/* Generated by Cython 0.18 on Tue Jan 29 11:58:56 2013 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02040000
    #error Cython requires Python 2.4+.
#else
#include <stddef.h> /* For offsetof */
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define CYTHON_FORMAT_SSIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   __Pyx_PyInt_AsInt(o)
  #define PyNumber_Index(o)    ((PyNumber_Check(o) && !PyFloat_Check(o)) ? PyNumber_Int(o) : \
                                (PyErr_Format(PyExc_TypeError, \
                                              "expected index value, got %.200s", Py_TYPE(o)->tp_name), \
                                 (PyObject*)0))
  #define __Pyx_PyIndex_Check(o) (PyNumber_Check(o) && !PyFloat_Check(o) && \
                                  !PyComplex_Check(o))
  #define PyIndex_Check __Pyx_PyIndex_Check
  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
  #define __PYX_BUILD_PY_SSIZE_T "i"
#else
  #define __PYX_BUILD_PY_SSIZE_T "n"
  #define CYTHON_FORMAT_SSIZE_T "z"
  #define __Pyx_PyIndex_Check PyIndex_Check
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)
  typedef struct {
     void *buf;
     PyObject *obj;
     Py_ssize_t len;
     Py_ssize_t itemsize;
     int readonly;
     int ndim;
     char *format;
     Py_ssize_t *shape;
     Py_ssize_t *strides;
     Py_ssize_t *suboffsets;
     void *internal;
  } Py_buffer;
  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
  #define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_FORMAT | PyBUF_WRITABLE)
  #define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_FORMAT | PyBUF_WRITABLE)
  typedef int (*getbufferproc)(PyObject *, Py_buffer *, int);
  typedef void (*releasebufferproc)(PyObject *, Py_buffer *);
#endif
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
#if PY_MAJOR_VERSION < 3 && PY_MINOR_VERSION < 6
  #define PyUnicode_FromString(s) PyUnicode_Decode(s, strlen(s), "UTF-8", "strict")
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((k=k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PyBytesObject                PyStringObject
  #define PyBytes_Type                 PyString_Type
  #define PyBytes_Check                PyString_Check
  #define PyBytes_CheckExact           PyString_CheckExact
  #define PyBytes_FromString           PyString_FromString
  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
  #define PyBytes_FromFormat           PyString_FromFormat
  #define PyBytes_DecodeEscape         PyString_DecodeEscape
  #define PyBytes_AsString             PyString_AsString
  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
  #define PyBytes_Size                 PyString_Size
  #define PyBytes_AS_STRING            PyString_AS_STRING
  #define PyBytes_GET_SIZE             PyString_GET_SIZE
  #define PyBytes_Repr                 PyString_Repr
  #define PyBytes_Concat               PyString_Concat
  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
#endif
#if PY_VERSION_HEX < 0x02060000
  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_VERSION_HEX < 0x03020000
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
#else
  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__talib__func
#define __PYX_HAVE_API__talib__func
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"
#include "math.h"
#include "ta-lib/ta_libc.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const long n; const char* encoding; const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/

#define __Pyx_PyBytes_FromUString(s) PyBytes_FromString((char*)s)
#define __Pyx_PyBytes_AsUString(s)   ((unsigned char*) PyBytes_AsString(s))
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))


#ifdef __GNUC__
  /* Test for GCC > 2.95 */
  #if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
    #define likely(x)   __builtin_expect(!!(x), 1)
    #define unlikely(x) __builtin_expect(!!(x), 0)
  #else /* __GNUC__ > 2 ... */
    #define likely(x)   (x)
    #define unlikely(x) (x)
  #endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;

#if !defined(CYTHON_CCOMPLEX)
  #if defined(__cplusplus)
    #define CYTHON_CCOMPLEX 1
  #elif defined(_Complex_I)
    #define CYTHON_CCOMPLEX 1
  #else
    #define CYTHON_CCOMPLEX 0
  #endif
#endif
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #include <complex>
  #else
    #include <complex.h>
  #endif
#endif
#if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
  #undef _Complex_I
  #define _Complex_I 1.0fj
#endif


static const char *__pyx_f[] = {
  "func.pyx",
  "numpy.pxd",
  "type.pxd",
};

/* "numpy.pxd":723
 * # in Cython to enable them only on the right systems.
 * 
 * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t
 */
typedef npy_int8 __pyx_t_5numpy_int8_t;

/* "numpy.pxd":724
 * 
 * ctypedef npy_int8       int8_t
 * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int32      int32_t
 * ctypedef npy_int64      int64_t
 */
typedef npy_int16 __pyx_t_5numpy_int16_t;

/* "numpy.pxd":725
 * ctypedef npy_int8       int8_t
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_int64      int64_t
 * #ctypedef npy_int96      int96_t
 */
typedef npy_int32 __pyx_t_5numpy_int32_t;

/* "numpy.pxd":726
 * ctypedef npy_int16      int16_t
 * ctypedef npy_int32      int32_t
 * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_int96      int96_t
 * #ctypedef npy_int128     int128_t
 */
typedef npy_int64 __pyx_t_5numpy_int64_t;

/* "numpy.pxd":730
 * #ctypedef npy_int128     int128_t
 * 
 * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t
 */
typedef npy_uint8 __pyx_t_5numpy_uint8_t;

/* "numpy.pxd":731
 * 
 * ctypedef npy_uint8      uint8_t
 * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint32     uint32_t
 * ctypedef npy_uint64     uint64_t
 */
typedef npy_uint16 __pyx_t_5numpy_uint16_t;

/* "numpy.pxd":732
 * ctypedef npy_uint8      uint8_t
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uint64     uint64_t
 * #ctypedef npy_uint96     uint96_t
 */
typedef npy_uint32 __pyx_t_5numpy_uint32_t;

/* "numpy.pxd":733
 * ctypedef npy_uint16     uint16_t
 * ctypedef npy_uint32     uint32_t
 * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_uint96     uint96_t
 * #ctypedef npy_uint128    uint128_t
 */
typedef npy_uint64 __pyx_t_5numpy_uint64_t;

/* "numpy.pxd":737
 * #ctypedef npy_uint128    uint128_t
 * 
 * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
 * ctypedef npy_float64    float64_t
 * #ctypedef npy_float80    float80_t
 */
typedef npy_float32 __pyx_t_5numpy_float32_t;

/* "numpy.pxd":738
 * 
 * ctypedef npy_float32    float32_t
 * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
 * #ctypedef npy_float80    float80_t
 * #ctypedef npy_float128   float128_t
 */
typedef npy_float64 __pyx_t_5numpy_float64_t;

/* "numpy.pxd":747
 * # The int types are mapped a bit surprising --
 * # numpy.int corresponds to 'l' and numpy.long to 'q'
 * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longlong   long_t
 * ctypedef npy_longlong   longlong_t
 */
typedef npy_long __pyx_t_5numpy_int_t;

/* "numpy.pxd":748
 * # numpy.int corresponds to 'l' and numpy.long to 'q'
 * ctypedef npy_long       int_t
 * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longlong   longlong_t
 * 
 */
typedef npy_longlong __pyx_t_5numpy_long_t;

/* "numpy.pxd":749
 * ctypedef npy_long       int_t
 * ctypedef npy_longlong   long_t
 * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_ulong      uint_t
 */
typedef npy_longlong __pyx_t_5numpy_longlong_t;

/* "numpy.pxd":751
 * ctypedef npy_longlong   longlong_t
 * 
 * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
 * ctypedef npy_ulonglong  ulong_t
 * ctypedef npy_ulonglong  ulonglong_t
 */
typedef npy_ulong __pyx_t_5numpy_uint_t;

/* "numpy.pxd":752
 * 
 * ctypedef npy_ulong      uint_t
 * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
 * ctypedef npy_ulonglong  ulonglong_t
 * 
 */
typedef npy_ulonglong __pyx_t_5numpy_ulong_t;

/* "numpy.pxd":753
 * ctypedef npy_ulong      uint_t
 * ctypedef npy_ulonglong  ulong_t
 * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_intp       intp_t
 */
typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;

/* "numpy.pxd":755
 * ctypedef npy_ulonglong  ulonglong_t
 * 
 * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
 * ctypedef npy_uintp      uintp_t
 * 
 */
typedef npy_intp __pyx_t_5numpy_intp_t;

/* "numpy.pxd":756
 * 
 * ctypedef npy_intp       intp_t
 * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_double     float_t
 */
typedef npy_uintp __pyx_t_5numpy_uintp_t;

/* "numpy.pxd":758
 * ctypedef npy_uintp      uintp_t
 * 
 * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
 * ctypedef npy_double     double_t
 * ctypedef npy_longdouble longdouble_t
 */
typedef npy_double __pyx_t_5numpy_float_t;

/* "numpy.pxd":759
 * 
 * ctypedef npy_double     float_t
 * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
 * ctypedef npy_longdouble longdouble_t
 * 
 */
typedef npy_double __pyx_t_5numpy_double_t;

/* "numpy.pxd":760
 * ctypedef npy_double     float_t
 * ctypedef npy_double     double_t
 * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_cfloat      cfloat_t
 */
typedef npy_longdouble __pyx_t_5numpy_longdouble_t;

/* "talib/func.pyx":7
 * from .common cimport _ta_check_success
 * 
 * ctypedef np.double_t double_t             # <<<<<<<<<<<<<<
 * ctypedef np.int32_t int32_t
 * 
 */
typedef __pyx_t_5numpy_double_t __pyx_t_5talib_4func_double_t;

/* "talib/func.pyx":8
 * 
 * ctypedef np.double_t double_t
 * ctypedef np.int32_t int32_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef int TA_RetCode
 */
typedef __pyx_t_5numpy_int32_t __pyx_t_5talib_4func_int32_t;

/* "talib/func.pyx":10
 * ctypedef np.int32_t int32_t
 * 
 * ctypedef int TA_RetCode             # <<<<<<<<<<<<<<
 * ctypedef int TA_MAType
 * 
 */
typedef int __pyx_t_5talib_4func_TA_RetCode;

/* "talib/func.pyx":11
 * 
 * ctypedef int TA_RetCode
 * ctypedef int TA_MAType             # <<<<<<<<<<<<<<
 * 
 * cdef double NaN = nan
 */
typedef int __pyx_t_5talib_4func_TA_MAType;
#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< float > __pyx_t_float_complex;
  #else
    typedef float _Complex __pyx_t_float_complex;
  #endif
#else
    typedef struct { float real, imag; } __pyx_t_float_complex;
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    typedef ::std::complex< double > __pyx_t_double_complex;
  #else
    typedef double _Complex __pyx_t_double_complex;
  #endif
#else
    typedef struct { double real, imag; } __pyx_t_double_complex;
#endif


/*--- Type declarations ---*/

/* "numpy.pxd":762
 * ctypedef npy_longdouble longdouble_t
 * 
 * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
 * ctypedef npy_cdouble     cdouble_t
 * ctypedef npy_clongdouble clongdouble_t
 */
typedef npy_cfloat __pyx_t_5numpy_cfloat_t;

/* "numpy.pxd":763
 * 
 * ctypedef npy_cfloat      cfloat_t
 * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
 * ctypedef npy_clongdouble clongdouble_t
 * 
 */
typedef npy_cdouble __pyx_t_5numpy_cdouble_t;

/* "numpy.pxd":764
 * ctypedef npy_cfloat      cfloat_t
 * ctypedef npy_cdouble     cdouble_t
 * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
 * 
 * ctypedef npy_cdouble     complex_t
 */
typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;

/* "numpy.pxd":766
 * ctypedef npy_clongdouble clongdouble_t
 * 
 * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 */
typedef npy_cdouble __pyx_t_5numpy_complex_t;
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname); /*proto*/
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif /* CYTHON_REFNANNY */
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact); /*proto*/

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause); /*proto*/

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/

static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name); /*proto*/

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
    const char* function_name); /*proto*/

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

static CYTHON_INLINE int __Pyx_IterFinish(void); /*proto*/

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level); /*proto*/

static CYTHON_INLINE void __Pyx_RaiseImportError(PyObject *name);

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    #define __Pyx_CREAL(z) ((z).real())
    #define __Pyx_CIMAG(z) ((z).imag())
  #else
    #define __Pyx_CREAL(z) (__real__(z))
    #define __Pyx_CIMAG(z) (__imag__(z))
  #endif
#else
    #define __Pyx_CREAL(z) ((z).real)
    #define __Pyx_CIMAG(z) ((z).imag)
#endif
#if defined(_WIN32) && defined(__cplusplus) && CYTHON_CCOMPLEX
    #define __Pyx_SET_CREAL(z,x) ((z).real(x))
    #define __Pyx_SET_CIMAG(z,y) ((z).imag(y))
#else
    #define __Pyx_SET_CREAL(z,x) __Pyx_CREAL(z) = (x)
    #define __Pyx_SET_CIMAG(z,y) __Pyx_CIMAG(z) = (y)
#endif

static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float, float);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eqf(a, b)   ((a)==(b))
    #define __Pyx_c_sumf(a, b)  ((a)+(b))
    #define __Pyx_c_difff(a, b) ((a)-(b))
    #define __Pyx_c_prodf(a, b) ((a)*(b))
    #define __Pyx_c_quotf(a, b) ((a)/(b))
    #define __Pyx_c_negf(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zerof(z) ((z)==(float)0)
    #define __Pyx_c_conjf(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_absf(z)     (::std::abs(z))
        #define __Pyx_c_powf(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zerof(z) ((z)==0)
    #define __Pyx_c_conjf(z)    (conjf(z))
    #if 1
        #define __Pyx_c_absf(z)     (cabsf(z))
        #define __Pyx_c_powf(a, b)  (cpowf(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex, __pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex);
    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex);
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex);
    #if 1
        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex);
        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex, __pyx_t_float_complex);
    #endif
#endif

static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double, double);

#if CYTHON_CCOMPLEX
    #define __Pyx_c_eq(a, b)   ((a)==(b))
    #define __Pyx_c_sum(a, b)  ((a)+(b))
    #define __Pyx_c_diff(a, b) ((a)-(b))
    #define __Pyx_c_prod(a, b) ((a)*(b))
    #define __Pyx_c_quot(a, b) ((a)/(b))
    #define __Pyx_c_neg(a)     (-(a))
  #ifdef __cplusplus
    #define __Pyx_c_is_zero(z) ((z)==(double)0)
    #define __Pyx_c_conj(z)    (::std::conj(z))
    #if 1
        #define __Pyx_c_abs(z)     (::std::abs(z))
        #define __Pyx_c_pow(a, b)  (::std::pow(a, b))
    #endif
  #else
    #define __Pyx_c_is_zero(z) ((z)==0)
    #define __Pyx_c_conj(z)    (conj(z))
    #if 1
        #define __Pyx_c_abs(z)     (cabs(z))
        #define __Pyx_c_pow(a, b)  (cpow(a, b))
    #endif
 #endif
#else
    static CYTHON_INLINE int __Pyx_c_eq(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot(__pyx_t_double_complex, __pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg(__pyx_t_double_complex);
    static CYTHON_INLINE int __Pyx_c_is_zero(__pyx_t_double_complex);
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex);
    #if 1
        static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex);
        static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow(__pyx_t_double_complex, __pyx_t_double_complex);
    #endif
#endif

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);

static int __Pyx_check_binary_version(void);

#if !defined(__Pyx_PyIdentifier_FromString)
#if PY_MAJOR_VERSION < 3
  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
#else
  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
#endif
#endif

static PyObject *__Pyx_ImportModule(const char *name); /*proto*/

static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);  /*proto*/

static int __Pyx_ImportFunction(PyObject *module, const char *funcname, void (**f)(void), const char *sig); /*proto*/

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/


/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cpython.object' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'numpy' */

/* Module declarations from 'numpy' */
static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
static PyTypeObject *__pyx_ptype_5numpy_flatiter = 0;
static PyTypeObject *__pyx_ptype_5numpy_broadcast = 0;
static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
static PyTypeObject *__pyx_ptype_5numpy_ufunc = 0;
static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/

/* Module declarations from 'talib.common' */
static PyObject *(*__pyx_f_5talib_6common__ta_check_success)(PyObject *, int, int __pyx_skip_dispatch); /*proto*/

/* Module declarations from 'talib.func' */
static double __pyx_v_5talib_4func_NaN;
#define __Pyx_MODULE_NAME "talib.func"
int __pyx_module_is_main_talib__func = 0;

/* Implementation of 'talib.func' */
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_RuntimeError;
static PyObject *__pyx_pf_5talib_4func_ACOS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_2AD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, PyArrayObject *__pyx_v_volume); /* proto */
static PyObject *__pyx_pf_5talib_4func_4ADD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1); /* proto */
static PyObject *__pyx_pf_5talib_4func_6ADOSC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, PyArrayObject *__pyx_v_volume, int __pyx_v_fastperiod, int __pyx_v_slowperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_8ADX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_10ADXR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_12APO(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_slowperiod, int __pyx_v_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_14AROON(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_16AROONOSC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_18ASIN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_20ATAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_22ATR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_24AVGPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_26BBANDS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_nbdevup, double __pyx_v_nbdevdn, int __pyx_v_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_28BETA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_30BOP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_32CCI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_34CDL2CROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_36CDL3BLACKCROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_38CDL3INSIDE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_40CDL3LINESTRIKE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_42CDL3OUTSIDE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_44CDL3STARSINSOUTH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_46CDL3WHITESOLDIERS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_48CDLABANDONEDBABY(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_50CDLADVANCEBLOCK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_52CDLBELTHOLD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_54CDLBREAKAWAY(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_56CDLCLOSINGMARUBOZU(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_58CDLCONCEALBABYSWALL(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_60CDLCOUNTERATTACK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_62CDLDARKCLOUDCOVER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_64CDLDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_66CDLDOJISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_68CDLDRAGONFLYDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_70CDLENGULFING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_72CDLEVENINGDOJISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_74CDLEVENINGSTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_76CDLGAPSIDESIDEWHITE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_78CDLGRAVESTONEDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_80CDLHAMMER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_82CDLHANGINGMAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_84CDLHARAMI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_86CDLHARAMICROSS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_88CDLHIGHWAVE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_90CDLHIKKAKE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_92CDLHIKKAKEMOD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_94CDLHOMINGPIGEON(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_96CDLIDENTICAL3CROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_98CDLINNECK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_100CDLINVERTEDHAMMER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_102CDLKICKING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_104CDLKICKINGBYLENGTH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_106CDLLADDERBOTTOM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_108CDLLONGLEGGEDDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_110CDLLONGLINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_112CDLMARUBOZU(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_114CDLMATCHINGLOW(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_116CDLMATHOLD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_118CDLMORNINGDOJISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_120CDLMORNINGSTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration); /* proto */
static PyObject *__pyx_pf_5talib_4func_122CDLONNECK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_124CDLPIERCING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_126CDLRICKSHAWMAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_128CDLRISEFALL3METHODS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_130CDLSEPARATINGLINES(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_132CDLSHOOTINGSTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_134CDLSHORTLINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_136CDLSPINNINGTOP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_138CDLSTALLEDPATTERN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_140CDLSTICKSANDWICH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_142CDLTAKURI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_144CDLTASUKIGAP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_146CDLTHRUSTING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_148CDLTRISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_150CDLUNIQUE3RIVER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_152CDLUPSIDEGAP2CROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_154CDLXSIDEGAP3METHODS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_156CEIL(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_158CMO(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_160CORREL(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_162COS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_164COSH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_166DEMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_168DIV(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1); /* proto */
static PyObject *__pyx_pf_5talib_4func_170DX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_172EMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_174EXP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_176FLOOR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_178HT_DCPERIOD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_180HT_DCPHASE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_182HT_PHASOR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_184HT_SINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_186HT_TRENDLINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_188HT_TRENDMODE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_190KAMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_192LINEARREG(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_194LINEARREG_ANGLE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_196LINEARREG_INTERCEPT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_198LINEARREG_SLOPE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_200LN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_202LOG10(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_204MA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, int __pyx_v_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_206MACD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_slowperiod, int __pyx_v_signalperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_208MACDEXT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_fastmatype, int __pyx_v_slowperiod, int __pyx_v_slowmatype, int __pyx_v_signalperiod, int __pyx_v_signalmatype); /* proto */
static PyObject *__pyx_pf_5talib_4func_210MACDFIX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_signalperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_212MAMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, double __pyx_v_fastlimit, double __pyx_v_slowlimit); /* proto */
static PyObject *__pyx_pf_5talib_4func_214MAVP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, PyArrayObject *__pyx_v_periods, int __pyx_v_minperiod, int __pyx_v_maxperiod, int __pyx_v_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_216MAX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_218MAXINDEX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_220MEDPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low); /* proto */
static PyObject *__pyx_pf_5talib_4func_222MFI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, PyArrayObject *__pyx_v_volume, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_224MIDPOINT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_226MIDPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_228MIN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_230MININDEX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_232MINMAX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_234MINMAXINDEX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_236MINUS_DI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_238MINUS_DM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_240MOM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_242MULT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1); /* proto */
static PyObject *__pyx_pf_5talib_4func_244NATR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_246OBV(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, PyArrayObject *__pyx_v_volume); /* proto */
static PyObject *__pyx_pf_5talib_4func_248PLUS_DI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_250PLUS_DM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_252PPO(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_slowperiod, int __pyx_v_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_254ROC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_256ROCP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_258ROCR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_260ROCR100(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_262RSI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_264SAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, double __pyx_v_acceleration, double __pyx_v_maximum); /* proto */
static PyObject *__pyx_pf_5talib_4func_266SAREXT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, double __pyx_v_startvalue, double __pyx_v_offsetonreverse, double __pyx_v_accelerationinitlong, double __pyx_v_accelerationlong, double __pyx_v_accelerationmaxlong, double __pyx_v_accelerationinitshort, double __pyx_v_accelerationshort, double __pyx_v_accelerationmaxshort); /* proto */
static PyObject *__pyx_pf_5talib_4func_268SIN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_270SINH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_272SMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_274SQRT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_276STDDEV(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_nbdev); /* proto */
static PyObject *__pyx_pf_5talib_4func_278STOCH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_fastk_period, int __pyx_v_slowk_period, int __pyx_v_slowk_matype, int __pyx_v_slowd_period, int __pyx_v_slowd_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_280STOCHF(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_fastk_period, int __pyx_v_fastd_period, int __pyx_v_fastd_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_282STOCHRSI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, int __pyx_v_fastk_period, int __pyx_v_fastd_period, int __pyx_v_fastd_matype); /* proto */
static PyObject *__pyx_pf_5talib_4func_284SUB(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1); /* proto */
static PyObject *__pyx_pf_5talib_4func_286SUM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_288T3(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_vfactor); /* proto */
static PyObject *__pyx_pf_5talib_4func_290TAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_292TANH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real); /* proto */
static PyObject *__pyx_pf_5talib_4func_294TEMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_296TRANGE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_298TRIMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_300TRIX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_302TSF(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_304TYPPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_306ULTOSC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod1, int __pyx_v_timeperiod2, int __pyx_v_timeperiod3); /* proto */
static PyObject *__pyx_pf_5talib_4func_308VAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_nbdev); /* proto */
static PyObject *__pyx_pf_5talib_4func_310WCLPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close); /* proto */
static PyObject *__pyx_pf_5talib_4func_312WILLR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod); /* proto */
static PyObject *__pyx_pf_5talib_4func_314WMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod); /* proto */
static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
static char __pyx_k_1[] = "real is not double";
static char __pyx_k_2[] = "real has wrong dimensions";
static char __pyx_k_3[] = "inputs are all NaN";
static char __pyx_k_5[] = "high is not double";
static char __pyx_k_6[] = "high has wrong dimensions";
static char __pyx_k_7[] = "low is not double";
static char __pyx_k_8[] = "low has wrong dimensions";
static char __pyx_k_9[] = "close is not double";
static char __pyx_k_10[] = "close has wrong dimensions";
static char __pyx_k_11[] = "volume is not double";
static char __pyx_k_12[] = "volume has wrong dimensions";
static char __pyx_k_14[] = "real0 is not double";
static char __pyx_k_15[] = "real0 has wrong dimensions";
static char __pyx_k_16[] = "real1 is not double";
static char __pyx_k_17[] = "real1 has wrong dimensions";
static char __pyx_k_28[] = "open is not double";
static char __pyx_k_29[] = "open has wrong dimensions";
static char __pyx_k_42[] = "TA_CDL3WHITESOLDIERS";
static char __pyx_k_48[] = "TA_CDLCLOSINGMARUBOZU";
static char __pyx_k_50[] = "TA_CDLCONCEALBABYSWALL";
static char __pyx_k_53[] = "TA_CDLDARKCLOUDCOVER";
static char __pyx_k_59[] = "TA_CDLEVENINGDOJISTAR";
static char __pyx_k_62[] = "TA_CDLGAPSIDESIDEWHITE";
static char __pyx_k_64[] = "TA_CDLGRAVESTONEDOJI";
static char __pyx_k_74[] = "TA_CDLIDENTICAL3CROWS";
static char __pyx_k_77[] = "TA_CDLINVERTEDHAMMER";
static char __pyx_k_80[] = "TA_CDLKICKINGBYLENGTH";
static char __pyx_k_83[] = "TA_CDLLONGLEGGEDDOJI";
static char __pyx_k_89[] = "TA_CDLMORNINGDOJISTAR";
static char __pyx_k_95[] = "TA_CDLRISEFALL3METHODS";
static char __pyx_k_97[] = "TA_CDLSEPARATINGLINES";
static char __pyx_k__B[] = "B";
static char __pyx_k__H[] = "H";
static char __pyx_k__I[] = "I";
static char __pyx_k__L[] = "L";
static char __pyx_k__O[] = "O";
static char __pyx_k__Q[] = "Q";
static char __pyx_k__b[] = "b";
static char __pyx_k__d[] = "d";
static char __pyx_k__f[] = "f";
static char __pyx_k__g[] = "g";
static char __pyx_k__h[] = "h";
static char __pyx_k__i[] = "i";
static char __pyx_k__l[] = "l";
static char __pyx_k__q[] = "q";
static char __pyx_k_102[] = "TA_CDLSTALLEDPATTERN";
static char __pyx_k_110[] = "TA_CDLUPSIDEGAP2CROWS";
static char __pyx_k_112[] = "TA_CDLXSIDEGAP3METHODS";
static char __pyx_k_134[] = "TA_LINEARREG_INTERCEPT";
static char __pyx_k_143[] = "periods is not double";
static char __pyx_k_144[] = "periods has wrong dimensions";
static char __pyx_k_171[] = "accelerationinitlong";
static char __pyx_k_172[] = "accelerationinitshort";
static char __pyx_k_173[] = "accelerationmaxshort";
static char __pyx_k_199[] = "ndarray is not C contiguous";
static char __pyx_k_201[] = "ndarray is not Fortran contiguous";
static char __pyx_k_203[] = "Non-native byte order not supported";
static char __pyx_k_205[] = "unknown dtype code in numpy.pxd (%d)";
static char __pyx_k_206[] = "Format string allocated too short, see comment in numpy.pxd";
static char __pyx_k_209[] = "Format string allocated too short.";
static char __pyx_k_213[] = "/Users/jbenedik/Dev/ta-lib/talib/func.pyx";
static char __pyx_k_214[] = "talib.func";
static char __pyx_k_239[] = "outrealupperband_data";
static char __pyx_k_240[] = "outrealmiddleband_data";
static char __pyx_k_241[] = "outreallowerband_data";
static char __pyx_k__AD[] = "AD";
static char __pyx_k__DX[] = "DX";
static char __pyx_k__LN[] = "LN";
static char __pyx_k__MA[] = "MA";
static char __pyx_k__T3[] = "T3";
static char __pyx_k__Zd[] = "Zd";
static char __pyx_k__Zf[] = "Zf";
static char __pyx_k__Zg[] = "Zg";
static char __pyx_k__ADD[] = "ADD";
static char __pyx_k__ADX[] = "ADX";
static char __pyx_k__APO[] = "APO";
static char __pyx_k__ATR[] = "ATR";
static char __pyx_k__BOP[] = "BOP";
static char __pyx_k__CCI[] = "CCI";
static char __pyx_k__CMO[] = "CMO";
static char __pyx_k__COS[] = "COS";
static char __pyx_k__DIV[] = "DIV";
static char __pyx_k__EMA[] = "EMA";
static char __pyx_k__EXP[] = "EXP";
static char __pyx_k__MAX[] = "MAX";
static char __pyx_k__MFI[] = "MFI";
static char __pyx_k__MIN[] = "MIN";
static char __pyx_k__MOM[] = "MOM";
static char __pyx_k__OBV[] = "OBV";
static char __pyx_k__PPO[] = "PPO";
static char __pyx_k__ROC[] = "ROC";
static char __pyx_k__RSI[] = "RSI";
static char __pyx_k__SAR[] = "SAR";
static char __pyx_k__SIN[] = "SIN";
static char __pyx_k__SMA[] = "SMA";
static char __pyx_k__SUB[] = "SUB";
static char __pyx_k__SUM[] = "SUM";
static char __pyx_k__TAN[] = "TAN";
static char __pyx_k__TSF[] = "TSF";
static char __pyx_k__VAR[] = "VAR";
static char __pyx_k__WMA[] = "WMA";
static char __pyx_k__low[] = "low";
static char __pyx_k__nan[] = "nan";
static char __pyx_k__ACOS[] = "ACOS";
static char __pyx_k__ADXR[] = "ADXR";
static char __pyx_k__ASIN[] = "ASIN";
static char __pyx_k__ATAN[] = "ATAN";
static char __pyx_k__BETA[] = "BETA";
static char __pyx_k__CEIL[] = "CEIL";
static char __pyx_k__COSH[] = "COSH";
static char __pyx_k__DEMA[] = "DEMA";
static char __pyx_k__KAMA[] = "KAMA";
static char __pyx_k__MACD[] = "MACD";
static char __pyx_k__MAMA[] = "MAMA";
static char __pyx_k__MAVP[] = "MAVP";
static char __pyx_k__MULT[] = "MULT";
static char __pyx_k__NATR[] = "NATR";
static char __pyx_k__ROCP[] = "ROCP";
static char __pyx_k__ROCR[] = "ROCR";
static char __pyx_k__SINH[] = "SINH";
static char __pyx_k__SQRT[] = "SQRT";
static char __pyx_k__TANH[] = "TANH";
static char __pyx_k__TEMA[] = "TEMA";
static char __pyx_k__TRIX[] = "TRIX";
static char __pyx_k__high[] = "high";
static char __pyx_k__open[] = "open";
static char __pyx_k__real[] = "real";
static char __pyx_k__ADOSC[] = "ADOSC";
static char __pyx_k__AROON[] = "AROON";
static char __pyx_k__FLOOR[] = "FLOOR";
static char __pyx_k__LOG10[] = "LOG10";
static char __pyx_k__STOCH[] = "STOCH";
static char __pyx_k__TA_AD[] = "TA_AD";
static char __pyx_k__TA_DX[] = "TA_DX";
static char __pyx_k__TA_LN[] = "TA_LN";
static char __pyx_k__TA_MA[] = "TA_MA";
static char __pyx_k__TA_T3[] = "TA_T3";
static char __pyx_k__TRIMA[] = "TRIMA";
static char __pyx_k__WILLR[] = "WILLR";
static char __pyx_k__close[] = "close";
static char __pyx_k__nbdev[] = "nbdev";
static char __pyx_k__numpy[] = "numpy";
static char __pyx_k__range[] = "range";
static char __pyx_k__real0[] = "real0";
static char __pyx_k__real1[] = "real1";
static char __pyx_k__BBANDS[] = "BBANDS";
static char __pyx_k__CORREL[] = "CORREL";
static char __pyx_k__MINMAX[] = "MINMAX";
static char __pyx_k__SAREXT[] = "SAREXT";
static char __pyx_k__STDDEV[] = "STDDEV";
static char __pyx_k__STOCHF[] = "STOCHF";
static char __pyx_k__TA_ADD[] = "TA_ADD";
static char __pyx_k__TA_ADX[] = "TA_ADX";
static char __pyx_k__TA_APO[] = "TA_APO";
static char __pyx_k__TA_ATR[] = "TA_ATR";
static char __pyx_k__TA_BOP[] = "TA_BOP";
static char __pyx_k__TA_CCI[] = "TA_CCI";
static char __pyx_k__TA_CMO[] = "TA_CMO";
static char __pyx_k__TA_COS[] = "TA_COS";
static char __pyx_k__TA_DIV[] = "TA_DIV";
static char __pyx_k__TA_EMA[] = "TA_EMA";
static char __pyx_k__TA_EXP[] = "TA_EXP";
static char __pyx_k__TA_MAX[] = "TA_MAX";
static char __pyx_k__TA_MFI[] = "TA_MFI";
static char __pyx_k__TA_MIN[] = "TA_MIN";
static char __pyx_k__TA_MOM[] = "TA_MOM";
static char __pyx_k__TA_OBV[] = "TA_OBV";
static char __pyx_k__TA_PPO[] = "TA_PPO";
static char __pyx_k__TA_ROC[] = "TA_ROC";
static char __pyx_k__TA_RSI[] = "TA_RSI";
static char __pyx_k__TA_SAR[] = "TA_SAR";
static char __pyx_k__TA_SIN[] = "TA_SIN";
static char __pyx_k__TA_SMA[] = "TA_SMA";
static char __pyx_k__TA_SUB[] = "TA_SUB";
static char __pyx_k__TA_SUM[] = "TA_SUM";
static char __pyx_k__TA_TAN[] = "TA_TAN";
static char __pyx_k__TA_TSF[] = "TA_TSF";
static char __pyx_k__TA_VAR[] = "TA_VAR";
static char __pyx_k__TA_WMA[] = "TA_WMA";
static char __pyx_k__TRANGE[] = "TRANGE";
static char __pyx_k__ULTOSC[] = "ULTOSC";
static char __pyx_k__begidx[] = "begidx";
static char __pyx_k__endidx[] = "endidx";
static char __pyx_k__length[] = "length";
static char __pyx_k__matype[] = "matype";
static char __pyx_k__outmax[] = "outmax";
static char __pyx_k__outmin[] = "outmin";
static char __pyx_k__volume[] = "volume";
static char __pyx_k__CDLDOJI[] = "CDLDOJI";
static char __pyx_k__HT_SINE[] = "HT_SINE";
static char __pyx_k__MACDEXT[] = "MACDEXT";
static char __pyx_k__MACDFIX[] = "MACDFIX";
static char __pyx_k__PLUS_DI[] = "PLUS_DI";
static char __pyx_k__PLUS_DM[] = "PLUS_DM";
static char __pyx_k__ROCR100[] = "ROCR100";
static char __pyx_k__TA_ACOS[] = "TA_ACOS";
static char __pyx_k__TA_ADXR[] = "TA_ADXR";
static char __pyx_k__TA_ASIN[] = "TA_ASIN";
static char __pyx_k__TA_ATAN[] = "TA_ATAN";
static char __pyx_k__TA_BETA[] = "TA_BETA";
static char __pyx_k__TA_CEIL[] = "TA_CEIL";
static char __pyx_k__TA_COSH[] = "TA_COSH";
static char __pyx_k__TA_DEMA[] = "TA_DEMA";
static char __pyx_k__TA_KAMA[] = "TA_KAMA";
static char __pyx_k__TA_MACD[] = "TA_MACD";
static char __pyx_k__TA_MAMA[] = "TA_MAMA";
static char __pyx_k__TA_MAVP[] = "TA_MAVP";
static char __pyx_k__TA_MULT[] = "TA_MULT";
static char __pyx_k__TA_NATR[] = "TA_NATR";
static char __pyx_k__TA_ROCP[] = "TA_ROCP";
static char __pyx_k__TA_ROCR[] = "TA_ROCR";
static char __pyx_k__TA_SINH[] = "TA_SINH";
static char __pyx_k__TA_SQRT[] = "TA_SQRT";
static char __pyx_k__TA_TANH[] = "TA_TANH";
static char __pyx_k__TA_TEMA[] = "TA_TEMA";
static char __pyx_k__TA_TRIX[] = "TA_TRIX";
static char __pyx_k____all__[] = "__all__";
static char __pyx_k__maximum[] = "maximum";
static char __pyx_k__nbdevdn[] = "nbdevdn";
static char __pyx_k__nbdevup[] = "nbdevup";
static char __pyx_k__outfama[] = "outfama";
static char __pyx_k__outmacd[] = "outmacd";
static char __pyx_k__outmama[] = "outmama";
static char __pyx_k__outreal[] = "outreal";
static char __pyx_k__outsine[] = "outsine";
static char __pyx_k__periods[] = "periods";
static char __pyx_k__retCode[] = "retCode";
static char __pyx_k__vfactor[] = "vfactor";
static char __pyx_k__AROONOSC[] = "AROONOSC";
static char __pyx_k__AVGPRICE[] = "AVGPRICE";
static char __pyx_k__MAXINDEX[] = "MAXINDEX";
static char __pyx_k__MEDPRICE[] = "MEDPRICE";
static char __pyx_k__MIDPOINT[] = "MIDPOINT";
static char __pyx_k__MIDPRICE[] = "MIDPRICE";
static char __pyx_k__MININDEX[] = "MININDEX";
static char __pyx_k__MINUS_DI[] = "MINUS_DI";
static char __pyx_k__MINUS_DM[] = "MINUS_DM";
static char __pyx_k__STOCHRSI[] = "STOCHRSI";
static char __pyx_k__TA_ADOSC[] = "TA_ADOSC";
static char __pyx_k__TA_AROON[] = "TA_AROON";
static char __pyx_k__TA_FLOOR[] = "TA_FLOOR";
static char __pyx_k__TA_LOG10[] = "TA_LOG10";
static char __pyx_k__TA_STOCH[] = "TA_STOCH";
static char __pyx_k__TA_TRIMA[] = "TA_TRIMA";
static char __pyx_k__TA_WILLR[] = "TA_WILLR";
static char __pyx_k__TYPPRICE[] = "TYPPRICE";
static char __pyx_k__WCLPRICE[] = "WCLPRICE";
static char __pyx_k____main__[] = "__main__";
static char __pyx_k____test__[] = "__test__";
static char __pyx_k__lookback[] = "lookback";
static char __pyx_k__low_data[] = "low_data";
static char __pyx_k__outfastd[] = "outfastd";
static char __pyx_k__outfastk[] = "outfastk";
static char __pyx_k__outslowd[] = "outslowd";
static char __pyx_k__outslowk[] = "outslowk";
static char __pyx_k__CDL2CROWS[] = "CDL2CROWS";
static char __pyx_k__CDLHAMMER[] = "CDLHAMMER";
static char __pyx_k__CDLHARAMI[] = "CDLHARAMI";
static char __pyx_k__CDLINNECK[] = "CDLINNECK";
static char __pyx_k__CDLONNECK[] = "CDLONNECK";
static char __pyx_k__CDLTAKURI[] = "CDLTAKURI";
static char __pyx_k__Exception[] = "Exception";
static char __pyx_k__HT_PHASOR[] = "HT_PHASOR";
static char __pyx_k__LINEARREG[] = "LINEARREG";
static char __pyx_k__TA_BBANDS[] = "TA_BBANDS";
static char __pyx_k__TA_CORREL[] = "TA_CORREL";
static char __pyx_k__TA_MINMAX[] = "TA_MINMAX";
static char __pyx_k__TA_SAREXT[] = "TA_SAREXT";
static char __pyx_k__TA_STDDEV[] = "TA_STDDEV";
static char __pyx_k__TA_STOCHF[] = "TA_STOCHF";
static char __pyx_k__TA_TRANGE[] = "TA_TRANGE";
static char __pyx_k__TA_ULTOSC[] = "TA_ULTOSC";
static char __pyx_k__fastlimit[] = "fastlimit";
static char __pyx_k__high_data[] = "high_data";
static char __pyx_k__maxperiod[] = "maxperiod";
static char __pyx_k__minperiod[] = "minperiod";
static char __pyx_k__open_data[] = "open_data";
static char __pyx_k__outbegidx[] = "outbegidx";
static char __pyx_k__outmaxidx[] = "outmaxidx";
static char __pyx_k__outminidx[] = "outminidx";
static char __pyx_k__real_data[] = "real_data";
static char __pyx_k__slowlimit[] = "slowlimit";
static char __pyx_k__CDL3INSIDE[] = "CDL3INSIDE";
static char __pyx_k__CDLHIKKAKE[] = "CDLHIKKAKE";
static char __pyx_k__CDLKICKING[] = "CDLKICKING";
static char __pyx_k__CDLMATHOLD[] = "CDLMATHOLD";
static char __pyx_k__CDLTRISTAR[] = "CDLTRISTAR";
static char __pyx_k__HT_DCPHASE[] = "HT_DCPHASE";
static char __pyx_k__TA_CDLDOJI[] = "TA_CDLDOJI";
static char __pyx_k__TA_HT_SINE[] = "TA_HT_SINE";
static char __pyx_k__TA_MACDEXT[] = "TA_MACDEXT";
static char __pyx_k__TA_MACDFIX[] = "TA_MACDFIX";
static char __pyx_k__TA_PLUS_DI[] = "TA_PLUS_DI";
static char __pyx_k__TA_PLUS_DM[] = "TA_PLUS_DM";
static char __pyx_k__TA_ROCR100[] = "TA_ROCR100";
static char __pyx_k__ValueError[] = "ValueError";
static char __pyx_k__close_data[] = "close_data";
static char __pyx_k__fastmatype[] = "fastmatype";
static char __pyx_k__fastperiod[] = "fastperiod";
static char __pyx_k__outaroonup[] = "outaroonup";
static char __pyx_k__outinphase[] = "outinphase";
static char __pyx_k__outinteger[] = "outinteger";
static char __pyx_k__real0_data[] = "real0_data";
static char __pyx_k__real1_data[] = "real1_data";
static char __pyx_k__slowmatype[] = "slowmatype";
static char __pyx_k__slowperiod[] = "slowperiod";
static char __pyx_k__startvalue[] = "startvalue";
static char __pyx_k__timeperiod[] = "timeperiod";
static char __pyx_k__CDL3OUTSIDE[] = "CDL3OUTSIDE";
static char __pyx_k__CDLBELTHOLD[] = "CDLBELTHOLD";
static char __pyx_k__CDLDOJISTAR[] = "CDLDOJISTAR";
static char __pyx_k__CDLHIGHWAVE[] = "CDLHIGHWAVE";
static char __pyx_k__CDLLONGLINE[] = "CDLLONGLINE";
static char __pyx_k__CDLMARUBOZU[] = "CDLMARUBOZU";
static char __pyx_k__CDLPIERCING[] = "CDLPIERCING";
static char __pyx_k__HT_DCPERIOD[] = "HT_DCPERIOD";
static char __pyx_k__MINMAXINDEX[] = "MINMAXINDEX";
static char __pyx_k__TA_AROONOSC[] = "TA_AROONOSC";
static char __pyx_k__TA_AVGPRICE[] = "TA_AVGPRICE";
static char __pyx_k__TA_MAXINDEX[] = "TA_MAXINDEX";
static char __pyx_k__TA_MEDPRICE[] = "TA_MEDPRICE";
static char __pyx_k__TA_MIDPOINT[] = "TA_MIDPOINT";
static char __pyx_k__TA_MIDPRICE[] = "TA_MIDPRICE";
static char __pyx_k__TA_MININDEX[] = "TA_MININDEX";
static char __pyx_k__TA_MINUS_DI[] = "TA_MINUS_DI";
static char __pyx_k__TA_MINUS_DM[] = "TA_MINUS_DM";
static char __pyx_k__TA_STOCHRSI[] = "TA_STOCHRSI";
static char __pyx_k__TA_TYPPRICE[] = "TA_TYPPRICE";
static char __pyx_k__TA_WCLPRICE[] = "TA_WCLPRICE";
static char __pyx_k__outleadsine[] = "outleadsine";
static char __pyx_k__outmacdhist[] = "outmacdhist";
static char __pyx_k__outmax_data[] = "outmax_data";
static char __pyx_k__outmin_data[] = "outmin_data";
static char __pyx_k__penetration[] = "penetration";
static char __pyx_k__timeperiod1[] = "timeperiod1";
static char __pyx_k__timeperiod2[] = "timeperiod2";
static char __pyx_k__timeperiod3[] = "timeperiod3";
static char __pyx_k__volume_data[] = "volume_data";
static char __pyx_k__CDLBREAKAWAY[] = "CDLBREAKAWAY";
static char __pyx_k__CDLENGULFING[] = "CDLENGULFING";
static char __pyx_k__CDLSHORTLINE[] = "CDLSHORTLINE";
static char __pyx_k__CDLTASUKIGAP[] = "CDLTASUKIGAP";
static char __pyx_k__CDLTHRUSTING[] = "CDLTHRUSTING";
static char __pyx_k__HT_TRENDLINE[] = "HT_TRENDLINE";
static char __pyx_k__HT_TRENDMODE[] = "HT_TRENDMODE";
static char __pyx_k__RuntimeError[] = "RuntimeError";
static char __pyx_k__TA_CDL2CROWS[] = "TA_CDL2CROWS";
static char __pyx_k__TA_CDLHAMMER[] = "TA_CDLHAMMER";
static char __pyx_k__TA_CDLHARAMI[] = "TA_CDLHARAMI";
static char __pyx_k__TA_CDLINNECK[] = "TA_CDLINNECK";
static char __pyx_k__TA_CDLONNECK[] = "TA_CDLONNECK";
static char __pyx_k__TA_CDLTAKURI[] = "TA_CDLTAKURI";
static char __pyx_k__TA_HT_PHASOR[] = "TA_HT_PHASOR";
static char __pyx_k__TA_LINEARREG[] = "TA_LINEARREG";
static char __pyx_k__acceleration[] = "acceleration";
static char __pyx_k__fastd_matype[] = "fastd_matype";
static char __pyx_k__fastd_period[] = "fastd_period";
static char __pyx_k__fastk_period[] = "fastk_period";
static char __pyx_k__outaroondown[] = "outaroondown";
static char __pyx_k__outfama_data[] = "outfama_data";
static char __pyx_k__outmacd_data[] = "outmacd_data";
static char __pyx_k__outmama_data[] = "outmama_data";
static char __pyx_k__outnbelement[] = "outnbelement";
static char __pyx_k__outreal_data[] = "outreal_data";
static char __pyx_k__outsine_data[] = "outsine_data";
static char __pyx_k__periods_data[] = "periods_data";
static char __pyx_k__signalmatype[] = "signalmatype";
static char __pyx_k__signalperiod[] = "signalperiod";
static char __pyx_k__slowd_matype[] = "slowd_matype";
static char __pyx_k__slowd_period[] = "slowd_period";
static char __pyx_k__slowk_matype[] = "slowk_matype";
static char __pyx_k__slowk_period[] = "slowk_period";
static char __pyx_k__CDLHANGINGMAN[] = "CDLHANGINGMAN";
static char __pyx_k__CDLHIKKAKEMOD[] = "CDLHIKKAKEMOD";
static char __pyx_k__TA_CDL3INSIDE[] = "TA_CDL3INSIDE";
static char __pyx_k__TA_CDLHIKKAKE[] = "TA_CDLHIKKAKE";
static char __pyx_k__TA_CDLKICKING[] = "TA_CDLKICKING";
static char __pyx_k__TA_CDLMATHOLD[] = "TA_CDLMATHOLD";
static char __pyx_k__TA_CDLTRISTAR[] = "TA_CDLTRISTAR";
static char __pyx_k__TA_HT_DCPHASE[] = "TA_HT_DCPHASE";
static char __pyx_k__outfastd_data[] = "outfastd_data";
static char __pyx_k__outfastk_data[] = "outfastk_data";
static char __pyx_k__outmacdsignal[] = "outmacdsignal";
static char __pyx_k__outquadrature[] = "outquadrature";
static char __pyx_k__outslowd_data[] = "outslowd_data";
static char __pyx_k__outslowk_data[] = "outslowk_data";
static char __pyx_k__CDL3BLACKCROWS[] = "CDL3BLACKCROWS";
static char __pyx_k__CDL3LINESTRIKE[] = "CDL3LINESTRIKE";
static char __pyx_k__CDLEVENINGSTAR[] = "CDLEVENINGSTAR";
static char __pyx_k__CDLHARAMICROSS[] = "CDLHARAMICROSS";
static char __pyx_k__CDLMATCHINGLOW[] = "CDLMATCHINGLOW";
static char __pyx_k__CDLMORNINGSTAR[] = "CDLMORNINGSTAR";
static char __pyx_k__CDLRICKSHAWMAN[] = "CDLRICKSHAWMAN";
static char __pyx_k__CDLSPINNINGTOP[] = "CDLSPINNINGTOP";
static char __pyx_k__TA_CDL3OUTSIDE[] = "TA_CDL3OUTSIDE";
static char __pyx_k__TA_CDLBELTHOLD[] = "TA_CDLBELTHOLD";
static char __pyx_k__TA_CDLDOJISTAR[] = "TA_CDLDOJISTAR";
static char __pyx_k__TA_CDLHIGHWAVE[] = "TA_CDLHIGHWAVE";
static char __pyx_k__TA_CDLLONGLINE[] = "TA_CDLLONGLINE";
static char __pyx_k__TA_CDLMARUBOZU[] = "TA_CDLMARUBOZU";
static char __pyx_k__TA_CDLPIERCING[] = "TA_CDLPIERCING";
static char __pyx_k__TA_HT_DCPERIOD[] = "TA_HT_DCPERIOD";
static char __pyx_k__TA_MINMAXINDEX[] = "TA_MINMAXINDEX";
static char __pyx_k__outmaxidx_data[] = "outmaxidx_data";
static char __pyx_k__outminidx_data[] = "outminidx_data";
static char __pyx_k__CDLADVANCEBLOCK[] = "CDLADVANCEBLOCK";
static char __pyx_k__CDLHOMINGPIGEON[] = "CDLHOMINGPIGEON";
static char __pyx_k__CDLLADDERBOTTOM[] = "CDLLADDERBOTTOM";
static char __pyx_k__CDLSHOOTINGSTAR[] = "CDLSHOOTINGSTAR";
static char __pyx_k__CDLUNIQUE3RIVER[] = "CDLUNIQUE3RIVER";
static char __pyx_k__LINEARREG_ANGLE[] = "LINEARREG_ANGLE";
static char __pyx_k__LINEARREG_SLOPE[] = "LINEARREG_SLOPE";
static char __pyx_k__TA_CDLBREAKAWAY[] = "TA_CDLBREAKAWAY";
static char __pyx_k__TA_CDLENGULFING[] = "TA_CDLENGULFING";
static char __pyx_k__TA_CDLSHORTLINE[] = "TA_CDLSHORTLINE";
static char __pyx_k__TA_CDLTASUKIGAP[] = "TA_CDLTASUKIGAP";
static char __pyx_k__TA_CDLTHRUSTING[] = "TA_CDLTHRUSTING";
static char __pyx_k__TA_HT_TRENDLINE[] = "TA_HT_TRENDLINE";
static char __pyx_k__TA_HT_TRENDMODE[] = "TA_HT_TRENDMODE";
static char __pyx_k__offsetonreverse[] = "offsetonreverse";
static char __pyx_k__outaroonup_data[] = "outaroonup_data";
static char __pyx_k__outinphase_data[] = "outinphase_data";
static char __pyx_k__outinteger_data[] = "outinteger_data";
static char __pyx_k__CDL3STARSINSOUTH[] = "CDL3STARSINSOUTH";
static char __pyx_k__CDLABANDONEDBABY[] = "CDLABANDONEDBABY";
static char __pyx_k__CDLCOUNTERATTACK[] = "CDLCOUNTERATTACK";
static char __pyx_k__CDLDRAGONFLYDOJI[] = "CDLDRAGONFLYDOJI";
static char __pyx_k__CDLSTICKSANDWICH[] = "CDLSTICKSANDWICH";
static char __pyx_k__TA_CDLHANGINGMAN[] = "TA_CDLHANGINGMAN";
static char __pyx_k__TA_CDLHIKKAKEMOD[] = "TA_CDLHIKKAKEMOD";
static char __pyx_k__accelerationlong[] = "accelerationlong";
static char __pyx_k__outleadsine_data[] = "outleadsine_data";
static char __pyx_k__outmacdhist_data[] = "outmacdhist_data";
static char __pyx_k__outreallowerband[] = "outreallowerband";
static char __pyx_k__outrealupperband[] = "outrealupperband";
static char __pyx_k__CDL3WHITESOLDIERS[] = "CDL3WHITESOLDIERS";
static char __pyx_k__CDLDARKCLOUDCOVER[] = "CDLDARKCLOUDCOVER";
static char __pyx_k__CDLGRAVESTONEDOJI[] = "CDLGRAVESTONEDOJI";
static char __pyx_k__CDLINVERTEDHAMMER[] = "CDLINVERTEDHAMMER";
static char __pyx_k__CDLLONGLEGGEDDOJI[] = "CDLLONGLEGGEDDOJI";
static char __pyx_k__CDLSTALLEDPATTERN[] = "CDLSTALLEDPATTERN";
static char __pyx_k__TA_CDL3BLACKCROWS[] = "TA_CDL3BLACKCROWS";
static char __pyx_k__TA_CDL3LINESTRIKE[] = "TA_CDL3LINESTRIKE";
static char __pyx_k__TA_CDLEVENINGSTAR[] = "TA_CDLEVENINGSTAR";
static char __pyx_k__TA_CDLHARAMICROSS[] = "TA_CDLHARAMICROSS";
static char __pyx_k__TA_CDLMATCHINGLOW[] = "TA_CDLMATCHINGLOW";
static char __pyx_k__TA_CDLMORNINGSTAR[] = "TA_CDLMORNINGSTAR";
static char __pyx_k__TA_CDLRICKSHAWMAN[] = "TA_CDLRICKSHAWMAN";
static char __pyx_k__TA_CDLSPINNINGTOP[] = "TA_CDLSPINNINGTOP";
static char __pyx_k__accelerationshort[] = "accelerationshort";
static char __pyx_k__outaroondown_data[] = "outaroondown_data";
static char __pyx_k__outrealmiddleband[] = "outrealmiddleband";
static char __pyx_k__CDLCLOSINGMARUBOZU[] = "CDLCLOSINGMARUBOZU";
static char __pyx_k__CDLEVENINGDOJISTAR[] = "CDLEVENINGDOJISTAR";
static char __pyx_k__CDLIDENTICAL3CROWS[] = "CDLIDENTICAL3CROWS";
static char __pyx_k__CDLKICKINGBYLENGTH[] = "CDLKICKINGBYLENGTH";
static char __pyx_k__CDLMORNINGDOJISTAR[] = "CDLMORNINGDOJISTAR";
static char __pyx_k__CDLSEPARATINGLINES[] = "CDLSEPARATINGLINES";
static char __pyx_k__CDLUPSIDEGAP2CROWS[] = "CDLUPSIDEGAP2CROWS";
static char __pyx_k__TA_CDLADVANCEBLOCK[] = "TA_CDLADVANCEBLOCK";
static char __pyx_k__TA_CDLHOMINGPIGEON[] = "TA_CDLHOMINGPIGEON";
static char __pyx_k__TA_CDLLADDERBOTTOM[] = "TA_CDLLADDERBOTTOM";
static char __pyx_k__TA_CDLSHOOTINGSTAR[] = "TA_CDLSHOOTINGSTAR";
static char __pyx_k__TA_CDLUNIQUE3RIVER[] = "TA_CDLUNIQUE3RIVER";
static char __pyx_k__TA_LINEARREG_ANGLE[] = "TA_LINEARREG_ANGLE";
static char __pyx_k__TA_LINEARREG_SLOPE[] = "TA_LINEARREG_SLOPE";
static char __pyx_k__outmacdsignal_data[] = "outmacdsignal_data";
static char __pyx_k__outquadrature_data[] = "outquadrature_data";
static char __pyx_k__CDLCONCEALBABYSWALL[] = "CDLCONCEALBABYSWALL";
static char __pyx_k__CDLGAPSIDESIDEWHITE[] = "CDLGAPSIDESIDEWHITE";
static char __pyx_k__CDLRISEFALL3METHODS[] = "CDLRISEFALL3METHODS";
static char __pyx_k__CDLXSIDEGAP3METHODS[] = "CDLXSIDEGAP3METHODS";
static char __pyx_k__LINEARREG_INTERCEPT[] = "LINEARREG_INTERCEPT";
static char __pyx_k__TA_CDL3STARSINSOUTH[] = "TA_CDL3STARSINSOUTH";
static char __pyx_k__TA_CDLABANDONEDBABY[] = "TA_CDLABANDONEDBABY";
static char __pyx_k__TA_CDLCOUNTERATTACK[] = "TA_CDLCOUNTERATTACK";
static char __pyx_k__TA_CDLDRAGONFLYDOJI[] = "TA_CDLDRAGONFLYDOJI";
static char __pyx_k__TA_CDLSTICKSANDWICH[] = "TA_CDLSTICKSANDWICH";
static char __pyx_k__accelerationmaxlong[] = "accelerationmaxlong";
static PyObject *__pyx_kp_s_1;
static PyObject *__pyx_kp_s_10;
static PyObject *__pyx_n_s_102;
static PyObject *__pyx_kp_s_11;
static PyObject *__pyx_n_s_110;
static PyObject *__pyx_n_s_112;
static PyObject *__pyx_kp_s_12;
static PyObject *__pyx_n_s_134;
static PyObject *__pyx_kp_s_14;
static PyObject *__pyx_kp_s_143;
static PyObject *__pyx_kp_s_144;
static PyObject *__pyx_kp_s_15;
static PyObject *__pyx_kp_s_16;
static PyObject *__pyx_kp_s_17;
static PyObject *__pyx_n_s_171;
static PyObject *__pyx_n_s_172;
static PyObject *__pyx_n_s_173;
static PyObject *__pyx_kp_u_199;
static PyObject *__pyx_kp_s_2;
static PyObject *__pyx_kp_u_201;
static PyObject *__pyx_kp_u_203;
static PyObject *__pyx_kp_u_205;
static PyObject *__pyx_kp_u_206;
static PyObject *__pyx_kp_u_209;
static PyObject *__pyx_kp_s_213;
static PyObject *__pyx_n_s_214;
static PyObject *__pyx_n_s_239;
static PyObject *__pyx_n_s_240;
static PyObject *__pyx_n_s_241;
static PyObject *__pyx_kp_s_28;
static PyObject *__pyx_kp_s_29;
static PyObject *__pyx_kp_s_3;
static PyObject *__pyx_n_s_42;
static PyObject *__pyx_n_s_48;
static PyObject *__pyx_kp_s_5;
static PyObject *__pyx_n_s_50;
static PyObject *__pyx_n_s_53;
static PyObject *__pyx_n_s_59;
static PyObject *__pyx_kp_s_6;
static PyObject *__pyx_n_s_62;
static PyObject *__pyx_n_s_64;
static PyObject *__pyx_kp_s_7;
static PyObject *__pyx_n_s_74;
static PyObject *__pyx_n_s_77;
static PyObject *__pyx_kp_s_8;
static PyObject *__pyx_n_s_80;
static PyObject *__pyx_n_s_83;
static PyObject *__pyx_n_s_89;
static PyObject *__pyx_kp_s_9;
static PyObject *__pyx_n_s_95;
static PyObject *__pyx_n_s_97;
static PyObject *__pyx_n_s__ACOS;
static PyObject *__pyx_n_s__AD;
static PyObject *__pyx_n_s__ADD;
static PyObject *__pyx_n_s__ADOSC;
static PyObject *__pyx_n_s__ADX;
static PyObject *__pyx_n_s__ADXR;
static PyObject *__pyx_n_s__APO;
static PyObject *__pyx_n_s__AROON;
static PyObject *__pyx_n_s__AROONOSC;
static PyObject *__pyx_n_s__ASIN;
static PyObject *__pyx_n_s__ATAN;
static PyObject *__pyx_n_s__ATR;
static PyObject *__pyx_n_s__AVGPRICE;
static PyObject *__pyx_n_s__BBANDS;
static PyObject *__pyx_n_s__BETA;
static PyObject *__pyx_n_s__BOP;
static PyObject *__pyx_n_s__CCI;
static PyObject *__pyx_n_s__CDL2CROWS;
static PyObject *__pyx_n_s__CDL3BLACKCROWS;
static PyObject *__pyx_n_s__CDL3INSIDE;
static PyObject *__pyx_n_s__CDL3LINESTRIKE;
static PyObject *__pyx_n_s__CDL3OUTSIDE;
static PyObject *__pyx_n_s__CDL3STARSINSOUTH;
static PyObject *__pyx_n_s__CDL3WHITESOLDIERS;
static PyObject *__pyx_n_s__CDLABANDONEDBABY;
static PyObject *__pyx_n_s__CDLADVANCEBLOCK;
static PyObject *__pyx_n_s__CDLBELTHOLD;
static PyObject *__pyx_n_s__CDLBREAKAWAY;
static PyObject *__pyx_n_s__CDLCLOSINGMARUBOZU;
static PyObject *__pyx_n_s__CDLCONCEALBABYSWALL;
static PyObject *__pyx_n_s__CDLCOUNTERATTACK;
static PyObject *__pyx_n_s__CDLDARKCLOUDCOVER;
static PyObject *__pyx_n_s__CDLDOJI;
static PyObject *__pyx_n_s__CDLDOJISTAR;
static PyObject *__pyx_n_s__CDLDRAGONFLYDOJI;
static PyObject *__pyx_n_s__CDLENGULFING;
static PyObject *__pyx_n_s__CDLEVENINGDOJISTAR;
static PyObject *__pyx_n_s__CDLEVENINGSTAR;
static PyObject *__pyx_n_s__CDLGAPSIDESIDEWHITE;
static PyObject *__pyx_n_s__CDLGRAVESTONEDOJI;
static PyObject *__pyx_n_s__CDLHAMMER;
static PyObject *__pyx_n_s__CDLHANGINGMAN;
static PyObject *__pyx_n_s__CDLHARAMI;
static PyObject *__pyx_n_s__CDLHARAMICROSS;
static PyObject *__pyx_n_s__CDLHIGHWAVE;
static PyObject *__pyx_n_s__CDLHIKKAKE;
static PyObject *__pyx_n_s__CDLHIKKAKEMOD;
static PyObject *__pyx_n_s__CDLHOMINGPIGEON;
static PyObject *__pyx_n_s__CDLIDENTICAL3CROWS;
static PyObject *__pyx_n_s__CDLINNECK;
static PyObject *__pyx_n_s__CDLINVERTEDHAMMER;
static PyObject *__pyx_n_s__CDLKICKING;
static PyObject *__pyx_n_s__CDLKICKINGBYLENGTH;
static PyObject *__pyx_n_s__CDLLADDERBOTTOM;
static PyObject *__pyx_n_s__CDLLONGLEGGEDDOJI;
static PyObject *__pyx_n_s__CDLLONGLINE;
static PyObject *__pyx_n_s__CDLMARUBOZU;
static PyObject *__pyx_n_s__CDLMATCHINGLOW;
static PyObject *__pyx_n_s__CDLMATHOLD;
static PyObject *__pyx_n_s__CDLMORNINGDOJISTAR;
static PyObject *__pyx_n_s__CDLMORNINGSTAR;
static PyObject *__pyx_n_s__CDLONNECK;
static PyObject *__pyx_n_s__CDLPIERCING;
static PyObject *__pyx_n_s__CDLRICKSHAWMAN;
static PyObject *__pyx_n_s__CDLRISEFALL3METHODS;
static PyObject *__pyx_n_s__CDLSEPARATINGLINES;
static PyObject *__pyx_n_s__CDLSHOOTINGSTAR;
static PyObject *__pyx_n_s__CDLSHORTLINE;
static PyObject *__pyx_n_s__CDLSPINNINGTOP;
static PyObject *__pyx_n_s__CDLSTALLEDPATTERN;
static PyObject *__pyx_n_s__CDLSTICKSANDWICH;
static PyObject *__pyx_n_s__CDLTAKURI;
static PyObject *__pyx_n_s__CDLTASUKIGAP;
static PyObject *__pyx_n_s__CDLTHRUSTING;
static PyObject *__pyx_n_s__CDLTRISTAR;
static PyObject *__pyx_n_s__CDLUNIQUE3RIVER;
static PyObject *__pyx_n_s__CDLUPSIDEGAP2CROWS;
static PyObject *__pyx_n_s__CDLXSIDEGAP3METHODS;
static PyObject *__pyx_n_s__CEIL;
static PyObject *__pyx_n_s__CMO;
static PyObject *__pyx_n_s__CORREL;
static PyObject *__pyx_n_s__COS;
static PyObject *__pyx_n_s__COSH;
static PyObject *__pyx_n_s__DEMA;
static PyObject *__pyx_n_s__DIV;
static PyObject *__pyx_n_s__DX;
static PyObject *__pyx_n_s__EMA;
static PyObject *__pyx_n_s__EXP;
static PyObject *__pyx_n_s__Exception;
static PyObject *__pyx_n_s__FLOOR;
static PyObject *__pyx_n_s__HT_DCPERIOD;
static PyObject *__pyx_n_s__HT_DCPHASE;
static PyObject *__pyx_n_s__HT_PHASOR;
static PyObject *__pyx_n_s__HT_SINE;
static PyObject *__pyx_n_s__HT_TRENDLINE;
static PyObject *__pyx_n_s__HT_TRENDMODE;
static PyObject *__pyx_n_s__KAMA;
static PyObject *__pyx_n_s__LINEARREG;
static PyObject *__pyx_n_s__LINEARREG_ANGLE;
static PyObject *__pyx_n_s__LINEARREG_INTERCEPT;
static PyObject *__pyx_n_s__LINEARREG_SLOPE;
static PyObject *__pyx_n_s__LN;
static PyObject *__pyx_n_s__LOG10;
static PyObject *__pyx_n_s__MA;
static PyObject *__pyx_n_s__MACD;
static PyObject *__pyx_n_s__MACDEXT;
static PyObject *__pyx_n_s__MACDFIX;
static PyObject *__pyx_n_s__MAMA;
static PyObject *__pyx_n_s__MAVP;
static PyObject *__pyx_n_s__MAX;
static PyObject *__pyx_n_s__MAXINDEX;
static PyObject *__pyx_n_s__MEDPRICE;
static PyObject *__pyx_n_s__MFI;
static PyObject *__pyx_n_s__MIDPOINT;
static PyObject *__pyx_n_s__MIDPRICE;
static PyObject *__pyx_n_s__MIN;
static PyObject *__pyx_n_s__MININDEX;
static PyObject *__pyx_n_s__MINMAX;
static PyObject *__pyx_n_s__MINMAXINDEX;
static PyObject *__pyx_n_s__MINUS_DI;
static PyObject *__pyx_n_s__MINUS_DM;
static PyObject *__pyx_n_s__MOM;
static PyObject *__pyx_n_s__MULT;
static PyObject *__pyx_n_s__NATR;
static PyObject *__pyx_n_s__OBV;
static PyObject *__pyx_n_s__PLUS_DI;
static PyObject *__pyx_n_s__PLUS_DM;
static PyObject *__pyx_n_s__PPO;
static PyObject *__pyx_n_s__ROC;
static PyObject *__pyx_n_s__ROCP;
static PyObject *__pyx_n_s__ROCR;
static PyObject *__pyx_n_s__ROCR100;
static PyObject *__pyx_n_s__RSI;
static PyObject *__pyx_n_s__RuntimeError;
static PyObject *__pyx_n_s__SAR;
static PyObject *__pyx_n_s__SAREXT;
static PyObject *__pyx_n_s__SIN;
static PyObject *__pyx_n_s__SINH;
static PyObject *__pyx_n_s__SMA;
static PyObject *__pyx_n_s__SQRT;
static PyObject *__pyx_n_s__STDDEV;
static PyObject *__pyx_n_s__STOCH;
static PyObject *__pyx_n_s__STOCHF;
static PyObject *__pyx_n_s__STOCHRSI;
static PyObject *__pyx_n_s__SUB;
static PyObject *__pyx_n_s__SUM;
static PyObject *__pyx_n_s__T3;
static PyObject *__pyx_n_s__TAN;
static PyObject *__pyx_n_s__TANH;
static PyObject *__pyx_n_s__TA_ACOS;
static PyObject *__pyx_n_s__TA_AD;
static PyObject *__pyx_n_s__TA_ADD;
static PyObject *__pyx_n_s__TA_ADOSC;
static PyObject *__pyx_n_s__TA_ADX;
static PyObject *__pyx_n_s__TA_ADXR;
static PyObject *__pyx_n_s__TA_APO;
static PyObject *__pyx_n_s__TA_AROON;
static PyObject *__pyx_n_s__TA_AROONOSC;
static PyObject *__pyx_n_s__TA_ASIN;
static PyObject *__pyx_n_s__TA_ATAN;
static PyObject *__pyx_n_s__TA_ATR;
static PyObject *__pyx_n_s__TA_AVGPRICE;
static PyObject *__pyx_n_s__TA_BBANDS;
static PyObject *__pyx_n_s__TA_BETA;
static PyObject *__pyx_n_s__TA_BOP;
static PyObject *__pyx_n_s__TA_CCI;
static PyObject *__pyx_n_s__TA_CDL2CROWS;
static PyObject *__pyx_n_s__TA_CDL3BLACKCROWS;
static PyObject *__pyx_n_s__TA_CDL3INSIDE;
static PyObject *__pyx_n_s__TA_CDL3LINESTRIKE;
static PyObject *__pyx_n_s__TA_CDL3OUTSIDE;
static PyObject *__pyx_n_s__TA_CDL3STARSINSOUTH;
static PyObject *__pyx_n_s__TA_CDLABANDONEDBABY;
static PyObject *__pyx_n_s__TA_CDLADVANCEBLOCK;
static PyObject *__pyx_n_s__TA_CDLBELTHOLD;
static PyObject *__pyx_n_s__TA_CDLBREAKAWAY;
static PyObject *__pyx_n_s__TA_CDLCOUNTERATTACK;
static PyObject *__pyx_n_s__TA_CDLDOJI;
static PyObject *__pyx_n_s__TA_CDLDOJISTAR;
static PyObject *__pyx_n_s__TA_CDLDRAGONFLYDOJI;
static PyObject *__pyx_n_s__TA_CDLENGULFING;
static PyObject *__pyx_n_s__TA_CDLEVENINGSTAR;
static PyObject *__pyx_n_s__TA_CDLHAMMER;
static PyObject *__pyx_n_s__TA_CDLHANGINGMAN;
static PyObject *__pyx_n_s__TA_CDLHARAMI;
static PyObject *__pyx_n_s__TA_CDLHARAMICROSS;
static PyObject *__pyx_n_s__TA_CDLHIGHWAVE;
static PyObject *__pyx_n_s__TA_CDLHIKKAKE;
static PyObject *__pyx_n_s__TA_CDLHIKKAKEMOD;
static PyObject *__pyx_n_s__TA_CDLHOMINGPIGEON;
static PyObject *__pyx_n_s__TA_CDLINNECK;
static PyObject *__pyx_n_s__TA_CDLKICKING;
static PyObject *__pyx_n_s__TA_CDLLADDERBOTTOM;
static PyObject *__pyx_n_s__TA_CDLLONGLINE;
static PyObject *__pyx_n_s__TA_CDLMARUBOZU;
static PyObject *__pyx_n_s__TA_CDLMATCHINGLOW;
static PyObject *__pyx_n_s__TA_CDLMATHOLD;
static PyObject *__pyx_n_s__TA_CDLMORNINGSTAR;
static PyObject *__pyx_n_s__TA_CDLONNECK;
static PyObject *__pyx_n_s__TA_CDLPIERCING;
static PyObject *__pyx_n_s__TA_CDLRICKSHAWMAN;
static PyObject *__pyx_n_s__TA_CDLSHOOTINGSTAR;
static PyObject *__pyx_n_s__TA_CDLSHORTLINE;
static PyObject *__pyx_n_s__TA_CDLSPINNINGTOP;
static PyObject *__pyx_n_s__TA_CDLSTICKSANDWICH;
static PyObject *__pyx_n_s__TA_CDLTAKURI;
static PyObject *__pyx_n_s__TA_CDLTASUKIGAP;
static PyObject *__pyx_n_s__TA_CDLTHRUSTING;
static PyObject *__pyx_n_s__TA_CDLTRISTAR;
static PyObject *__pyx_n_s__TA_CDLUNIQUE3RIVER;
static PyObject *__pyx_n_s__TA_CEIL;
static PyObject *__pyx_n_s__TA_CMO;
static PyObject *__pyx_n_s__TA_CORREL;
static PyObject *__pyx_n_s__TA_COS;
static PyObject *__pyx_n_s__TA_COSH;
static PyObject *__pyx_n_s__TA_DEMA;
static PyObject *__pyx_n_s__TA_DIV;
static PyObject *__pyx_n_s__TA_DX;
static PyObject *__pyx_n_s__TA_EMA;
static PyObject *__pyx_n_s__TA_EXP;
static PyObject *__pyx_n_s__TA_FLOOR;
static PyObject *__pyx_n_s__TA_HT_DCPERIOD;
static PyObject *__pyx_n_s__TA_HT_DCPHASE;
static PyObject *__pyx_n_s__TA_HT_PHASOR;
static PyObject *__pyx_n_s__TA_HT_SINE;
static PyObject *__pyx_n_s__TA_HT_TRENDLINE;
static PyObject *__pyx_n_s__TA_HT_TRENDMODE;
static PyObject *__pyx_n_s__TA_KAMA;
static PyObject *__pyx_n_s__TA_LINEARREG;
static PyObject *__pyx_n_s__TA_LINEARREG_ANGLE;
static PyObject *__pyx_n_s__TA_LINEARREG_SLOPE;
static PyObject *__pyx_n_s__TA_LN;
static PyObject *__pyx_n_s__TA_LOG10;
static PyObject *__pyx_n_s__TA_MA;
static PyObject *__pyx_n_s__TA_MACD;
static PyObject *__pyx_n_s__TA_MACDEXT;
static PyObject *__pyx_n_s__TA_MACDFIX;
static PyObject *__pyx_n_s__TA_MAMA;
static PyObject *__pyx_n_s__TA_MAVP;
static PyObject *__pyx_n_s__TA_MAX;
static PyObject *__pyx_n_s__TA_MAXINDEX;
static PyObject *__pyx_n_s__TA_MEDPRICE;
static PyObject *__pyx_n_s__TA_MFI;
static PyObject *__pyx_n_s__TA_MIDPOINT;
static PyObject *__pyx_n_s__TA_MIDPRICE;
static PyObject *__pyx_n_s__TA_MIN;
static PyObject *__pyx_n_s__TA_MININDEX;
static PyObject *__pyx_n_s__TA_MINMAX;
static PyObject *__pyx_n_s__TA_MINMAXINDEX;
static PyObject *__pyx_n_s__TA_MINUS_DI;
static PyObject *__pyx_n_s__TA_MINUS_DM;
static PyObject *__pyx_n_s__TA_MOM;
static PyObject *__pyx_n_s__TA_MULT;
static PyObject *__pyx_n_s__TA_NATR;
static PyObject *__pyx_n_s__TA_OBV;
static PyObject *__pyx_n_s__TA_PLUS_DI;
static PyObject *__pyx_n_s__TA_PLUS_DM;
static PyObject *__pyx_n_s__TA_PPO;
static PyObject *__pyx_n_s__TA_ROC;
static PyObject *__pyx_n_s__TA_ROCP;
static PyObject *__pyx_n_s__TA_ROCR;
static PyObject *__pyx_n_s__TA_ROCR100;
static PyObject *__pyx_n_s__TA_RSI;
static PyObject *__pyx_n_s__TA_SAR;
static PyObject *__pyx_n_s__TA_SAREXT;
static PyObject *__pyx_n_s__TA_SIN;
static PyObject *__pyx_n_s__TA_SINH;
static PyObject *__pyx_n_s__TA_SMA;
static PyObject *__pyx_n_s__TA_SQRT;
static PyObject *__pyx_n_s__TA_STDDEV;
static PyObject *__pyx_n_s__TA_STOCH;
static PyObject *__pyx_n_s__TA_STOCHF;
static PyObject *__pyx_n_s__TA_STOCHRSI;
static PyObject *__pyx_n_s__TA_SUB;
static PyObject *__pyx_n_s__TA_SUM;
static PyObject *__pyx_n_s__TA_T3;
static PyObject *__pyx_n_s__TA_TAN;
static PyObject *__pyx_n_s__TA_TANH;
static PyObject *__pyx_n_s__TA_TEMA;
static PyObject *__pyx_n_s__TA_TRANGE;
static PyObject *__pyx_n_s__TA_TRIMA;
static PyObject *__pyx_n_s__TA_TRIX;
static PyObject *__pyx_n_s__TA_TSF;
static PyObject *__pyx_n_s__TA_TYPPRICE;
static PyObject *__pyx_n_s__TA_ULTOSC;
static PyObject *__pyx_n_s__TA_VAR;
static PyObject *__pyx_n_s__TA_WCLPRICE;
static PyObject *__pyx_n_s__TA_WILLR;
static PyObject *__pyx_n_s__TA_WMA;
static PyObject *__pyx_n_s__TEMA;
static PyObject *__pyx_n_s__TRANGE;
static PyObject *__pyx_n_s__TRIMA;
static PyObject *__pyx_n_s__TRIX;
static PyObject *__pyx_n_s__TSF;
static PyObject *__pyx_n_s__TYPPRICE;
static PyObject *__pyx_n_s__ULTOSC;
static PyObject *__pyx_n_s__VAR;
static PyObject *__pyx_n_s__ValueError;
static PyObject *__pyx_n_s__WCLPRICE;
static PyObject *__pyx_n_s__WILLR;
static PyObject *__pyx_n_s__WMA;
static PyObject *__pyx_n_s____all__;
static PyObject *__pyx_n_s____main__;
static PyObject *__pyx_n_s____test__;
static PyObject *__pyx_n_s__acceleration;
static PyObject *__pyx_n_s__accelerationlong;
static PyObject *__pyx_n_s__accelerationmaxlong;
static PyObject *__pyx_n_s__accelerationshort;
static PyObject *__pyx_n_s__begidx;
static PyObject *__pyx_n_s__close;
static PyObject *__pyx_n_s__close_data;
static PyObject *__pyx_n_s__endidx;
static PyObject *__pyx_n_s__fastd_matype;
static PyObject *__pyx_n_s__fastd_period;
static PyObject *__pyx_n_s__fastk_period;
static PyObject *__pyx_n_s__fastlimit;
static PyObject *__pyx_n_s__fastmatype;
static PyObject *__pyx_n_s__fastperiod;
static PyObject *__pyx_n_s__high;
static PyObject *__pyx_n_s__high_data;
static PyObject *__pyx_n_s__i;
static PyObject *__pyx_n_s__length;
static PyObject *__pyx_n_s__lookback;
static PyObject *__pyx_n_s__low;
static PyObject *__pyx_n_s__low_data;
static PyObject *__pyx_n_s__matype;
static PyObject *__pyx_n_s__maximum;
static PyObject *__pyx_n_s__maxperiod;
static PyObject *__pyx_n_s__minperiod;
static PyObject *__pyx_n_s__nan;
static PyObject *__pyx_n_s__nbdev;
static PyObject *__pyx_n_s__nbdevdn;
static PyObject *__pyx_n_s__nbdevup;
static PyObject *__pyx_n_s__numpy;
static PyObject *__pyx_n_s__offsetonreverse;
static PyObject *__pyx_n_s__open;
static PyObject *__pyx_n_s__open_data;
static PyObject *__pyx_n_s__outaroondown;
static PyObject *__pyx_n_s__outaroondown_data;
static PyObject *__pyx_n_s__outaroonup;
static PyObject *__pyx_n_s__outaroonup_data;
static PyObject *__pyx_n_s__outbegidx;
static PyObject *__pyx_n_s__outfama;
static PyObject *__pyx_n_s__outfama_data;
static PyObject *__pyx_n_s__outfastd;
static PyObject *__pyx_n_s__outfastd_data;
static PyObject *__pyx_n_s__outfastk;
static PyObject *__pyx_n_s__outfastk_data;
static PyObject *__pyx_n_s__outinphase;
static PyObject *__pyx_n_s__outinphase_data;
static PyObject *__pyx_n_s__outinteger;
static PyObject *__pyx_n_s__outinteger_data;
static PyObject *__pyx_n_s__outleadsine;
static PyObject *__pyx_n_s__outleadsine_data;
static PyObject *__pyx_n_s__outmacd;
static PyObject *__pyx_n_s__outmacd_data;
static PyObject *__pyx_n_s__outmacdhist;
static PyObject *__pyx_n_s__outmacdhist_data;
static PyObject *__pyx_n_s__outmacdsignal;
static PyObject *__pyx_n_s__outmacdsignal_data;
static PyObject *__pyx_n_s__outmama;
static PyObject *__pyx_n_s__outmama_data;
static PyObject *__pyx_n_s__outmax;
static PyObject *__pyx_n_s__outmax_data;
static PyObject *__pyx_n_s__outmaxidx;
static PyObject *__pyx_n_s__outmaxidx_data;
static PyObject *__pyx_n_s__outmin;
static PyObject *__pyx_n_s__outmin_data;
static PyObject *__pyx_n_s__outminidx;
static PyObject *__pyx_n_s__outminidx_data;
static PyObject *__pyx_n_s__outnbelement;
static PyObject *__pyx_n_s__outquadrature;
static PyObject *__pyx_n_s__outquadrature_data;
static PyObject *__pyx_n_s__outreal;
static PyObject *__pyx_n_s__outreal_data;
static PyObject *__pyx_n_s__outreallowerband;
static PyObject *__pyx_n_s__outrealmiddleband;
static PyObject *__pyx_n_s__outrealupperband;
static PyObject *__pyx_n_s__outsine;
static PyObject *__pyx_n_s__outsine_data;
static PyObject *__pyx_n_s__outslowd;
static PyObject *__pyx_n_s__outslowd_data;
static PyObject *__pyx_n_s__outslowk;
static PyObject *__pyx_n_s__outslowk_data;
static PyObject *__pyx_n_s__penetration;
static PyObject *__pyx_n_s__periods;
static PyObject *__pyx_n_s__periods_data;
static PyObject *__pyx_n_s__range;
static PyObject *__pyx_n_s__real;
static PyObject *__pyx_n_s__real0;
static PyObject *__pyx_n_s__real0_data;
static PyObject *__pyx_n_s__real1;
static PyObject *__pyx_n_s__real1_data;
static PyObject *__pyx_n_s__real_data;
static PyObject *__pyx_n_s__retCode;
static PyObject *__pyx_n_s__signalmatype;
static PyObject *__pyx_n_s__signalperiod;
static PyObject *__pyx_n_s__slowd_matype;
static PyObject *__pyx_n_s__slowd_period;
static PyObject *__pyx_n_s__slowk_matype;
static PyObject *__pyx_n_s__slowk_period;
static PyObject *__pyx_n_s__slowlimit;
static PyObject *__pyx_n_s__slowmatype;
static PyObject *__pyx_n_s__slowperiod;
static PyObject *__pyx_n_s__startvalue;
static PyObject *__pyx_n_s__timeperiod;
static PyObject *__pyx_n_s__timeperiod1;
static PyObject *__pyx_n_s__timeperiod2;
static PyObject *__pyx_n_s__timeperiod3;
static PyObject *__pyx_n_s__vfactor;
static PyObject *__pyx_n_s__volume;
static PyObject *__pyx_n_s__volume_data;
static PyObject *__pyx_int_15;
static PyObject *__pyx_k_tuple_4;
static PyObject *__pyx_k_tuple_13;
static PyObject *__pyx_k_tuple_18;
static PyObject *__pyx_k_tuple_19;
static PyObject *__pyx_k_tuple_20;
static PyObject *__pyx_k_tuple_21;
static PyObject *__pyx_k_tuple_22;
static PyObject *__pyx_k_tuple_23;
static PyObject *__pyx_k_tuple_24;
static PyObject *__pyx_k_tuple_25;
static PyObject *__pyx_k_tuple_26;
static PyObject *__pyx_k_tuple_27;
static PyObject *__pyx_k_tuple_30;
static PyObject *__pyx_k_tuple_31;
static PyObject *__pyx_k_tuple_32;
static PyObject *__pyx_k_tuple_33;
static PyObject *__pyx_k_tuple_34;
static PyObject *__pyx_k_tuple_35;
static PyObject *__pyx_k_tuple_36;
static PyObject *__pyx_k_tuple_37;
static PyObject *__pyx_k_tuple_38;
static PyObject *__pyx_k_tuple_39;
static PyObject *__pyx_k_tuple_40;
static PyObject *__pyx_k_tuple_41;
static PyObject *__pyx_k_tuple_43;
static PyObject *__pyx_k_tuple_44;
static PyObject *__pyx_k_tuple_45;
static PyObject *__pyx_k_tuple_46;
static PyObject *__pyx_k_tuple_47;
static PyObject *__pyx_k_tuple_49;
static PyObject *__pyx_k_tuple_51;
static PyObject *__pyx_k_tuple_52;
static PyObject *__pyx_k_tuple_54;
static PyObject *__pyx_k_tuple_55;
static PyObject *__pyx_k_tuple_56;
static PyObject *__pyx_k_tuple_57;
static PyObject *__pyx_k_tuple_58;
static PyObject *__pyx_k_tuple_60;
static PyObject *__pyx_k_tuple_61;
static PyObject *__pyx_k_tuple_63;
static PyObject *__pyx_k_tuple_65;
static PyObject *__pyx_k_tuple_66;
static PyObject *__pyx_k_tuple_67;
static PyObject *__pyx_k_tuple_68;
static PyObject *__pyx_k_tuple_69;
static PyObject *__pyx_k_tuple_70;
static PyObject *__pyx_k_tuple_71;
static PyObject *__pyx_k_tuple_72;
static PyObject *__pyx_k_tuple_73;
static PyObject *__pyx_k_tuple_75;
static PyObject *__pyx_k_tuple_76;
static PyObject *__pyx_k_tuple_78;
static PyObject *__pyx_k_tuple_79;
static PyObject *__pyx_k_tuple_81;
static PyObject *__pyx_k_tuple_82;
static PyObject *__pyx_k_tuple_84;
static PyObject *__pyx_k_tuple_85;
static PyObject *__pyx_k_tuple_86;
static PyObject *__pyx_k_tuple_87;
static PyObject *__pyx_k_tuple_88;
static PyObject *__pyx_k_tuple_90;
static PyObject *__pyx_k_tuple_91;
static PyObject *__pyx_k_tuple_92;
static PyObject *__pyx_k_tuple_93;
static PyObject *__pyx_k_tuple_94;
static PyObject *__pyx_k_tuple_96;
static PyObject *__pyx_k_tuple_98;
static PyObject *__pyx_k_tuple_99;
static PyObject *__pyx_k_tuple_100;
static PyObject *__pyx_k_tuple_101;
static PyObject *__pyx_k_tuple_103;
static PyObject *__pyx_k_tuple_104;
static PyObject *__pyx_k_tuple_105;
static PyObject *__pyx_k_tuple_106;
static PyObject *__pyx_k_tuple_107;
static PyObject *__pyx_k_tuple_108;
static PyObject *__pyx_k_tuple_109;
static PyObject *__pyx_k_tuple_111;
static PyObject *__pyx_k_tuple_113;
static PyObject *__pyx_k_tuple_114;
static PyObject *__pyx_k_tuple_115;
static PyObject *__pyx_k_tuple_116;
static PyObject *__pyx_k_tuple_117;
static PyObject *__pyx_k_tuple_118;
static PyObject *__pyx_k_tuple_119;
static PyObject *__pyx_k_tuple_120;
static PyObject *__pyx_k_tuple_121;
static PyObject *__pyx_k_tuple_122;
static PyObject *__pyx_k_tuple_123;
static PyObject *__pyx_k_tuple_124;
static PyObject *__pyx_k_tuple_125;
static PyObject *__pyx_k_tuple_126;
static PyObject *__pyx_k_tuple_127;
static PyObject *__pyx_k_tuple_128;
static PyObject *__pyx_k_tuple_129;
static PyObject *__pyx_k_tuple_130;
static PyObject *__pyx_k_tuple_131;
static PyObject *__pyx_k_tuple_132;
static PyObject *__pyx_k_tuple_133;
static PyObject *__pyx_k_tuple_135;
static PyObject *__pyx_k_tuple_136;
static PyObject *__pyx_k_tuple_137;
static PyObject *__pyx_k_tuple_138;
static PyObject *__pyx_k_tuple_139;
static PyObject *__pyx_k_tuple_140;
static PyObject *__pyx_k_tuple_141;
static PyObject *__pyx_k_tuple_142;
static PyObject *__pyx_k_tuple_145;
static PyObject *__pyx_k_tuple_146;
static PyObject *__pyx_k_tuple_147;
static PyObject *__pyx_k_tuple_148;
static PyObject *__pyx_k_tuple_149;
static PyObject *__pyx_k_tuple_150;
static PyObject *__pyx_k_tuple_151;
static PyObject *__pyx_k_tuple_152;
static PyObject *__pyx_k_tuple_153;
static PyObject *__pyx_k_tuple_154;
static PyObject *__pyx_k_tuple_155;
static PyObject *__pyx_k_tuple_156;
static PyObject *__pyx_k_tuple_157;
static PyObject *__pyx_k_tuple_158;
static PyObject *__pyx_k_tuple_159;
static PyObject *__pyx_k_tuple_160;
static PyObject *__pyx_k_tuple_161;
static PyObject *__pyx_k_tuple_162;
static PyObject *__pyx_k_tuple_163;
static PyObject *__pyx_k_tuple_164;
static PyObject *__pyx_k_tuple_165;
static PyObject *__pyx_k_tuple_166;
static PyObject *__pyx_k_tuple_167;
static PyObject *__pyx_k_tuple_168;
static PyObject *__pyx_k_tuple_169;
static PyObject *__pyx_k_tuple_170;
static PyObject *__pyx_k_tuple_174;
static PyObject *__pyx_k_tuple_175;
static PyObject *__pyx_k_tuple_176;
static PyObject *__pyx_k_tuple_177;
static PyObject *__pyx_k_tuple_178;
static PyObject *__pyx_k_tuple_179;
static PyObject *__pyx_k_tuple_180;
static PyObject *__pyx_k_tuple_181;
static PyObject *__pyx_k_tuple_182;
static PyObject *__pyx_k_tuple_183;
static PyObject *__pyx_k_tuple_184;
static PyObject *__pyx_k_tuple_185;
static PyObject *__pyx_k_tuple_186;
static PyObject *__pyx_k_tuple_187;
static PyObject *__pyx_k_tuple_188;
static PyObject *__pyx_k_tuple_189;
static PyObject *__pyx_k_tuple_190;
static PyObject *__pyx_k_tuple_191;
static PyObject *__pyx_k_tuple_192;
static PyObject *__pyx_k_tuple_193;
static PyObject *__pyx_k_tuple_194;
static PyObject *__pyx_k_tuple_195;
static PyObject *__pyx_k_tuple_196;
static PyObject *__pyx_k_tuple_197;
static PyObject *__pyx_k_tuple_198;
static PyObject *__pyx_k_tuple_200;
static PyObject *__pyx_k_tuple_202;
static PyObject *__pyx_k_tuple_204;
static PyObject *__pyx_k_tuple_207;
static PyObject *__pyx_k_tuple_208;
static PyObject *__pyx_k_tuple_210;
static PyObject *__pyx_k_tuple_211;
static PyObject *__pyx_k_tuple_215;
static PyObject *__pyx_k_tuple_217;
static PyObject *__pyx_k_tuple_219;
static PyObject *__pyx_k_tuple_221;
static PyObject *__pyx_k_tuple_223;
static PyObject *__pyx_k_tuple_225;
static PyObject *__pyx_k_tuple_227;
static PyObject *__pyx_k_tuple_229;
static PyObject *__pyx_k_tuple_231;
static PyObject *__pyx_k_tuple_233;
static PyObject *__pyx_k_tuple_235;
static PyObject *__pyx_k_tuple_237;
static PyObject *__pyx_k_tuple_242;
static PyObject *__pyx_k_tuple_244;
static PyObject *__pyx_k_tuple_246;
static PyObject *__pyx_k_tuple_248;
static PyObject *__pyx_k_tuple_250;
static PyObject *__pyx_k_tuple_252;
static PyObject *__pyx_k_tuple_254;
static PyObject *__pyx_k_tuple_256;
static PyObject *__pyx_k_tuple_258;
static PyObject *__pyx_k_tuple_260;
static PyObject *__pyx_k_tuple_262;
static PyObject *__pyx_k_tuple_264;
static PyObject *__pyx_k_tuple_266;
static PyObject *__pyx_k_tuple_268;
static PyObject *__pyx_k_tuple_270;
static PyObject *__pyx_k_tuple_272;
static PyObject *__pyx_k_tuple_274;
static PyObject *__pyx_k_tuple_276;
static PyObject *__pyx_k_tuple_278;
static PyObject *__pyx_k_tuple_280;
static PyObject *__pyx_k_tuple_282;
static PyObject *__pyx_k_tuple_284;
static PyObject *__pyx_k_tuple_286;
static PyObject *__pyx_k_tuple_288;
static PyObject *__pyx_k_tuple_290;
static PyObject *__pyx_k_tuple_292;
static PyObject *__pyx_k_tuple_294;
static PyObject *__pyx_k_tuple_296;
static PyObject *__pyx_k_tuple_298;
static PyObject *__pyx_k_tuple_300;
static PyObject *__pyx_k_tuple_302;
static PyObject *__pyx_k_tuple_304;
static PyObject *__pyx_k_tuple_306;
static PyObject *__pyx_k_tuple_308;
static PyObject *__pyx_k_tuple_310;
static PyObject *__pyx_k_tuple_312;
static PyObject *__pyx_k_tuple_314;
static PyObject *__pyx_k_tuple_316;
static PyObject *__pyx_k_tuple_318;
static PyObject *__pyx_k_tuple_320;
static PyObject *__pyx_k_tuple_322;
static PyObject *__pyx_k_tuple_324;
static PyObject *__pyx_k_tuple_326;
static PyObject *__pyx_k_tuple_328;
static PyObject *__pyx_k_tuple_330;
static PyObject *__pyx_k_tuple_332;
static PyObject *__pyx_k_tuple_334;
static PyObject *__pyx_k_tuple_336;
static PyObject *__pyx_k_tuple_338;
static PyObject *__pyx_k_tuple_340;
static PyObject *__pyx_k_tuple_342;
static PyObject *__pyx_k_tuple_344;
static PyObject *__pyx_k_tuple_346;
static PyObject *__pyx_k_tuple_348;
static PyObject *__pyx_k_tuple_350;
static PyObject *__pyx_k_tuple_352;
static PyObject *__pyx_k_tuple_354;
static PyObject *__pyx_k_tuple_356;
static PyObject *__pyx_k_tuple_358;
static PyObject *__pyx_k_tuple_360;
static PyObject *__pyx_k_tuple_362;
static PyObject *__pyx_k_tuple_364;
static PyObject *__pyx_k_tuple_366;
static PyObject *__pyx_k_tuple_368;
static PyObject *__pyx_k_tuple_370;
static PyObject *__pyx_k_tuple_372;
static PyObject *__pyx_k_tuple_374;
static PyObject *__pyx_k_tuple_376;
static PyObject *__pyx_k_tuple_378;
static PyObject *__pyx_k_tuple_380;
static PyObject *__pyx_k_tuple_382;
static PyObject *__pyx_k_tuple_384;
static PyObject *__pyx_k_tuple_386;
static PyObject *__pyx_k_tuple_388;
static PyObject *__pyx_k_tuple_390;
static PyObject *__pyx_k_tuple_392;
static PyObject *__pyx_k_tuple_394;
static PyObject *__pyx_k_tuple_396;
static PyObject *__pyx_k_tuple_398;
static PyObject *__pyx_k_tuple_400;
static PyObject *__pyx_k_tuple_402;
static PyObject *__pyx_k_tuple_404;
static PyObject *__pyx_k_tuple_406;
static PyObject *__pyx_k_tuple_408;
static PyObject *__pyx_k_tuple_410;
static PyObject *__pyx_k_tuple_412;
static PyObject *__pyx_k_tuple_414;
static PyObject *__pyx_k_tuple_416;
static PyObject *__pyx_k_tuple_418;
static PyObject *__pyx_k_tuple_420;
static PyObject *__pyx_k_tuple_422;
static PyObject *__pyx_k_tuple_424;
static PyObject *__pyx_k_tuple_426;
static PyObject *__pyx_k_tuple_428;
static PyObject *__pyx_k_tuple_430;
static PyObject *__pyx_k_tuple_432;
static PyObject *__pyx_k_tuple_434;
static PyObject *__pyx_k_tuple_436;
static PyObject *__pyx_k_tuple_438;
static PyObject *__pyx_k_tuple_440;
static PyObject *__pyx_k_tuple_442;
static PyObject *__pyx_k_tuple_444;
static PyObject *__pyx_k_tuple_446;
static PyObject *__pyx_k_tuple_448;
static PyObject *__pyx_k_tuple_450;
static PyObject *__pyx_k_tuple_452;
static PyObject *__pyx_k_tuple_454;
static PyObject *__pyx_k_tuple_456;
static PyObject *__pyx_k_tuple_458;
static PyObject *__pyx_k_tuple_460;
static PyObject *__pyx_k_tuple_462;
static PyObject *__pyx_k_tuple_464;
static PyObject *__pyx_k_tuple_466;
static PyObject *__pyx_k_tuple_468;
static PyObject *__pyx_k_tuple_470;
static PyObject *__pyx_k_tuple_472;
static PyObject *__pyx_k_tuple_474;
static PyObject *__pyx_k_tuple_476;
static PyObject *__pyx_k_tuple_478;
static PyObject *__pyx_k_tuple_480;
static PyObject *__pyx_k_tuple_482;
static PyObject *__pyx_k_tuple_484;
static PyObject *__pyx_k_tuple_486;
static PyObject *__pyx_k_tuple_488;
static PyObject *__pyx_k_tuple_490;
static PyObject *__pyx_k_tuple_492;
static PyObject *__pyx_k_tuple_494;
static PyObject *__pyx_k_tuple_496;
static PyObject *__pyx_k_tuple_498;
static PyObject *__pyx_k_tuple_500;
static PyObject *__pyx_k_tuple_502;
static PyObject *__pyx_k_tuple_504;
static PyObject *__pyx_k_tuple_506;
static PyObject *__pyx_k_tuple_508;
static PyObject *__pyx_k_tuple_510;
static PyObject *__pyx_k_tuple_512;
static PyObject *__pyx_k_tuple_514;
static PyObject *__pyx_k_tuple_516;
static PyObject *__pyx_k_tuple_518;
static PyObject *__pyx_k_tuple_520;
static PyObject *__pyx_k_tuple_522;
static PyObject *__pyx_k_tuple_524;
static PyObject *__pyx_k_tuple_526;
static PyObject *__pyx_k_tuple_528;
static PyObject *__pyx_k_tuple_530;
static PyObject *__pyx_k_codeobj_212;
static PyObject *__pyx_k_codeobj_216;
static PyObject *__pyx_k_codeobj_218;
static PyObject *__pyx_k_codeobj_220;
static PyObject *__pyx_k_codeobj_222;
static PyObject *__pyx_k_codeobj_224;
static PyObject *__pyx_k_codeobj_226;
static PyObject *__pyx_k_codeobj_228;
static PyObject *__pyx_k_codeobj_230;
static PyObject *__pyx_k_codeobj_232;
static PyObject *__pyx_k_codeobj_234;
static PyObject *__pyx_k_codeobj_236;
static PyObject *__pyx_k_codeobj_238;
static PyObject *__pyx_k_codeobj_243;
static PyObject *__pyx_k_codeobj_245;
static PyObject *__pyx_k_codeobj_247;
static PyObject *__pyx_k_codeobj_249;
static PyObject *__pyx_k_codeobj_251;
static PyObject *__pyx_k_codeobj_253;
static PyObject *__pyx_k_codeobj_255;
static PyObject *__pyx_k_codeobj_257;
static PyObject *__pyx_k_codeobj_259;
static PyObject *__pyx_k_codeobj_261;
static PyObject *__pyx_k_codeobj_263;
static PyObject *__pyx_k_codeobj_265;
static PyObject *__pyx_k_codeobj_267;
static PyObject *__pyx_k_codeobj_269;
static PyObject *__pyx_k_codeobj_271;
static PyObject *__pyx_k_codeobj_273;
static PyObject *__pyx_k_codeobj_275;
static PyObject *__pyx_k_codeobj_277;
static PyObject *__pyx_k_codeobj_279;
static PyObject *__pyx_k_codeobj_281;
static PyObject *__pyx_k_codeobj_283;
static PyObject *__pyx_k_codeobj_285;
static PyObject *__pyx_k_codeobj_287;
static PyObject *__pyx_k_codeobj_289;
static PyObject *__pyx_k_codeobj_291;
static PyObject *__pyx_k_codeobj_293;
static PyObject *__pyx_k_codeobj_295;
static PyObject *__pyx_k_codeobj_297;
static PyObject *__pyx_k_codeobj_299;
static PyObject *__pyx_k_codeobj_301;
static PyObject *__pyx_k_codeobj_303;
static PyObject *__pyx_k_codeobj_305;
static PyObject *__pyx_k_codeobj_307;
static PyObject *__pyx_k_codeobj_309;
static PyObject *__pyx_k_codeobj_311;
static PyObject *__pyx_k_codeobj_313;
static PyObject *__pyx_k_codeobj_315;
static PyObject *__pyx_k_codeobj_317;
static PyObject *__pyx_k_codeobj_319;
static PyObject *__pyx_k_codeobj_321;
static PyObject *__pyx_k_codeobj_323;
static PyObject *__pyx_k_codeobj_325;
static PyObject *__pyx_k_codeobj_327;
static PyObject *__pyx_k_codeobj_329;
static PyObject *__pyx_k_codeobj_331;
static PyObject *__pyx_k_codeobj_333;
static PyObject *__pyx_k_codeobj_335;
static PyObject *__pyx_k_codeobj_337;
static PyObject *__pyx_k_codeobj_339;
static PyObject *__pyx_k_codeobj_341;
static PyObject *__pyx_k_codeobj_343;
static PyObject *__pyx_k_codeobj_345;
static PyObject *__pyx_k_codeobj_347;
static PyObject *__pyx_k_codeobj_349;
static PyObject *__pyx_k_codeobj_351;
static PyObject *__pyx_k_codeobj_353;
static PyObject *__pyx_k_codeobj_355;
static PyObject *__pyx_k_codeobj_357;
static PyObject *__pyx_k_codeobj_359;
static PyObject *__pyx_k_codeobj_361;
static PyObject *__pyx_k_codeobj_363;
static PyObject *__pyx_k_codeobj_365;
static PyObject *__pyx_k_codeobj_367;
static PyObject *__pyx_k_codeobj_369;
static PyObject *__pyx_k_codeobj_371;
static PyObject *__pyx_k_codeobj_373;
static PyObject *__pyx_k_codeobj_375;
static PyObject *__pyx_k_codeobj_377;
static PyObject *__pyx_k_codeobj_379;
static PyObject *__pyx_k_codeobj_381;
static PyObject *__pyx_k_codeobj_383;
static PyObject *__pyx_k_codeobj_385;
static PyObject *__pyx_k_codeobj_387;
static PyObject *__pyx_k_codeobj_389;
static PyObject *__pyx_k_codeobj_391;
static PyObject *__pyx_k_codeobj_393;
static PyObject *__pyx_k_codeobj_395;
static PyObject *__pyx_k_codeobj_397;
static PyObject *__pyx_k_codeobj_399;
static PyObject *__pyx_k_codeobj_401;
static PyObject *__pyx_k_codeobj_403;
static PyObject *__pyx_k_codeobj_405;
static PyObject *__pyx_k_codeobj_407;
static PyObject *__pyx_k_codeobj_409;
static PyObject *__pyx_k_codeobj_411;
static PyObject *__pyx_k_codeobj_413;
static PyObject *__pyx_k_codeobj_415;
static PyObject *__pyx_k_codeobj_417;
static PyObject *__pyx_k_codeobj_419;
static PyObject *__pyx_k_codeobj_421;
static PyObject *__pyx_k_codeobj_423;
static PyObject *__pyx_k_codeobj_425;
static PyObject *__pyx_k_codeobj_427;
static PyObject *__pyx_k_codeobj_429;
static PyObject *__pyx_k_codeobj_431;
static PyObject *__pyx_k_codeobj_433;
static PyObject *__pyx_k_codeobj_435;
static PyObject *__pyx_k_codeobj_437;
static PyObject *__pyx_k_codeobj_439;
static PyObject *__pyx_k_codeobj_441;
static PyObject *__pyx_k_codeobj_443;
static PyObject *__pyx_k_codeobj_445;
static PyObject *__pyx_k_codeobj_447;
static PyObject *__pyx_k_codeobj_449;
static PyObject *__pyx_k_codeobj_451;
static PyObject *__pyx_k_codeobj_453;
static PyObject *__pyx_k_codeobj_455;
static PyObject *__pyx_k_codeobj_457;
static PyObject *__pyx_k_codeobj_459;
static PyObject *__pyx_k_codeobj_461;
static PyObject *__pyx_k_codeobj_463;
static PyObject *__pyx_k_codeobj_465;
static PyObject *__pyx_k_codeobj_467;
static PyObject *__pyx_k_codeobj_469;
static PyObject *__pyx_k_codeobj_471;
static PyObject *__pyx_k_codeobj_473;
static PyObject *__pyx_k_codeobj_475;
static PyObject *__pyx_k_codeobj_477;
static PyObject *__pyx_k_codeobj_479;
static PyObject *__pyx_k_codeobj_481;
static PyObject *__pyx_k_codeobj_483;
static PyObject *__pyx_k_codeobj_485;
static PyObject *__pyx_k_codeobj_487;
static PyObject *__pyx_k_codeobj_489;
static PyObject *__pyx_k_codeobj_491;
static PyObject *__pyx_k_codeobj_493;
static PyObject *__pyx_k_codeobj_495;
static PyObject *__pyx_k_codeobj_497;
static PyObject *__pyx_k_codeobj_499;
static PyObject *__pyx_k_codeobj_501;
static PyObject *__pyx_k_codeobj_503;
static PyObject *__pyx_k_codeobj_505;
static PyObject *__pyx_k_codeobj_507;
static PyObject *__pyx_k_codeobj_509;
static PyObject *__pyx_k_codeobj_511;
static PyObject *__pyx_k_codeobj_513;
static PyObject *__pyx_k_codeobj_515;
static PyObject *__pyx_k_codeobj_517;
static PyObject *__pyx_k_codeobj_519;
static PyObject *__pyx_k_codeobj_521;
static PyObject *__pyx_k_codeobj_523;
static PyObject *__pyx_k_codeobj_525;
static PyObject *__pyx_k_codeobj_527;
static PyObject *__pyx_k_codeobj_529;
static PyObject *__pyx_k_codeobj_531;

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_1ACOS(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_ACOS[] = " ACOS(real)\n\n    Vector Trigonometric ACos (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_1ACOS = {__Pyx_NAMESTR("ACOS"), (PyCFunction)__pyx_pw_5talib_4func_1ACOS, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_ACOS)};
static PyObject *__pyx_pw_5talib_4func_1ACOS(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ACOS (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_ACOS(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":347
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ACOS( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ACOS(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_ACOS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ACOS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":365
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 365; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":366
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":367
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":368
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":369
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":370
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":371
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":372
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":373
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":374
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":375
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":377
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ACOS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_4), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":378
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ACOS_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":379
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ACOS_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ACOS_Lookback());

  /* "talib/func.pyx":380
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ACOS_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":381
 *     lookback = begidx + TA_ACOS_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":382
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ACOS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":383
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ACOS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ACOS", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":384
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ACOS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ACOS", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ACOS(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":385
 *         outreal_data[i] = NaN
 *     retCode = TA_ACOS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ACOS", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ACOS, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 385; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":386
 *     retCode = TA_ACOS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ACOS", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ACOS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_3AD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_2AD[] = " AD(high, low, close, volume)\n\n    Chaikin A/D Line (Volume Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close', 'volume']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_3AD = {__Pyx_NAMESTR("AD"), (PyCFunction)__pyx_pw_5talib_4func_3AD, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_2AD)};
static PyObject *__pyx_pw_5talib_4func_3AD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyArrayObject *__pyx_v_volume = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AD (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__volume,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AD", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AD", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__volume)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AD", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "AD") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    __pyx_v_volume = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("AD", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.AD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_volume), __pyx_ptype_5numpy_ndarray, 0, "volume", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_2AD(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_volume);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":390
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AD( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None ):             # <<<<<<<<<<<<<<
 *     """ AD(high, low, close, volume)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_2AD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, PyArrayObject *__pyx_v_volume) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  double *__pyx_v_volume_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);
  __Pyx_INCREF((PyObject *)__pyx_v_volume);

  /* "talib/func.pyx":411
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":412
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":413
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":414
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":415
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":416
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":417
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":418
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":419
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":420
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":421
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":422
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":423
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":424
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":425
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":426
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"             # <<<<<<<<<<<<<<
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_volume) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_11));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":427
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_volume->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_12));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":428
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_volume) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":429
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)             # <<<<<<<<<<<<<<
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_volume); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_volume));
    __pyx_v_volume = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":430
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_volume_data = ((double *)__pyx_v_volume->data);

  /* "talib/func.pyx":431
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":432
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":433
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":434
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":435
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":436
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":438
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AD_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_13), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":439
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_AD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":440
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AD_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_AD_Lookback());

  /* "talib/func.pyx":441
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":442
 *     lookback = begidx + TA_AD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":443
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_AD( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":444
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_AD( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AD", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":445
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_AD( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_AD", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_AD(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), ((double *)(__pyx_v_volume_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":446
 *         outreal_data[i] = NaN
 *     retCode = TA_AD( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AD", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_AD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 446; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":447
 *     retCode = TA_AD( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AD", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.AD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XDECREF((PyObject *)__pyx_v_volume);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_5ADD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_4ADD[] = " ADD(real0, real1)\n\n    Vector Arithmetic Add (Math Operators)\n\n    Inputs:\n        real0: (any ndarray)\n        real1: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_5ADD = {__Pyx_NAMESTR("ADD"), (PyCFunction)__pyx_pw_5talib_4func_5ADD, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_4ADD)};
static PyObject *__pyx_pw_5talib_4func_5ADD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real0 = 0;
  PyArrayObject *__pyx_v_real1 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ADD (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real0,&__pyx_n_s__real1,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real0)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADD", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ADD") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_real0 = ((PyArrayObject *)values[0]);
    __pyx_v_real1 = ((PyArrayObject *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ADD", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ADD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real0), __pyx_ptype_5numpy_ndarray, 0, "real0", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real1), __pyx_ptype_5numpy_ndarray, 0, "real1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_4ADD(__pyx_self, __pyx_v_real0, __pyx_v_real1);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":451
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADD( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ ADD(real0, real1)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_4ADD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real0_data;
  double *__pyx_v_real1_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ADD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real0);
  __Pyx_INCREF((PyObject *)__pyx_v_real1);

  /* "talib/func.pyx":471
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"             # <<<<<<<<<<<<<<
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real0) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_14));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 471; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":472
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real0->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_15));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":473
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real0) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":474
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)             # <<<<<<<<<<<<<<
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real0));
    __pyx_v_real0 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":475
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 */
  __pyx_v_real0_data = ((double *)__pyx_v_real0->data);

  /* "talib/func.pyx":476
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"             # <<<<<<<<<<<<<<
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real1) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_16));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":477
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real1->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_17));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":478
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real1) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":479
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)             # <<<<<<<<<<<<<<
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 479; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 479; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real1));
    __pyx_v_real1 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":480
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data             # <<<<<<<<<<<<<<
 *     length = real0.shape[0]
 *     begidx = 0
 */
  __pyx_v_real1_data = ((double *)__pyx_v_real1->data);

  /* "talib/func.pyx":481
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real0->dimensions[0]);

  /* "talib/func.pyx":482
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":483
 *     length = real0.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real0_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":484
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real0_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":485
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":486
 *         if not isnan(real0_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":488
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADD_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_18), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":489
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ADD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":490
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADD_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ADD_Lookback());

  /* "talib/func.pyx":491
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":492
 *     lookback = begidx + TA_ADD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":493
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ADD( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":494
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ADD( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADD", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":495
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ADD( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ADD", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ADD(0, __pyx_v_endidx, ((double *)(__pyx_v_real0_data + __pyx_v_begidx)), ((double *)(__pyx_v_real1_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":496
 *         outreal_data[i] = NaN
 *     retCode = TA_ADD( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADD", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ADD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":497
 *     retCode = TA_ADD( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADD", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ADD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real0);
  __Pyx_XDECREF((PyObject *)__pyx_v_real1);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_7ADOSC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_6ADOSC[] = " ADOSC(high, low, close, volume[, fastperiod=?, slowperiod=?])\n\n    Chaikin A/D Oscillator (Volume Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close', 'volume']\n    Parameters:\n        fastperiod: 3\n        slowperiod: 10\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_7ADOSC = {__Pyx_NAMESTR("ADOSC"), (PyCFunction)__pyx_pw_5talib_4func_7ADOSC, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_6ADOSC)};
static PyObject *__pyx_pw_5talib_4func_7ADOSC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyArrayObject *__pyx_v_volume = 0;
  int __pyx_v_fastperiod;
  int __pyx_v_slowperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ADOSC (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__volume,&__pyx_n_s__fastperiod,&__pyx_n_s__slowperiod,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADOSC", 0, 4, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADOSC", 0, 4, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__volume)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADOSC", 0, 4, 6, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastperiod);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowperiod);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ADOSC") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    __pyx_v_volume = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_fastperiod = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_fastperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastperiod = ((int)-2147483648);
    }
    if (values[5]) {
      __pyx_v_slowperiod = __Pyx_PyInt_AsInt(values[5]); if (unlikely((__pyx_v_slowperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ADOSC", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ADOSC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_volume), __pyx_ptype_5numpy_ndarray, 0, "volume", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_6ADOSC(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_volume, __pyx_v_fastperiod, __pyx_v_slowperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":501
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADOSC( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None , int fastperiod=-2**31 , int slowperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADOSC(high, low, close, volume[, fastperiod=?, slowperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_6ADOSC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, PyArrayObject *__pyx_v_volume, int __pyx_v_fastperiod, int __pyx_v_slowperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  double *__pyx_v_volume_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ADOSC", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);
  __Pyx_INCREF((PyObject *)__pyx_v_volume);

  /* "talib/func.pyx":525
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":526
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":527
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":528
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":529
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":530
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":531
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":532
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":533
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":534
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":535
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":536
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":537
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":538
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":539
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":540
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"             # <<<<<<<<<<<<<<
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_volume) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_11));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":541
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_volume->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_12));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":542
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_volume) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":543
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)             # <<<<<<<<<<<<<<
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_volume); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_volume));
    __pyx_v_volume = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":544
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_volume_data = ((double *)__pyx_v_volume->data);

  /* "talib/func.pyx":545
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":546
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":547
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":548
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":549
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":550
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":552
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADOSC_Lookback( fastperiod , slowperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_19), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":553
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ADOSC_Lookback( fastperiod , slowperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":554
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADOSC_Lookback( fastperiod , slowperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ADOSC_Lookback(__pyx_v_fastperiod, __pyx_v_slowperiod));

  /* "talib/func.pyx":555
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADOSC_Lookback( fastperiod , slowperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 555; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 555; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":556
 *     lookback = begidx + TA_ADOSC_Lookback( fastperiod , slowperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":557
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ADOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , fastperiod , slowperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":558
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ADOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , fastperiod , slowperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADOSC", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":559
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ADOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , fastperiod , slowperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ADOSC", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ADOSC(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), ((double *)(__pyx_v_volume_data + __pyx_v_begidx)), __pyx_v_fastperiod, __pyx_v_slowperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":560
 *         outreal_data[i] = NaN
 *     retCode = TA_ADOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , fastperiod , slowperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADOSC", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ADOSC, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":561
 *     retCode = TA_ADOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , fastperiod , slowperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADOSC", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ADOSC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XDECREF((PyObject *)__pyx_v_volume);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_9ADX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_8ADX[] = " ADX(high, low, close[, timeperiod=?])\n\n    Average Directional Movement Index (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_9ADX = {__Pyx_NAMESTR("ADX"), (PyCFunction)__pyx_pw_5talib_4func_9ADX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_8ADX)};
static PyObject *__pyx_pw_5talib_4func_9ADX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ADX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADX", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADX", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ADX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ADX", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ADX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_8ADX(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":565
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADX( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADX(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_8ADX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ADX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":587
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":588
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":589
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":590
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 590; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 590; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":591
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":592
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":593
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":594
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":595
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":596
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":597
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":598
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":599
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":600
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":601
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":602
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":603
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":604
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":605
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":606
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":607
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":609
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_20), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":610
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ADX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":611
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ADX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":612
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":613
 *     lookback = begidx + TA_ADX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":614
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ADX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":615
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ADX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADX", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":616
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ADX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ADX", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ADX(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":617
 *         outreal_data[i] = NaN
 *     retCode = TA_ADX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADX", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ADX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":618
 *     retCode = TA_ADX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADX", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ADX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_11ADXR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_10ADXR[] = " ADXR(high, low, close[, timeperiod=?])\n\n    Average Directional Movement Index Rating (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_11ADXR = {__Pyx_NAMESTR("ADXR"), (PyCFunction)__pyx_pw_5talib_4func_11ADXR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_10ADXR)};
static PyObject *__pyx_pw_5talib_4func_11ADXR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ADXR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADXR", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ADXR", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ADXR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ADXR", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ADXR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_10ADXR(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":622
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADXR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADXR(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_10ADXR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ADXR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":644
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 644; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":645
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":646
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":647
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":648
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":649
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 649; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":650
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":651
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":652
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":653
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":654
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 654; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":655
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 655; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":656
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":657
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":658
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":659
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":660
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":661
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":662
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":663
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":664
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":666
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADXR_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_21), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":667
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ADXR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":668
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADXR_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ADXR_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":669
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADXR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":670
 *     lookback = begidx + TA_ADXR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":671
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ADXR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":672
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ADXR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADXR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":673
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ADXR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ADXR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ADXR(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":674
 *         outreal_data[i] = NaN
 *     retCode = TA_ADXR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADXR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ADXR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 674; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":675
 *     retCode = TA_ADXR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ADXR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ADXR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_13APO(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_12APO[] = " APO(real[, fastperiod=?, slowperiod=?, matype=?])\n\n    Absolute Price Oscillator (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        fastperiod: 12\n        slowperiod: 26\n        matype: 0 (Simple Moving Average)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_13APO = {__Pyx_NAMESTR("APO"), (PyCFunction)__pyx_pw_5talib_4func_13APO, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_12APO)};
static PyObject *__pyx_pw_5talib_4func_13APO(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_fastperiod;
  int __pyx_v_slowperiod;
  int __pyx_v_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("APO (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__fastperiod,&__pyx_n_s__slowperiod,&__pyx_n_s__matype,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowperiod);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__matype);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "APO") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_fastperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_fastperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_slowperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_slowperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowperiod = ((int)-2147483648);
    }
    if (values[3]) {
      __pyx_v_matype = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("APO", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.APO", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_12APO(__pyx_self, __pyx_v_real, __pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":679
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def APO( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ APO(real[, fastperiod=?, slowperiod=?, matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_12APO(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_slowperiod, int __pyx_v_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("APO", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":701
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":702
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":703
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":704
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":705
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":706
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":707
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":708
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":709
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":710
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":711
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":713
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_APO_Lookback( fastperiod , slowperiod , matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_22), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":714
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_APO_Lookback( fastperiod , slowperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":715
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_APO_Lookback( fastperiod , slowperiod , matype )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_APO_Lookback(__pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_matype));

  /* "talib/func.pyx":716
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_APO_Lookback( fastperiod , slowperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":717
 *     lookback = begidx + TA_APO_Lookback( fastperiod , slowperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":718
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_APO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":719
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_APO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_APO", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":720
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_APO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_APO", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_APO(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":721
 *         outreal_data[i] = NaN
 *     retCode = TA_APO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_APO", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_APO, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 721; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":722
 *     retCode = TA_APO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_APO", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.APO", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_15AROON(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_14AROON[] = " AROON(high, low[, timeperiod=?])\n\n    Aroon (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        aroondown\n        aroonup\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_15AROON = {__Pyx_NAMESTR("AROON"), (PyCFunction)__pyx_pw_5talib_4func_15AROON, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_14AROON)};
static PyObject *__pyx_pw_5talib_4func_15AROON(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AROON (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AROON", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "AROON") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("AROON", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.AROON", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_14AROON(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":726
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AROON( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ AROON(high, low[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_14AROON(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outaroondown = 0;
  double *__pyx_v_outaroondown_data;
  PyArrayObject *__pyx_v_outaroonup = 0;
  double *__pyx_v_outaroonup_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AROON", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":750
 *         np.ndarray outaroonup
 *         double* outaroonup_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 750; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":751
 *         double* outaroonup_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":752
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":753
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":754
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":755
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 755; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":756
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":757
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":758
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":759
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":760
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":761
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":762
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":763
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":764
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":765
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":767
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROON_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_23), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":768
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_AROON_Lookback( timeperiod )
 *     outaroondown = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":769
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROON_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outaroondown = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outaroondown_data = <double*>outaroondown.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_AROON_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":770
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROON_Lookback( timeperiod )
 *     outaroondown = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outaroondown_data = <double*>outaroondown.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outaroondown = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":771
 *     lookback = begidx + TA_AROON_Lookback( timeperiod )
 *     outaroondown = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outaroondown_data = <double*>outaroondown.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outaroondown_data[i] = NaN
 */
  __pyx_v_outaroondown_data = ((double *)__pyx_v_outaroondown->data);

  /* "talib/func.pyx":772
 *     outaroondown = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outaroondown_data = <double*>outaroondown.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outaroondown_data[i] = NaN
 *     outaroonup = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":773
 *     outaroondown_data = <double*>outaroondown.data
 *     for i from 0 <= i < min(lookback, length):
 *         outaroondown_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outaroonup = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outaroonup_data = <double*>outaroonup.data
 */
    (__pyx_v_outaroondown_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":774
 *     for i from 0 <= i < min(lookback, length):
 *         outaroondown_data[i] = NaN
 *     outaroonup = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outaroonup_data = <double*>outaroonup.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outaroonup = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":775
 *         outaroondown_data[i] = NaN
 *     outaroonup = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outaroonup_data = <double*>outaroonup.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outaroonup_data[i] = NaN
 */
  __pyx_v_outaroonup_data = ((double *)__pyx_v_outaroonup->data);

  /* "talib/func.pyx":776
 *     outaroonup = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outaroonup_data = <double*>outaroonup.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outaroonup_data[i] = NaN
 *     retCode = TA_AROON( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outaroondown_data+lookback) , <double *>(outaroonup_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":777
 *     outaroonup_data = <double*>outaroonup.data
 *     for i from 0 <= i < min(lookback, length):
 *         outaroonup_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_AROON( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outaroondown_data+lookback) , <double *>(outaroonup_data+lookback) )
 *     _ta_check_success("TA_AROON", retCode)
 */
    (__pyx_v_outaroonup_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":778
 *     for i from 0 <= i < min(lookback, length):
 *         outaroonup_data[i] = NaN
 *     retCode = TA_AROON( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outaroondown_data+lookback) , <double *>(outaroonup_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_AROON", retCode)
 *     return outaroondown , outaroonup
 */
  __pyx_v_retCode = TA_AROON(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outaroondown_data + __pyx_v_lookback)), ((double *)(__pyx_v_outaroonup_data + __pyx_v_lookback)));

  /* "talib/func.pyx":779
 *         outaroonup_data[i] = NaN
 *     retCode = TA_AROON( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outaroondown_data+lookback) , <double *>(outaroonup_data+lookback) )
 *     _ta_check_success("TA_AROON", retCode)             # <<<<<<<<<<<<<<
 *     return outaroondown , outaroonup
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_AROON, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 779; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":780
 *     retCode = TA_AROON( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outaroondown_data+lookback) , <double *>(outaroonup_data+lookback) )
 *     _ta_check_success("TA_AROON", retCode)
 *     return outaroondown , outaroonup             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outaroondown));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outaroondown));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outaroondown));
  __Pyx_INCREF(((PyObject *)__pyx_v_outaroonup));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outaroonup));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outaroonup));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.AROON", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outaroondown);
  __Pyx_XDECREF((PyObject *)__pyx_v_outaroonup);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_17AROONOSC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_16AROONOSC[] = " AROONOSC(high, low[, timeperiod=?])\n\n    Aroon Oscillator (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_17AROONOSC = {__Pyx_NAMESTR("AROONOSC"), (PyCFunction)__pyx_pw_5talib_4func_17AROONOSC, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_16AROONOSC)};
static PyObject *__pyx_pw_5talib_4func_17AROONOSC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AROONOSC (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AROONOSC", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "AROONOSC") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("AROONOSC", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.AROONOSC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_16AROONOSC(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":784
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AROONOSC( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ AROONOSC(high, low[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_16AROONOSC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AROONOSC", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":805
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 805; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":806
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 806; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":807
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":808
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":809
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":810
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":811
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 811; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":812
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":813
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":814
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":815
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":816
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":817
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":818
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":819
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":820
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":822
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROONOSC_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_24), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":823
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_AROONOSC_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":824
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROONOSC_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_AROONOSC_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":825
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROONOSC_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":826
 *     lookback = begidx + TA_AROONOSC_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":827
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_AROONOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":828
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_AROONOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AROONOSC", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":829
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_AROONOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_AROONOSC", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_AROONOSC(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":830
 *         outreal_data[i] = NaN
 *     retCode = TA_AROONOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AROONOSC", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_AROONOSC, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":831
 *     retCode = TA_AROONOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AROONOSC", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.AROONOSC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_19ASIN(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_18ASIN[] = " ASIN(real)\n\n    Vector Trigonometric ASin (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_19ASIN = {__Pyx_NAMESTR("ASIN"), (PyCFunction)__pyx_pw_5talib_4func_19ASIN, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_18ASIN)};
static PyObject *__pyx_pw_5talib_4func_19ASIN(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ASIN (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_18ASIN(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":835
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ASIN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ASIN(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_18ASIN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ASIN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":853
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":854
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 854; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":855
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":856
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":857
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":858
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":859
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":860
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":861
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":862
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":863
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":865
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ASIN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_25), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":866
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ASIN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":867
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ASIN_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ASIN_Lookback());

  /* "talib/func.pyx":868
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ASIN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 868; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":869
 *     lookback = begidx + TA_ASIN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":870
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ASIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":871
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ASIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ASIN", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":872
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ASIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ASIN", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ASIN(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":873
 *         outreal_data[i] = NaN
 *     retCode = TA_ASIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ASIN", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ASIN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 873; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":874
 *     retCode = TA_ASIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ASIN", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ASIN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_21ATAN(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_20ATAN[] = " ATAN(real)\n\n    Vector Trigonometric ATan (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_21ATAN = {__Pyx_NAMESTR("ATAN"), (PyCFunction)__pyx_pw_5talib_4func_21ATAN, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_20ATAN)};
static PyObject *__pyx_pw_5talib_4func_21ATAN(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ATAN (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 878; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_20ATAN(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":878
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ATAN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ATAN(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_20ATAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ATAN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":896
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":897
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":898
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":899
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":900
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":901
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":902
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":903
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":904
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":905
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":906
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":908
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATAN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_26), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":909
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ATAN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":910
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATAN_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ATAN_Lookback());

  /* "talib/func.pyx":911
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATAN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 911; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 911; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":912
 *     lookback = begidx + TA_ATAN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":913
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ATAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":914
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ATAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ATAN", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":915
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ATAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ATAN", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ATAN(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":916
 *         outreal_data[i] = NaN
 *     retCode = TA_ATAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ATAN", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ATAN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 916; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":917
 *     retCode = TA_ATAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ATAN", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ATAN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_23ATR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_22ATR[] = " ATR(high, low, close[, timeperiod=?])\n\n    Average True Range (Volatility Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_23ATR = {__Pyx_NAMESTR("ATR"), (PyCFunction)__pyx_pw_5talib_4func_23ATR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_22ATR)};
static PyObject *__pyx_pw_5talib_4func_23ATR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ATR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ATR", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ATR", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ATR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ATR", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ATR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_22ATR(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":921
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ATR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ATR(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_22ATR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ATR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":943
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 943; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":944
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":945
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":946
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 946; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 946; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":947
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":948
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 948; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":949
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 949; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":950
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":951
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 951; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 951; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":952
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":953
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 953; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":954
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":955
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":956
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":957
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":958
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":959
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":960
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":961
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":962
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":963
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":965
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATR_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_27), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":966
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ATR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":967
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATR_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ATR_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":968
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":969
 *     lookback = begidx + TA_ATR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":970
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":971
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ATR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":972
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ATR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ATR(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":973
 *         outreal_data[i] = NaN
 *     retCode = TA_ATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ATR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ATR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 973; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":974
 *     retCode = TA_ATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ATR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ATR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_25AVGPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_24AVGPRICE[] = " AVGPRICE(open, high, low, close)\n\n    Average Price (Price Transform)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_25AVGPRICE = {__Pyx_NAMESTR("AVGPRICE"), (PyCFunction)__pyx_pw_5talib_4func_25AVGPRICE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_24AVGPRICE)};
static PyObject *__pyx_pw_5talib_4func_25AVGPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("AVGPRICE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AVGPRICE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AVGPRICE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("AVGPRICE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "AVGPRICE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("AVGPRICE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.AVGPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_24AVGPRICE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":978
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AVGPRICE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ AVGPRICE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_24AVGPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("AVGPRICE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":999
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1000
 *         double* outreal_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1001
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1002
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1003
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1004
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1005
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1006
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1007
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1008
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1009
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1009; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1010
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1010; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1011
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1012
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1013
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1014
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1014; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1015
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1016
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1017
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1018
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1019
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1020
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1021
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1022
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1023
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1024
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1026
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AVGPRICE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_30), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1027
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_AVGPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1028
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AVGPRICE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_AVGPRICE_Lookback());

  /* "talib/func.pyx":1029
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AVGPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1029; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1029; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1030
 *     lookback = begidx + TA_AVGPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":1031
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_AVGPRICE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1032
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_AVGPRICE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AVGPRICE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1033
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_AVGPRICE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_AVGPRICE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_AVGPRICE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1034
 *         outreal_data[i] = NaN
 *     retCode = TA_AVGPRICE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AVGPRICE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_AVGPRICE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1034; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1035
 *     retCode = TA_AVGPRICE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_AVGPRICE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.AVGPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_27BBANDS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_26BBANDS[] = " BBANDS(real[, timeperiod=?, nbdevup=?, nbdevdn=?, matype=?])\n\n    Bollinger Bands (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 5\n        nbdevup: 2\n        nbdevdn: 2\n        matype: 0 (Simple Moving Average)\n    Outputs:\n        upperband\n        middleband\n        lowerband\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_27BBANDS = {__Pyx_NAMESTR("BBANDS"), (PyCFunction)__pyx_pw_5talib_4func_27BBANDS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_26BBANDS)};
static PyObject *__pyx_pw_5talib_4func_27BBANDS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  double __pyx_v_nbdevup;
  double __pyx_v_nbdevdn;
  int __pyx_v_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BBANDS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,&__pyx_n_s__nbdevup,&__pyx_n_s__nbdevdn,&__pyx_n_s__matype,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nbdevup);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nbdevdn);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__matype);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "BBANDS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_nbdevup = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_nbdevup == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":1039
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BBANDS( np.ndarray real not None , int timeperiod=-2**31 , double nbdevup=-4e37 , double nbdevdn=-4e37 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ BBANDS(real[, timeperiod=?, nbdevup=?, nbdevdn=?, matype=?])
 * 
 */
      __pyx_v_nbdevup = ((double)-4e37);
    }
    if (values[3]) {
      __pyx_v_nbdevdn = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_nbdevdn == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_nbdevdn = ((double)-4e37);
    }
    if (values[4]) {
      __pyx_v_matype = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("BBANDS", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.BBANDS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_26BBANDS(__pyx_self, __pyx_v_real, __pyx_v_timeperiod, __pyx_v_nbdevup, __pyx_v_nbdevdn, __pyx_v_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_26BBANDS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_nbdevup, double __pyx_v_nbdevdn, int __pyx_v_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outrealupperband = 0;
  double *__pyx_v_outrealupperband_data;
  PyArrayObject *__pyx_v_outrealmiddleband = 0;
  double *__pyx_v_outrealmiddleband_data;
  PyArrayObject *__pyx_v_outreallowerband = 0;
  double *__pyx_v_outreallowerband_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BBANDS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":1068
 *         np.ndarray outreallowerband
 *         double* outreallowerband_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1068; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1069
 *         double* outreallowerband_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1070
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1071
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1072
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":1073
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":1074
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1075
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1076
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1077
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1078
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":1080
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BBANDS_Lookback( timeperiod , nbdevup , nbdevdn , matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_31), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":1081
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_BBANDS_Lookback( timeperiod , nbdevup , nbdevdn , matype )
 *     outrealupperband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1082
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BBANDS_Lookback( timeperiod , nbdevup , nbdevdn , matype )             # <<<<<<<<<<<<<<
 *     outrealupperband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outrealupperband_data = <double*>outrealupperband.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_BBANDS_Lookback(__pyx_v_timeperiod, __pyx_v_nbdevup, __pyx_v_nbdevdn, __pyx_v_matype));

  /* "talib/func.pyx":1083
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BBANDS_Lookback( timeperiod , nbdevup , nbdevdn , matype )
 *     outrealupperband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outrealupperband_data = <double*>outrealupperband.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1083; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1083; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outrealupperband = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1084
 *     lookback = begidx + TA_BBANDS_Lookback( timeperiod , nbdevup , nbdevdn , matype )
 *     outrealupperband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outrealupperband_data = <double*>outrealupperband.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outrealupperband_data[i] = NaN
 */
  __pyx_v_outrealupperband_data = ((double *)__pyx_v_outrealupperband->data);

  /* "talib/func.pyx":1085
 *     outrealupperband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outrealupperband_data = <double*>outrealupperband.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outrealupperband_data[i] = NaN
 *     outrealmiddleband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1086
 *     outrealupperband_data = <double*>outrealupperband.data
 *     for i from 0 <= i < min(lookback, length):
 *         outrealupperband_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outrealmiddleband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outrealmiddleband_data = <double*>outrealmiddleband.data
 */
    (__pyx_v_outrealupperband_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1087
 *     for i from 0 <= i < min(lookback, length):
 *         outrealupperband_data[i] = NaN
 *     outrealmiddleband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outrealmiddleband_data = <double*>outrealmiddleband.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1087; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1087; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outrealmiddleband = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1088
 *         outrealupperband_data[i] = NaN
 *     outrealmiddleband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outrealmiddleband_data = <double*>outrealmiddleband.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outrealmiddleband_data[i] = NaN
 */
  __pyx_v_outrealmiddleband_data = ((double *)__pyx_v_outrealmiddleband->data);

  /* "talib/func.pyx":1089
 *     outrealmiddleband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outrealmiddleband_data = <double*>outrealmiddleband.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outrealmiddleband_data[i] = NaN
 *     outreallowerband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1090
 *     outrealmiddleband_data = <double*>outrealmiddleband.data
 *     for i from 0 <= i < min(lookback, length):
 *         outrealmiddleband_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outreallowerband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreallowerband_data = <double*>outreallowerband.data
 */
    (__pyx_v_outrealmiddleband_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1091
 *     for i from 0 <= i < min(lookback, length):
 *         outrealmiddleband_data[i] = NaN
 *     outreallowerband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreallowerband_data = <double*>outreallowerband.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreallowerband = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1092
 *         outrealmiddleband_data[i] = NaN
 *     outreallowerband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreallowerband_data = <double*>outreallowerband.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreallowerband_data[i] = NaN
 */
  __pyx_v_outreallowerband_data = ((double *)__pyx_v_outreallowerband->data);

  /* "talib/func.pyx":1093
 *     outreallowerband = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreallowerband_data = <double*>outreallowerband.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreallowerband_data[i] = NaN
 *     retCode = TA_BBANDS( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdevup , nbdevdn , matype , &outbegidx , &outnbelement , <double *>(outrealupperband_data+lookback) , <double *>(outrealmiddleband_data+lookback) , <double *>(outreallowerband_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1094
 *     outreallowerband_data = <double*>outreallowerband.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreallowerband_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_BBANDS( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdevup , nbdevdn , matype , &outbegidx , &outnbelement , <double *>(outrealupperband_data+lookback) , <double *>(outrealmiddleband_data+lookback) , <double *>(outreallowerband_data+lookback) )
 *     _ta_check_success("TA_BBANDS", retCode)
 */
    (__pyx_v_outreallowerband_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1095
 *     for i from 0 <= i < min(lookback, length):
 *         outreallowerband_data[i] = NaN
 *     retCode = TA_BBANDS( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdevup , nbdevdn , matype , &outbegidx , &outnbelement , <double *>(outrealupperband_data+lookback) , <double *>(outrealmiddleband_data+lookback) , <double *>(outreallowerband_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_BBANDS", retCode)
 *     return outrealupperband , outrealmiddleband , outreallowerband
 */
  __pyx_v_retCode = TA_BBANDS(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, __pyx_v_nbdevup, __pyx_v_nbdevdn, __pyx_v_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outrealupperband_data + __pyx_v_lookback)), ((double *)(__pyx_v_outrealmiddleband_data + __pyx_v_lookback)), ((double *)(__pyx_v_outreallowerband_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1096
 *         outreallowerband_data[i] = NaN
 *     retCode = TA_BBANDS( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdevup , nbdevdn , matype , &outbegidx , &outnbelement , <double *>(outrealupperband_data+lookback) , <double *>(outrealmiddleband_data+lookback) , <double *>(outreallowerband_data+lookback) )
 *     _ta_check_success("TA_BBANDS", retCode)             # <<<<<<<<<<<<<<
 *     return outrealupperband , outrealmiddleband , outreallowerband
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_BBANDS, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1096; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1097
 *     retCode = TA_BBANDS( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdevup , nbdevdn , matype , &outbegidx , &outnbelement , <double *>(outrealupperband_data+lookback) , <double *>(outrealmiddleband_data+lookback) , <double *>(outreallowerband_data+lookback) )
 *     _ta_check_success("TA_BBANDS", retCode)
 *     return outrealupperband , outrealmiddleband , outreallowerband             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1097; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outrealupperband));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outrealupperband));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outrealupperband));
  __Pyx_INCREF(((PyObject *)__pyx_v_outrealmiddleband));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outrealmiddleband));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outrealmiddleband));
  __Pyx_INCREF(((PyObject *)__pyx_v_outreallowerband));
  PyTuple_SET_ITEM(__pyx_t_2, 2, ((PyObject *)__pyx_v_outreallowerband));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outreallowerband));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.BBANDS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outrealupperband);
  __Pyx_XDECREF((PyObject *)__pyx_v_outrealmiddleband);
  __Pyx_XDECREF((PyObject *)__pyx_v_outreallowerband);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_29BETA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_28BETA[] = " BETA(real0, real1[, timeperiod=?])\n\n    Beta (Statistic Functions)\n\n    Inputs:\n        real0: (any ndarray)\n        real1: (any ndarray)\n    Parameters:\n        timeperiod: 5\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_29BETA = {__Pyx_NAMESTR("BETA"), (PyCFunction)__pyx_pw_5talib_4func_29BETA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_28BETA)};
static PyObject *__pyx_pw_5talib_4func_29BETA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real0 = 0;
  PyArrayObject *__pyx_v_real1 = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BETA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real0,&__pyx_n_s__real1,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real0)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("BETA", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "BETA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real0 = ((PyArrayObject *)values[0]);
    __pyx_v_real1 = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("BETA", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.BETA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real0), __pyx_ptype_5numpy_ndarray, 0, "real0", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real1), __pyx_ptype_5numpy_ndarray, 0, "real1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_28BETA(__pyx_self, __pyx_v_real0, __pyx_v_real1, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1101
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BETA( np.ndarray real0 not None , np.ndarray real1 not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ BETA(real0, real1[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_28BETA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real0_data;
  double *__pyx_v_real1_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BETA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real0);
  __Pyx_INCREF((PyObject *)__pyx_v_real1);

  /* "talib/func.pyx":1123
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"             # <<<<<<<<<<<<<<
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real0) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_14));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1124
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real0->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_15));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1125
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real0) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1126
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)             # <<<<<<<<<<<<<<
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real0));
    __pyx_v_real0 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1127
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 */
  __pyx_v_real0_data = ((double *)__pyx_v_real0->data);

  /* "talib/func.pyx":1128
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"             # <<<<<<<<<<<<<<
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real1) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_16));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1129
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real1->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_17));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1130
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real1) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1131
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)             # <<<<<<<<<<<<<<
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real1));
    __pyx_v_real1 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1132
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data             # <<<<<<<<<<<<<<
 *     length = real0.shape[0]
 *     begidx = 0
 */
  __pyx_v_real1_data = ((double *)__pyx_v_real1->data);

  /* "talib/func.pyx":1133
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real0->dimensions[0]);

  /* "talib/func.pyx":1134
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1135
 *     length = real0.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real0_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1136
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real0_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1137
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1138
 *         if not isnan(real0_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":1140
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BETA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_32), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":1141
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_BETA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1142
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BETA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_BETA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":1143
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BETA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1144
 *     lookback = begidx + TA_BETA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":1145
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_BETA( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1146
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_BETA( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_BETA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1147
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_BETA( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_BETA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_BETA(0, __pyx_v_endidx, ((double *)(__pyx_v_real0_data + __pyx_v_begidx)), ((double *)(__pyx_v_real1_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1148
 *         outreal_data[i] = NaN
 *     retCode = TA_BETA( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_BETA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_BETA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1149
 *     retCode = TA_BETA( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_BETA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.BETA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real0);
  __Pyx_XDECREF((PyObject *)__pyx_v_real1);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_31BOP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_30BOP[] = " BOP(open, high, low, close)\n\n    Balance Of Power (Momentum Indicators)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_31BOP = {__Pyx_NAMESTR("BOP"), (PyCFunction)__pyx_pw_5talib_4func_31BOP, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_30BOP)};
static PyObject *__pyx_pw_5talib_4func_31BOP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("BOP (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("BOP", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("BOP", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("BOP", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "BOP") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("BOP", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.BOP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_30BOP(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1153
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BOP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ BOP(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_30BOP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("BOP", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1174
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1175
 *         double* outreal_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1176
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1177
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1178
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1179
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1180
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1181
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1182
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1183
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1184
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1185
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1186
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1187
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1188
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1189
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1190
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1191
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1192
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1193
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1194
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1195
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1196
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1197
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1198
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1199
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1201
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BOP_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_33), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1202
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_BOP_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1203
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BOP_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_BOP_Lookback());

  /* "talib/func.pyx":1204
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BOP_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1205
 *     lookback = begidx + TA_BOP_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":1206
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_BOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1207
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_BOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_BOP", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1208
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_BOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_BOP", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_BOP(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1209
 *         outreal_data[i] = NaN
 *     retCode = TA_BOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_BOP", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_BOP, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1210
 *     retCode = TA_BOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_BOP", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.BOP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_33CCI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_32CCI[] = " CCI(high, low, close[, timeperiod=?])\n\n    Commodity Channel Index (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_33CCI = {__Pyx_NAMESTR("CCI"), (PyCFunction)__pyx_pw_5talib_4func_33CCI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_32CCI)};
static PyObject *__pyx_pw_5talib_4func_33CCI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CCI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CCI", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CCI", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CCI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CCI", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CCI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_32CCI(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1214
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CCI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CCI(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_32CCI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CCI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1236
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1237
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1238
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1239
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1240
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1241
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1242
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1243
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1244
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1245
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1246
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1247
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1248
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1249
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1250
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1251
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1252
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1253
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1254
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1255
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1256
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":1258
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CCI_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_34), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":1259
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CCI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1260
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CCI_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CCI_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":1261
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CCI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1262
 *     lookback = begidx + TA_CCI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":1263
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_CCI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1264
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_CCI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CCI", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":1265
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_CCI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CCI", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_CCI(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1266
 *         outreal_data[i] = NaN
 *     retCode = TA_CCI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CCI", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CCI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1266; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1267
 *     retCode = TA_CCI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CCI", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CCI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_35CDL2CROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_34CDL2CROWS[] = " CDL2CROWS(open, high, low, close)\n\n    Two Crows (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_35CDL2CROWS = {__Pyx_NAMESTR("CDL2CROWS"), (PyCFunction)__pyx_pw_5talib_4func_35CDL2CROWS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_34CDL2CROWS)};
static PyObject *__pyx_pw_5talib_4func_35CDL2CROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL2CROWS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL2CROWS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL2CROWS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL2CROWS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL2CROWS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL2CROWS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL2CROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_34CDL2CROWS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1271
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL2CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL2CROWS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_34CDL2CROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL2CROWS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1292
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1293
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1293; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1294
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1295
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1296
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1297
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1298
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1299
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1300
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1301
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1302
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1302; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1303
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1304
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1305
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1306
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1307
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1308
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1309
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1310
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1311
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1312
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1313
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1314
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1315
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1316
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1317
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1319
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL2CROWS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_35), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1320
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL2CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1321
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL2CROWS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL2CROWS_Lookback());

  /* "talib/func.pyx":1322
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL2CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1323
 *     lookback = begidx + TA_CDL2CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1324
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1325
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL2CROWS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1326
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL2CROWS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL2CROWS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1327
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL2CROWS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDL2CROWS, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1328
 *     retCode = TA_CDL2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL2CROWS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL2CROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_37CDL3BLACKCROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_36CDL3BLACKCROWS[] = " CDL3BLACKCROWS(open, high, low, close)\n\n    Three Black Crows (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_37CDL3BLACKCROWS = {__Pyx_NAMESTR("CDL3BLACKCROWS"), (PyCFunction)__pyx_pw_5talib_4func_37CDL3BLACKCROWS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_36CDL3BLACKCROWS)};
static PyObject *__pyx_pw_5talib_4func_37CDL3BLACKCROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL3BLACKCROWS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3BLACKCROWS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3BLACKCROWS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3BLACKCROWS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL3BLACKCROWS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL3BLACKCROWS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL3BLACKCROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_36CDL3BLACKCROWS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1332
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3BLACKCROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3BLACKCROWS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_36CDL3BLACKCROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL3BLACKCROWS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1353
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1354
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1354; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1355
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1356
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1356; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1356; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1357
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1358
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1358; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1359
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1360
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1361
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1362
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1363
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1364
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1365
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1366
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1367
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1368
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1369
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1370
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1371
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1372
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1373
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1374
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1375
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1376
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1377
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1378
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1380
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3BLACKCROWS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_36), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1381
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL3BLACKCROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1382
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3BLACKCROWS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL3BLACKCROWS_Lookback());

  /* "talib/func.pyx":1383
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3BLACKCROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1384
 *     lookback = begidx + TA_CDL3BLACKCROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1385
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3BLACKCROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1386
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL3BLACKCROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3BLACKCROWS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1387
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3BLACKCROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL3BLACKCROWS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL3BLACKCROWS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1388
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3BLACKCROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3BLACKCROWS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDL3BLACKCROWS, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1389
 *     retCode = TA_CDL3BLACKCROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3BLACKCROWS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL3BLACKCROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_39CDL3INSIDE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_38CDL3INSIDE[] = " CDL3INSIDE(open, high, low, close)\n\n    Three Inside Up/Down (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_39CDL3INSIDE = {__Pyx_NAMESTR("CDL3INSIDE"), (PyCFunction)__pyx_pw_5talib_4func_39CDL3INSIDE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_38CDL3INSIDE)};
static PyObject *__pyx_pw_5talib_4func_39CDL3INSIDE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL3INSIDE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3INSIDE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3INSIDE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3INSIDE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL3INSIDE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL3INSIDE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL3INSIDE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_38CDL3INSIDE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1393
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3INSIDE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3INSIDE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_38CDL3INSIDE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL3INSIDE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1414
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1415
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1416
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1417
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1418
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1419
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1420
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1421
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1422
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1423
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1424
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1425
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1426
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1427
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1428
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1429
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1430
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1431
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1432
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1433
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1434
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1435
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1436
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1437
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1438
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1439
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1441
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3INSIDE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_37), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1442
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL3INSIDE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1443
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3INSIDE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL3INSIDE_Lookback());

  /* "talib/func.pyx":1444
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3INSIDE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1445
 *     lookback = begidx + TA_CDL3INSIDE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1446
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3INSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1447
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL3INSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3INSIDE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1448
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3INSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL3INSIDE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL3INSIDE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1449
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3INSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3INSIDE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDL3INSIDE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1449; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1450
 *     retCode = TA_CDL3INSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3INSIDE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL3INSIDE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_41CDL3LINESTRIKE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_40CDL3LINESTRIKE[] = " CDL3LINESTRIKE(open, high, low, close)\n\n    Three-Line Strike  (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_41CDL3LINESTRIKE = {__Pyx_NAMESTR("CDL3LINESTRIKE"), (PyCFunction)__pyx_pw_5talib_4func_41CDL3LINESTRIKE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_40CDL3LINESTRIKE)};
static PyObject *__pyx_pw_5talib_4func_41CDL3LINESTRIKE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL3LINESTRIKE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3LINESTRIKE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3LINESTRIKE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3LINESTRIKE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL3LINESTRIKE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL3LINESTRIKE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL3LINESTRIKE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_40CDL3LINESTRIKE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1454
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3LINESTRIKE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3LINESTRIKE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_40CDL3LINESTRIKE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL3LINESTRIKE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1475
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1476
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1476; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1477
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1478
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1479
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1480
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1481
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1482
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1483
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1484
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1485
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1486
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1487
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1488
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1489
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1490
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1490; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1491
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1492
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1493
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1494
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1495
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1496
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1497
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1498
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1499
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1500
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1502
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3LINESTRIKE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_38), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1503
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL3LINESTRIKE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1504
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3LINESTRIKE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL3LINESTRIKE_Lookback());

  /* "talib/func.pyx":1505
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3LINESTRIKE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1506
 *     lookback = begidx + TA_CDL3LINESTRIKE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1507
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3LINESTRIKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1508
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL3LINESTRIKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3LINESTRIKE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1509
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3LINESTRIKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL3LINESTRIKE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL3LINESTRIKE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1510
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3LINESTRIKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3LINESTRIKE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDL3LINESTRIKE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1511
 *     retCode = TA_CDL3LINESTRIKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3LINESTRIKE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL3LINESTRIKE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_43CDL3OUTSIDE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_42CDL3OUTSIDE[] = " CDL3OUTSIDE(open, high, low, close)\n\n    Three Outside Up/Down (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_43CDL3OUTSIDE = {__Pyx_NAMESTR("CDL3OUTSIDE"), (PyCFunction)__pyx_pw_5talib_4func_43CDL3OUTSIDE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_42CDL3OUTSIDE)};
static PyObject *__pyx_pw_5talib_4func_43CDL3OUTSIDE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL3OUTSIDE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3OUTSIDE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3OUTSIDE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3OUTSIDE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL3OUTSIDE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL3OUTSIDE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL3OUTSIDE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_42CDL3OUTSIDE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1515
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3OUTSIDE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3OUTSIDE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_42CDL3OUTSIDE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL3OUTSIDE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1536
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1537
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1537; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1538
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1539
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1540
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1541
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1542
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1543
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1544
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1545
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1546
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1547
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1548
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1549
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1550
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1551
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1552
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1553
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1554
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1554; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1554; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1555
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1556
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1557
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1558
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1559
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1560
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1561
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1563
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3OUTSIDE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_39), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1564
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL3OUTSIDE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1565
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3OUTSIDE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL3OUTSIDE_Lookback());

  /* "talib/func.pyx":1566
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3OUTSIDE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1567
 *     lookback = begidx + TA_CDL3OUTSIDE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1568
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3OUTSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1569
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL3OUTSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3OUTSIDE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1570
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3OUTSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL3OUTSIDE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL3OUTSIDE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1571
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3OUTSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3OUTSIDE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDL3OUTSIDE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1571; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1572
 *     retCode = TA_CDL3OUTSIDE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3OUTSIDE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL3OUTSIDE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_45CDL3STARSINSOUTH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_44CDL3STARSINSOUTH[] = " CDL3STARSINSOUTH(open, high, low, close)\n\n    Three Stars In The South (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_45CDL3STARSINSOUTH = {__Pyx_NAMESTR("CDL3STARSINSOUTH"), (PyCFunction)__pyx_pw_5talib_4func_45CDL3STARSINSOUTH, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_44CDL3STARSINSOUTH)};
static PyObject *__pyx_pw_5talib_4func_45CDL3STARSINSOUTH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL3STARSINSOUTH (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3STARSINSOUTH", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3STARSINSOUTH", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3STARSINSOUTH", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL3STARSINSOUTH") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL3STARSINSOUTH", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL3STARSINSOUTH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_44CDL3STARSINSOUTH(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1576
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3STARSINSOUTH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3STARSINSOUTH(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_44CDL3STARSINSOUTH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL3STARSINSOUTH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1597
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1598
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1599
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1600
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1601
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1602
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1602; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1603
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1603; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1604
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1605
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1605; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1605; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1606
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1607
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1608
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1609
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1610
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1611
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1612
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1613
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1614
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1615
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1616
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1617
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1618
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1619
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1620
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1621
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1622
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1624
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3STARSINSOUTH_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_40), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1625
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL3STARSINSOUTH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1626
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3STARSINSOUTH_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL3STARSINSOUTH_Lookback());

  /* "talib/func.pyx":1627
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3STARSINSOUTH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1628
 *     lookback = begidx + TA_CDL3STARSINSOUTH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1629
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3STARSINSOUTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1630
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL3STARSINSOUTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3STARSINSOUTH", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1631
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3STARSINSOUTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL3STARSINSOUTH", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL3STARSINSOUTH(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1632
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3STARSINSOUTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3STARSINSOUTH", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDL3STARSINSOUTH, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1633
 *     retCode = TA_CDL3STARSINSOUTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3STARSINSOUTH", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL3STARSINSOUTH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_47CDL3WHITESOLDIERS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_46CDL3WHITESOLDIERS[] = " CDL3WHITESOLDIERS(open, high, low, close)\n\n    Three Advancing White Soldiers (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_47CDL3WHITESOLDIERS = {__Pyx_NAMESTR("CDL3WHITESOLDIERS"), (PyCFunction)__pyx_pw_5talib_4func_47CDL3WHITESOLDIERS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_46CDL3WHITESOLDIERS)};
static PyObject *__pyx_pw_5talib_4func_47CDL3WHITESOLDIERS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDL3WHITESOLDIERS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3WHITESOLDIERS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3WHITESOLDIERS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDL3WHITESOLDIERS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDL3WHITESOLDIERS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDL3WHITESOLDIERS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDL3WHITESOLDIERS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_46CDL3WHITESOLDIERS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1637
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3WHITESOLDIERS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3WHITESOLDIERS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_46CDL3WHITESOLDIERS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDL3WHITESOLDIERS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1658
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1659
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1660
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1661
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1662
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1663
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1664
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1664; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1665
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1666
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1667
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1668
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1668; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1669
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1670
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1671
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1671; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1671; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1672
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1673
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1673; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1674
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1674; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1675
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1676
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1677
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1678
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1679
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1680
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1681
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1682
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1683
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1685
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3WHITESOLDIERS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_41), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1686
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDL3WHITESOLDIERS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1687
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3WHITESOLDIERS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDL3WHITESOLDIERS_Lookback());

  /* "talib/func.pyx":1688
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3WHITESOLDIERS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1689
 *     lookback = begidx + TA_CDL3WHITESOLDIERS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1690
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3WHITESOLDIERS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1691
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDL3WHITESOLDIERS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3WHITESOLDIERS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1692
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3WHITESOLDIERS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDL3WHITESOLDIERS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDL3WHITESOLDIERS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1693
 *         outinteger_data[i] = 0
 *     retCode = TA_CDL3WHITESOLDIERS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3WHITESOLDIERS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_42, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1693; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1694
 *     retCode = TA_CDL3WHITESOLDIERS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDL3WHITESOLDIERS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDL3WHITESOLDIERS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_49CDLABANDONEDBABY(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_48CDLABANDONEDBABY[] = " CDLABANDONEDBABY(open, high, low, close[, penetration=?])\n\n    Abandoned Baby (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.3\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_49CDLABANDONEDBABY = {__Pyx_NAMESTR("CDLABANDONEDBABY"), (PyCFunction)__pyx_pw_5talib_4func_49CDLABANDONEDBABY, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_48CDLABANDONEDBABY)};
static PyObject *__pyx_pw_5talib_4func_49CDLABANDONEDBABY(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLABANDONEDBABY (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLABANDONEDBABY", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLABANDONEDBABY", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLABANDONEDBABY", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLABANDONEDBABY") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":1698
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLABANDONEDBABY( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLABANDONEDBABY(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.3);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLABANDONEDBABY", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLABANDONEDBABY", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_48CDLABANDONEDBABY(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_48CDLABANDONEDBABY(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLABANDONEDBABY", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1721
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1721; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1722
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1723
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1724
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1725
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1726
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1727
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1728
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1729
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1729; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1729; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1730
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1731
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1732
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1732; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1733
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1734
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1735
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1736
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1737
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1737; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1738
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1739
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1740
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1741
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1742
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1743
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1744
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1745
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1746
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1748
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLABANDONEDBABY_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_43), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1749
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLABANDONEDBABY_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1750
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLABANDONEDBABY_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLABANDONEDBABY_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":1751
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLABANDONEDBABY_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1752
 *     lookback = begidx + TA_CDLABANDONEDBABY_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1753
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLABANDONEDBABY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1754
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLABANDONEDBABY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLABANDONEDBABY", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1755
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLABANDONEDBABY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLABANDONEDBABY", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLABANDONEDBABY(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1756
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLABANDONEDBABY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLABANDONEDBABY", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLABANDONEDBABY, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1757
 *     retCode = TA_CDLABANDONEDBABY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLABANDONEDBABY", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLABANDONEDBABY", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_51CDLADVANCEBLOCK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_50CDLADVANCEBLOCK[] = " CDLADVANCEBLOCK(open, high, low, close)\n\n    Advance Block (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_51CDLADVANCEBLOCK = {__Pyx_NAMESTR("CDLADVANCEBLOCK"), (PyCFunction)__pyx_pw_5talib_4func_51CDLADVANCEBLOCK, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_50CDLADVANCEBLOCK)};
static PyObject *__pyx_pw_5talib_4func_51CDLADVANCEBLOCK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLADVANCEBLOCK (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLADVANCEBLOCK", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLADVANCEBLOCK", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLADVANCEBLOCK", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLADVANCEBLOCK") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLADVANCEBLOCK", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLADVANCEBLOCK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_50CDLADVANCEBLOCK(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1761
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLADVANCEBLOCK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLADVANCEBLOCK(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_50CDLADVANCEBLOCK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLADVANCEBLOCK", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1782
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1783
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1784
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1785
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1785; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1786
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1787
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1788
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1788; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1789
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1790
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1790; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1791
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1792
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1793
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1793; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1794
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1795
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1796
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1797
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1797; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1798
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1799
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1800
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1801
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1802
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1803
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1804
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1805
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1806
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1807
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1809
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLADVANCEBLOCK_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_44), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1810
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLADVANCEBLOCK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1811
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLADVANCEBLOCK_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLADVANCEBLOCK_Lookback());

  /* "talib/func.pyx":1812
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLADVANCEBLOCK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1812; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1813
 *     lookback = begidx + TA_CDLADVANCEBLOCK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1814
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLADVANCEBLOCK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1815
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLADVANCEBLOCK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLADVANCEBLOCK", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1816
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLADVANCEBLOCK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLADVANCEBLOCK", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLADVANCEBLOCK(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1817
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLADVANCEBLOCK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLADVANCEBLOCK", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLADVANCEBLOCK, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1817; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1818
 *     retCode = TA_CDLADVANCEBLOCK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLADVANCEBLOCK", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLADVANCEBLOCK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_53CDLBELTHOLD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_52CDLBELTHOLD[] = " CDLBELTHOLD(open, high, low, close)\n\n    Belt-hold (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_53CDLBELTHOLD = {__Pyx_NAMESTR("CDLBELTHOLD"), (PyCFunction)__pyx_pw_5talib_4func_53CDLBELTHOLD, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_52CDLBELTHOLD)};
static PyObject *__pyx_pw_5talib_4func_53CDLBELTHOLD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLBELTHOLD (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLBELTHOLD", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLBELTHOLD", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLBELTHOLD", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLBELTHOLD") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLBELTHOLD", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLBELTHOLD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_52CDLBELTHOLD(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1822
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLBELTHOLD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLBELTHOLD(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_52CDLBELTHOLD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLBELTHOLD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1843
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1844
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1845
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1846
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1846; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1846; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1847
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1848
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1849
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1850
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1851
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1851; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1852
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1853
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1854
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1854; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1855
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1856
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1856; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1857
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1858
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1859
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1859; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1860
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1861
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1862
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1863
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1864
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1865
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1866
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1867
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1868
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1870
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBELTHOLD_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_45), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1871
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLBELTHOLD_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1872
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBELTHOLD_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLBELTHOLD_Lookback());

  /* "talib/func.pyx":1873
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBELTHOLD_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1873; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1873; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1874
 *     lookback = begidx + TA_CDLBELTHOLD_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1875
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLBELTHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1876
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLBELTHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLBELTHOLD", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1877
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLBELTHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLBELTHOLD", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLBELTHOLD(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1878
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLBELTHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLBELTHOLD", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLBELTHOLD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1878; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1879
 *     retCode = TA_CDLBELTHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLBELTHOLD", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLBELTHOLD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_55CDLBREAKAWAY(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_54CDLBREAKAWAY[] = " CDLBREAKAWAY(open, high, low, close)\n\n    Breakaway (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_55CDLBREAKAWAY = {__Pyx_NAMESTR("CDLBREAKAWAY"), (PyCFunction)__pyx_pw_5talib_4func_55CDLBREAKAWAY, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_54CDLBREAKAWAY)};
static PyObject *__pyx_pw_5talib_4func_55CDLBREAKAWAY(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLBREAKAWAY (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLBREAKAWAY", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLBREAKAWAY", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLBREAKAWAY", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLBREAKAWAY") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLBREAKAWAY", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLBREAKAWAY", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_54CDLBREAKAWAY(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1883
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLBREAKAWAY( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLBREAKAWAY(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_54CDLBREAKAWAY(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLBREAKAWAY", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1904
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1904; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1905
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1906
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1907
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1907; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1907; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1908
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1909
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1909; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1910
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1911
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1912
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1912; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1912; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1913
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1914
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1914; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1915
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1915; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1916
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1917
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1918
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1919
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1919; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1920
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1920; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1921
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1922
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1923
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1924
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1925
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1926
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1927
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1928
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1929
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1931
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBREAKAWAY_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_46), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1931; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1931; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1932
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLBREAKAWAY_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1933
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBREAKAWAY_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLBREAKAWAY_Lookback());

  /* "talib/func.pyx":1934
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBREAKAWAY_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1935
 *     lookback = begidx + TA_CDLBREAKAWAY_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1936
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLBREAKAWAY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1937
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLBREAKAWAY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLBREAKAWAY", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1938
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLBREAKAWAY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLBREAKAWAY", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLBREAKAWAY(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":1939
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLBREAKAWAY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLBREAKAWAY", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLBREAKAWAY, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1939; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":1940
 *     retCode = TA_CDLBREAKAWAY( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLBREAKAWAY", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLBREAKAWAY", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_57CDLCLOSINGMARUBOZU(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_56CDLCLOSINGMARUBOZU[] = " CDLCLOSINGMARUBOZU(open, high, low, close)\n\n    Closing Marubozu (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_57CDLCLOSINGMARUBOZU = {__Pyx_NAMESTR("CDLCLOSINGMARUBOZU"), (PyCFunction)__pyx_pw_5talib_4func_57CDLCLOSINGMARUBOZU, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_56CDLCLOSINGMARUBOZU)};
static PyObject *__pyx_pw_5talib_4func_57CDLCLOSINGMARUBOZU(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLCLOSINGMARUBOZU (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCLOSINGMARUBOZU", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCLOSINGMARUBOZU", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCLOSINGMARUBOZU", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLCLOSINGMARUBOZU") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLCLOSINGMARUBOZU", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLCLOSINGMARUBOZU", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_56CDLCLOSINGMARUBOZU(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":1944
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCLOSINGMARUBOZU( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCLOSINGMARUBOZU(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_56CDLCLOSINGMARUBOZU(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLCLOSINGMARUBOZU", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":1965
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1966
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1966; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1967
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1968
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":1969
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":1970
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1970; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1971
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1972
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1973
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1973; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1973; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":1974
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":1975
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1976
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1976; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1977
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1978
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":1979
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":1980
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1980; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1981
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":1982
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":1983
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":1984
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":1985
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":1986
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":1987
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":1988
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":1989
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":1990
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":1992
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCLOSINGMARUBOZU_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_47), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1992; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1992; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":1993
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLCLOSINGMARUBOZU_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":1994
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCLOSINGMARUBOZU_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLCLOSINGMARUBOZU_Lookback());

  /* "talib/func.pyx":1995
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCLOSINGMARUBOZU_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":1996
 *     lookback = begidx + TA_CDLCLOSINGMARUBOZU_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":1997
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCLOSINGMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":1998
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLCLOSINGMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCLOSINGMARUBOZU", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":1999
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCLOSINGMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLCLOSINGMARUBOZU", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLCLOSINGMARUBOZU(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2000
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCLOSINGMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCLOSINGMARUBOZU", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_48, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2001
 *     retCode = TA_CDLCLOSINGMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCLOSINGMARUBOZU", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLCLOSINGMARUBOZU", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_59CDLCONCEALBABYSWALL(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_58CDLCONCEALBABYSWALL[] = " CDLCONCEALBABYSWALL(open, high, low, close)\n\n    Concealing Baby Swallow (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_59CDLCONCEALBABYSWALL = {__Pyx_NAMESTR("CDLCONCEALBABYSWALL"), (PyCFunction)__pyx_pw_5talib_4func_59CDLCONCEALBABYSWALL, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_58CDLCONCEALBABYSWALL)};
static PyObject *__pyx_pw_5talib_4func_59CDLCONCEALBABYSWALL(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLCONCEALBABYSWALL (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCONCEALBABYSWALL", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCONCEALBABYSWALL", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCONCEALBABYSWALL", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLCONCEALBABYSWALL") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLCONCEALBABYSWALL", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLCONCEALBABYSWALL", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_58CDLCONCEALBABYSWALL(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2005
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCONCEALBABYSWALL( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCONCEALBABYSWALL(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_58CDLCONCEALBABYSWALL(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLCONCEALBABYSWALL", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2026
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2027
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2028
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2029
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2029; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2029; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2030
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2031
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2031; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2032
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2032; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2033
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2034
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2034; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2034; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2035
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2036
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2036; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2037
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2037; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2038
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2039
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2040
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2041
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2041; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2042
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2042; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2043
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2044
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2044; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2044; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2045
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2046
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2047
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2048
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2049
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2050
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2051
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2053
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCONCEALBABYSWALL_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_49), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2054
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLCONCEALBABYSWALL_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2055
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCONCEALBABYSWALL_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLCONCEALBABYSWALL_Lookback());

  /* "talib/func.pyx":2056
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCONCEALBABYSWALL_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2057
 *     lookback = begidx + TA_CDLCONCEALBABYSWALL_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2058
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCONCEALBABYSWALL( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2059
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLCONCEALBABYSWALL( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCONCEALBABYSWALL", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2060
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCONCEALBABYSWALL( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLCONCEALBABYSWALL", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLCONCEALBABYSWALL(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2061
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCONCEALBABYSWALL( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCONCEALBABYSWALL", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_50, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2061; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2062
 *     retCode = TA_CDLCONCEALBABYSWALL( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCONCEALBABYSWALL", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLCONCEALBABYSWALL", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_61CDLCOUNTERATTACK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_60CDLCOUNTERATTACK[] = " CDLCOUNTERATTACK(open, high, low, close)\n\n    Counterattack (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_61CDLCOUNTERATTACK = {__Pyx_NAMESTR("CDLCOUNTERATTACK"), (PyCFunction)__pyx_pw_5talib_4func_61CDLCOUNTERATTACK, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_60CDLCOUNTERATTACK)};
static PyObject *__pyx_pw_5talib_4func_61CDLCOUNTERATTACK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLCOUNTERATTACK (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCOUNTERATTACK", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCOUNTERATTACK", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLCOUNTERATTACK", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLCOUNTERATTACK") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLCOUNTERATTACK", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLCOUNTERATTACK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_60CDLCOUNTERATTACK(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2066
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCOUNTERATTACK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCOUNTERATTACK(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_60CDLCOUNTERATTACK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLCOUNTERATTACK", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2087
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2087; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2088
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2088; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2089
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2090
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2090; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2090; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2091
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2092
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2092; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2093
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2093; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2094
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2095
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2095; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2095; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2096
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2097
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2097; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2098
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2098; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2099
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2100
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2101
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2102
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2103
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2104
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2105
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2106
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2107
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2108
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2109
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2110
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2111
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2112
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2114
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCOUNTERATTACK_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_51), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2115
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLCOUNTERATTACK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2116
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCOUNTERATTACK_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLCOUNTERATTACK_Lookback());

  /* "talib/func.pyx":2117
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCOUNTERATTACK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2118
 *     lookback = begidx + TA_CDLCOUNTERATTACK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2119
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCOUNTERATTACK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2120
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLCOUNTERATTACK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCOUNTERATTACK", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2121
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCOUNTERATTACK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLCOUNTERATTACK", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLCOUNTERATTACK(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2122
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLCOUNTERATTACK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCOUNTERATTACK", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLCOUNTERATTACK, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2123
 *     retCode = TA_CDLCOUNTERATTACK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLCOUNTERATTACK", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLCOUNTERATTACK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_63CDLDARKCLOUDCOVER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_62CDLDARKCLOUDCOVER[] = " CDLDARKCLOUDCOVER(open, high, low, close[, penetration=?])\n\n    Dark Cloud Cover (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.5\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_63CDLDARKCLOUDCOVER = {__Pyx_NAMESTR("CDLDARKCLOUDCOVER"), (PyCFunction)__pyx_pw_5talib_4func_63CDLDARKCLOUDCOVER, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_62CDLDARKCLOUDCOVER)};
static PyObject *__pyx_pw_5talib_4func_63CDLDARKCLOUDCOVER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLDARKCLOUDCOVER (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDARKCLOUDCOVER", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDARKCLOUDCOVER", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDARKCLOUDCOVER", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLDARKCLOUDCOVER") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":2127
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDARKCLOUDCOVER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.5 ):             # <<<<<<<<<<<<<<
 *     """ CDLDARKCLOUDCOVER(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.5);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLDARKCLOUDCOVER", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLDARKCLOUDCOVER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_62CDLDARKCLOUDCOVER(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_62CDLDARKCLOUDCOVER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLDARKCLOUDCOVER", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2150
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2151
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2152
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2153
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2154
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2155
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2156
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2157
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2158
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2159
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2160
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2161
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2162
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2163
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2164
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2165
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2166
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2167
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2168
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2169
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2170
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2171
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2172
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2173
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2174
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2175
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2177
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDARKCLOUDCOVER_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_52), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2178
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLDARKCLOUDCOVER_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2179
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDARKCLOUDCOVER_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLDARKCLOUDCOVER_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":2180
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDARKCLOUDCOVER_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2181
 *     lookback = begidx + TA_CDLDARKCLOUDCOVER_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2182
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDARKCLOUDCOVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2183
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLDARKCLOUDCOVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDARKCLOUDCOVER", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2184
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDARKCLOUDCOVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLDARKCLOUDCOVER", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLDARKCLOUDCOVER(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2185
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDARKCLOUDCOVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDARKCLOUDCOVER", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_53, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2186
 *     retCode = TA_CDLDARKCLOUDCOVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDARKCLOUDCOVER", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLDARKCLOUDCOVER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_65CDLDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_64CDLDOJI[] = " CDLDOJI(open, high, low, close)\n\n    Doji (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_65CDLDOJI = {__Pyx_NAMESTR("CDLDOJI"), (PyCFunction)__pyx_pw_5talib_4func_65CDLDOJI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_64CDLDOJI)};
static PyObject *__pyx_pw_5talib_4func_65CDLDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLDOJI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDOJI", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDOJI", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDOJI", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLDOJI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLDOJI", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_64CDLDOJI(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2190
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDOJI(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_64CDLDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLDOJI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2211
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2212
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2213
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2214
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2215
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2216
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2216; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2217
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2217; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2218
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2219
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2220
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2221
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2222
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2223
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2224
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2225
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2226
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2227
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2228
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2229
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2229; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2230
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2231
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2232
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2233
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2234
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2235
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2236
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2238
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJI_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_54), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2239
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2240
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJI_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLDOJI_Lookback());

  /* "talib/func.pyx":2241
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2241; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2242
 *     lookback = begidx + TA_CDLDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2243
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2244
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDOJI", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2245
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLDOJI", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLDOJI(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2246
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDOJI", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLDOJI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2247
 *     retCode = TA_CDLDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDOJI", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_67CDLDOJISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_66CDLDOJISTAR[] = " CDLDOJISTAR(open, high, low, close)\n\n    Doji Star (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_67CDLDOJISTAR = {__Pyx_NAMESTR("CDLDOJISTAR"), (PyCFunction)__pyx_pw_5talib_4func_67CDLDOJISTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_66CDLDOJISTAR)};
static PyObject *__pyx_pw_5talib_4func_67CDLDOJISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLDOJISTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDOJISTAR", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDOJISTAR", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDOJISTAR", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLDOJISTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLDOJISTAR", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLDOJISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_66CDLDOJISTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2251
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDOJISTAR(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_66CDLDOJISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLDOJISTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2272
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2273
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2273; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2274
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2275
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2276
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2277
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2278
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2278; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2279
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2280
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2281
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2282
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2282; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2283
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2283; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2284
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2285
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2285; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2285; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2286
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2287
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2288
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2289
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2290
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2291
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2292
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2293
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2294
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2295
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2296
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2297
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2299
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJISTAR_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_55), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2300
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLDOJISTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2301
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJISTAR_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLDOJISTAR_Lookback());

  /* "talib/func.pyx":2302
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJISTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2302; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2302; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2303
 *     lookback = begidx + TA_CDLDOJISTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2304
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2305
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDOJISTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2306
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLDOJISTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLDOJISTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2307
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDOJISTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLDOJISTAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2308
 *     retCode = TA_CDLDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDOJISTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLDOJISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_69CDLDRAGONFLYDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_68CDLDRAGONFLYDOJI[] = " CDLDRAGONFLYDOJI(open, high, low, close)\n\n    Dragonfly Doji (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_69CDLDRAGONFLYDOJI = {__Pyx_NAMESTR("CDLDRAGONFLYDOJI"), (PyCFunction)__pyx_pw_5talib_4func_69CDLDRAGONFLYDOJI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_68CDLDRAGONFLYDOJI)};
static PyObject *__pyx_pw_5talib_4func_69CDLDRAGONFLYDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLDRAGONFLYDOJI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDRAGONFLYDOJI", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDRAGONFLYDOJI", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLDRAGONFLYDOJI", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLDRAGONFLYDOJI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLDRAGONFLYDOJI", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLDRAGONFLYDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_68CDLDRAGONFLYDOJI(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2312
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDRAGONFLYDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDRAGONFLYDOJI(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_68CDLDRAGONFLYDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLDRAGONFLYDOJI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2333
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2334
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2335
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2336
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2337
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2338
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2339
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2340
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2341
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2342
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2343
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2344
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2345
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2346
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2347
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2348
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2349
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2350
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2351
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2351; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2351; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2352
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2353
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2354
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2355
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2356
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2357
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2358
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2360
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDRAGONFLYDOJI_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_56), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2361
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLDRAGONFLYDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2362
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDRAGONFLYDOJI_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLDRAGONFLYDOJI_Lookback());

  /* "talib/func.pyx":2363
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDRAGONFLYDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2364
 *     lookback = begidx + TA_CDLDRAGONFLYDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2365
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDRAGONFLYDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2366
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLDRAGONFLYDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDRAGONFLYDOJI", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2367
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDRAGONFLYDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLDRAGONFLYDOJI", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLDRAGONFLYDOJI(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2368
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLDRAGONFLYDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDRAGONFLYDOJI", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLDRAGONFLYDOJI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2369
 *     retCode = TA_CDLDRAGONFLYDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLDRAGONFLYDOJI", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLDRAGONFLYDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_71CDLENGULFING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_70CDLENGULFING[] = " CDLENGULFING(open, high, low, close)\n\n    Engulfing Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_71CDLENGULFING = {__Pyx_NAMESTR("CDLENGULFING"), (PyCFunction)__pyx_pw_5talib_4func_71CDLENGULFING, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_70CDLENGULFING)};
static PyObject *__pyx_pw_5talib_4func_71CDLENGULFING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLENGULFING (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLENGULFING", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLENGULFING", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLENGULFING", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLENGULFING") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLENGULFING", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLENGULFING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_70CDLENGULFING(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2373
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLENGULFING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLENGULFING(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_70CDLENGULFING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLENGULFING", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2394
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2394; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2395
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2396
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2397
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2398
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2399
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2400
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2400; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2401
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2402
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2403
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2404
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2404; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2405
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2406
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2407
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2408
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2409
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2410
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2411
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2412
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2413
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2414
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2415
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2416
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2417
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2418
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2419
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2421
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLENGULFING_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_57), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2422
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLENGULFING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2423
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLENGULFING_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLENGULFING_Lookback());

  /* "talib/func.pyx":2424
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLENGULFING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2425
 *     lookback = begidx + TA_CDLENGULFING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2426
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLENGULFING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2427
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLENGULFING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLENGULFING", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2428
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLENGULFING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLENGULFING", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLENGULFING(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2429
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLENGULFING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLENGULFING", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLENGULFING, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2430
 *     retCode = TA_CDLENGULFING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLENGULFING", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLENGULFING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_73CDLEVENINGDOJISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_72CDLEVENINGDOJISTAR[] = " CDLEVENINGDOJISTAR(open, high, low, close[, penetration=?])\n\n    Evening Doji Star (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.3\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_73CDLEVENINGDOJISTAR = {__Pyx_NAMESTR("CDLEVENINGDOJISTAR"), (PyCFunction)__pyx_pw_5talib_4func_73CDLEVENINGDOJISTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_72CDLEVENINGDOJISTAR)};
static PyObject *__pyx_pw_5talib_4func_73CDLEVENINGDOJISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLEVENINGDOJISTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLEVENINGDOJISTAR", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLEVENINGDOJISTAR", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLEVENINGDOJISTAR", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLEVENINGDOJISTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":2434
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLEVENINGDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLEVENINGDOJISTAR(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.3);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLEVENINGDOJISTAR", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLEVENINGDOJISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_72CDLEVENINGDOJISTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_72CDLEVENINGDOJISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLEVENINGDOJISTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2457
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2458
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2459
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2460
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2460; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2460; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2461
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2462
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2463
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2464
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2465
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2466
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2467
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2468
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2468; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2469
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2470
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2471
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2472
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2473
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2473; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2474
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2475
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2476
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2477
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2478
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2479
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2480
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2481
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2482
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2484
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGDOJISTAR_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_58), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2485
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLEVENINGDOJISTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2486
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGDOJISTAR_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLEVENINGDOJISTAR_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":2487
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGDOJISTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2487; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2488
 *     lookback = begidx + TA_CDLEVENINGDOJISTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2489
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLEVENINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2490
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLEVENINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLEVENINGDOJISTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2491
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLEVENINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLEVENINGDOJISTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLEVENINGDOJISTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2492
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLEVENINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLEVENINGDOJISTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_59, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2493
 *     retCode = TA_CDLEVENINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLEVENINGDOJISTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLEVENINGDOJISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_75CDLEVENINGSTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_74CDLEVENINGSTAR[] = " CDLEVENINGSTAR(open, high, low, close[, penetration=?])\n\n    Evening Star (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.3\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_75CDLEVENINGSTAR = {__Pyx_NAMESTR("CDLEVENINGSTAR"), (PyCFunction)__pyx_pw_5talib_4func_75CDLEVENINGSTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_74CDLEVENINGSTAR)};
static PyObject *__pyx_pw_5talib_4func_75CDLEVENINGSTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLEVENINGSTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLEVENINGSTAR", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLEVENINGSTAR", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLEVENINGSTAR", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLEVENINGSTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":2497
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLEVENINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLEVENINGSTAR(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.3);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLEVENINGSTAR", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLEVENINGSTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_74CDLEVENINGSTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_74CDLEVENINGSTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLEVENINGSTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2520
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2520; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2521
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2522
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2523
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2524
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2525
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2526
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2527
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2528
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2529
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2530
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2531
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2532
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2533
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2534
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2535
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2536
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2537
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2538
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2539
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2540
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2541
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2542
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2543
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2544
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2545
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2547
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGSTAR_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_60), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2548
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLEVENINGSTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2549
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGSTAR_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLEVENINGSTAR_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":2550
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGSTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2551
 *     lookback = begidx + TA_CDLEVENINGSTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2552
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLEVENINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2553
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLEVENINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLEVENINGSTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2554
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLEVENINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLEVENINGSTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLEVENINGSTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2555
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLEVENINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLEVENINGSTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLEVENINGSTAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2555; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2556
 *     retCode = TA_CDLEVENINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLEVENINGSTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLEVENINGSTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_77CDLGAPSIDESIDEWHITE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_76CDLGAPSIDESIDEWHITE[] = " CDLGAPSIDESIDEWHITE(open, high, low, close)\n\n    Up/Down-gap side-by-side white lines (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_77CDLGAPSIDESIDEWHITE = {__Pyx_NAMESTR("CDLGAPSIDESIDEWHITE"), (PyCFunction)__pyx_pw_5talib_4func_77CDLGAPSIDESIDEWHITE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_76CDLGAPSIDESIDEWHITE)};
static PyObject *__pyx_pw_5talib_4func_77CDLGAPSIDESIDEWHITE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLGAPSIDESIDEWHITE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLGAPSIDESIDEWHITE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLGAPSIDESIDEWHITE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLGAPSIDESIDEWHITE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLGAPSIDESIDEWHITE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLGAPSIDESIDEWHITE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLGAPSIDESIDEWHITE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_76CDLGAPSIDESIDEWHITE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2560
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLGAPSIDESIDEWHITE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLGAPSIDESIDEWHITE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_76CDLGAPSIDESIDEWHITE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLGAPSIDESIDEWHITE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2581
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2582
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2582; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2583
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2584
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2585
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2586
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2586; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2587
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2588
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2589
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2589; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2589; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2590
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2591
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2592
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2593
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2594
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2595
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2596
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2597
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2598
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2599
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2599; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2599; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2600
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2601
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2602
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2603
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2604
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2605
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2606
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2608
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGAPSIDESIDEWHITE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_61), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2609
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLGAPSIDESIDEWHITE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2610
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGAPSIDESIDEWHITE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLGAPSIDESIDEWHITE_Lookback());

  /* "talib/func.pyx":2611
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGAPSIDESIDEWHITE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2612
 *     lookback = begidx + TA_CDLGAPSIDESIDEWHITE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2613
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLGAPSIDESIDEWHITE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2614
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLGAPSIDESIDEWHITE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLGAPSIDESIDEWHITE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2615
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLGAPSIDESIDEWHITE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLGAPSIDESIDEWHITE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLGAPSIDESIDEWHITE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2616
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLGAPSIDESIDEWHITE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLGAPSIDESIDEWHITE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_62, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2617
 *     retCode = TA_CDLGAPSIDESIDEWHITE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLGAPSIDESIDEWHITE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLGAPSIDESIDEWHITE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_79CDLGRAVESTONEDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_78CDLGRAVESTONEDOJI[] = " CDLGRAVESTONEDOJI(open, high, low, close)\n\n    Gravestone Doji (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_79CDLGRAVESTONEDOJI = {__Pyx_NAMESTR("CDLGRAVESTONEDOJI"), (PyCFunction)__pyx_pw_5talib_4func_79CDLGRAVESTONEDOJI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_78CDLGRAVESTONEDOJI)};
static PyObject *__pyx_pw_5talib_4func_79CDLGRAVESTONEDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLGRAVESTONEDOJI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLGRAVESTONEDOJI", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLGRAVESTONEDOJI", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLGRAVESTONEDOJI", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLGRAVESTONEDOJI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLGRAVESTONEDOJI", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLGRAVESTONEDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_78CDLGRAVESTONEDOJI(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2621
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLGRAVESTONEDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLGRAVESTONEDOJI(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_78CDLGRAVESTONEDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLGRAVESTONEDOJI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2642
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2643
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2644
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2645
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2646
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2647
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2648
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2648; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2649
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2650
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2651
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2652
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2653
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2654
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2655
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2655; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2655; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2656
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2657
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2658
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2659
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2660
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2661
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2662
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2663
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2664
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2665
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2666
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2667
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2669
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGRAVESTONEDOJI_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_63), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2670
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLGRAVESTONEDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2671
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGRAVESTONEDOJI_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLGRAVESTONEDOJI_Lookback());

  /* "talib/func.pyx":2672
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGRAVESTONEDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2672; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2672; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2673
 *     lookback = begidx + TA_CDLGRAVESTONEDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2674
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLGRAVESTONEDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2675
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLGRAVESTONEDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLGRAVESTONEDOJI", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2676
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLGRAVESTONEDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLGRAVESTONEDOJI", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLGRAVESTONEDOJI(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2677
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLGRAVESTONEDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLGRAVESTONEDOJI", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_64, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2677; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2678
 *     retCode = TA_CDLGRAVESTONEDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLGRAVESTONEDOJI", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLGRAVESTONEDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_81CDLHAMMER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_80CDLHAMMER[] = " CDLHAMMER(open, high, low, close)\n\n    Hammer (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_81CDLHAMMER = {__Pyx_NAMESTR("CDLHAMMER"), (PyCFunction)__pyx_pw_5talib_4func_81CDLHAMMER, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_80CDLHAMMER)};
static PyObject *__pyx_pw_5talib_4func_81CDLHAMMER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHAMMER (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHAMMER", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHAMMER", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHAMMER", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHAMMER") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHAMMER", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHAMMER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_80CDLHAMMER(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2682
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHAMMER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHAMMER(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_80CDLHAMMER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHAMMER", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2703
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2703; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2704
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2705
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2706
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2707
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2708
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2709
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2710
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2711
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2712
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2713
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2714
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2715
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2716
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2717
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2718
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2719
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2720
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2721
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2721; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2721; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2722
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2723
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2724
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2725
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2726
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2727
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2728
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2730
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHAMMER_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_65), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2731
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHAMMER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2732
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHAMMER_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHAMMER_Lookback());

  /* "talib/func.pyx":2733
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHAMMER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2734
 *     lookback = begidx + TA_CDLHAMMER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2735
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2736
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHAMMER", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2737
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHAMMER", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHAMMER(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2738
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHAMMER", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHAMMER, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2739
 *     retCode = TA_CDLHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHAMMER", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHAMMER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_83CDLHANGINGMAN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_82CDLHANGINGMAN[] = " CDLHANGINGMAN(open, high, low, close)\n\n    Hanging Man (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_83CDLHANGINGMAN = {__Pyx_NAMESTR("CDLHANGINGMAN"), (PyCFunction)__pyx_pw_5talib_4func_83CDLHANGINGMAN, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_82CDLHANGINGMAN)};
static PyObject *__pyx_pw_5talib_4func_83CDLHANGINGMAN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHANGINGMAN (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHANGINGMAN", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHANGINGMAN", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHANGINGMAN", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHANGINGMAN") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHANGINGMAN", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHANGINGMAN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_82CDLHANGINGMAN(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2743
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHANGINGMAN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHANGINGMAN(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_82CDLHANGINGMAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHANGINGMAN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2764
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2764; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2765
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2766
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2767
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2768
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2769
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2770
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2771
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2772
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2772; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2772; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2773
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2774
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2775
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2776
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2777
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2778
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2779
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2779; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2780
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2781
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2782
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2783
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2784
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2785
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2786
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2787
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2788
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2789
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2791
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHANGINGMAN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_66), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2792
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHANGINGMAN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2793
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHANGINGMAN_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHANGINGMAN_Lookback());

  /* "talib/func.pyx":2794
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHANGINGMAN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2795
 *     lookback = begidx + TA_CDLHANGINGMAN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2796
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHANGINGMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2797
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHANGINGMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHANGINGMAN", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2798
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHANGINGMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHANGINGMAN", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHANGINGMAN(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2799
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHANGINGMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHANGINGMAN", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHANGINGMAN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2800
 *     retCode = TA_CDLHANGINGMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHANGINGMAN", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHANGINGMAN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_85CDLHARAMI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_84CDLHARAMI[] = " CDLHARAMI(open, high, low, close)\n\n    Harami Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_85CDLHARAMI = {__Pyx_NAMESTR("CDLHARAMI"), (PyCFunction)__pyx_pw_5talib_4func_85CDLHARAMI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_84CDLHARAMI)};
static PyObject *__pyx_pw_5talib_4func_85CDLHARAMI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHARAMI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHARAMI", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHARAMI", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHARAMI", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHARAMI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHARAMI", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHARAMI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_84CDLHARAMI(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2804
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHARAMI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHARAMI(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_84CDLHARAMI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHARAMI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2825
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2825; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2826
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2827
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2828
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2829
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2830
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2831
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2832
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2833
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2834
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2835
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2836
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2837
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2838
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2839
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2840
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2841
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2842
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2843
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2844
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2845
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2846
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2847
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2848
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2849
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2850
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2852
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMI_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_67), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2853
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHARAMI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2854
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMI_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHARAMI_Lookback());

  /* "talib/func.pyx":2855
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2855; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2855; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2856
 *     lookback = begidx + TA_CDLHARAMI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2857
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHARAMI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2858
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHARAMI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHARAMI", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2859
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHARAMI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHARAMI", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHARAMI(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2860
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHARAMI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHARAMI", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHARAMI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2860; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2861
 *     retCode = TA_CDLHARAMI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHARAMI", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHARAMI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_87CDLHARAMICROSS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_86CDLHARAMICROSS[] = " CDLHARAMICROSS(open, high, low, close)\n\n    Harami Cross Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_87CDLHARAMICROSS = {__Pyx_NAMESTR("CDLHARAMICROSS"), (PyCFunction)__pyx_pw_5talib_4func_87CDLHARAMICROSS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_86CDLHARAMICROSS)};
static PyObject *__pyx_pw_5talib_4func_87CDLHARAMICROSS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHARAMICROSS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHARAMICROSS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHARAMICROSS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHARAMICROSS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHARAMICROSS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHARAMICROSS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHARAMICROSS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_86CDLHARAMICROSS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2865
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHARAMICROSS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHARAMICROSS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_86CDLHARAMICROSS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHARAMICROSS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2886
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2886; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2887
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2887; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2888
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2889
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2889; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2889; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2890
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2891
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2891; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2892
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2892; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2893
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2894
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2894; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2894; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2895
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2896
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2897
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2898
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2899
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2900
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2901
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2902
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2902; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2903
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2904
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2904; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2904; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2905
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2906
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2907
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2908
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2909
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2910
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2911
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2913
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMICROSS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_68), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2914
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHARAMICROSS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2915
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMICROSS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHARAMICROSS_Lookback());

  /* "talib/func.pyx":2916
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMICROSS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2916; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2916; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2917
 *     lookback = begidx + TA_CDLHARAMICROSS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2918
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHARAMICROSS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2919
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHARAMICROSS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHARAMICROSS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2920
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHARAMICROSS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHARAMICROSS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHARAMICROSS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2921
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHARAMICROSS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHARAMICROSS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHARAMICROSS, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2922
 *     retCode = TA_CDLHARAMICROSS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHARAMICROSS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHARAMICROSS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_89CDLHIGHWAVE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_88CDLHIGHWAVE[] = " CDLHIGHWAVE(open, high, low, close)\n\n    High-Wave Candle (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_89CDLHIGHWAVE = {__Pyx_NAMESTR("CDLHIGHWAVE"), (PyCFunction)__pyx_pw_5talib_4func_89CDLHIGHWAVE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_88CDLHIGHWAVE)};
static PyObject *__pyx_pw_5talib_4func_89CDLHIGHWAVE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHIGHWAVE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIGHWAVE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIGHWAVE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIGHWAVE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHIGHWAVE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHIGHWAVE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHIGHWAVE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_88CDLHIGHWAVE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2926
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIGHWAVE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIGHWAVE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_88CDLHIGHWAVE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHIGHWAVE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":2947
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2948
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2948; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2949
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2950
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2950; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2950; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":2951
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":2952
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2953
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2953; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2954
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2955
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":2956
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":2957
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2958
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2958; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2959
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2960
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":2961
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":2962
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2962; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2963
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2963; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":2964
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":2965
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":2966
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":2967
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":2968
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":2969
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":2970
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":2971
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":2972
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":2974
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIGHWAVE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_69), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":2975
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHIGHWAVE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":2976
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIGHWAVE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHIGHWAVE_Lookback());

  /* "talib/func.pyx":2977
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIGHWAVE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":2978
 *     lookback = begidx + TA_CDLHIGHWAVE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":2979
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIGHWAVE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":2980
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHIGHWAVE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIGHWAVE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":2981
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIGHWAVE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHIGHWAVE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHIGHWAVE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":2982
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIGHWAVE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIGHWAVE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHIGHWAVE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":2983
 *     retCode = TA_CDLHIGHWAVE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIGHWAVE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHIGHWAVE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_91CDLHIKKAKE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_90CDLHIKKAKE[] = " CDLHIKKAKE(open, high, low, close)\n\n    Hikkake Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_91CDLHIKKAKE = {__Pyx_NAMESTR("CDLHIKKAKE"), (PyCFunction)__pyx_pw_5talib_4func_91CDLHIKKAKE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_90CDLHIKKAKE)};
static PyObject *__pyx_pw_5talib_4func_91CDLHIKKAKE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHIKKAKE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIKKAKE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIKKAKE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIKKAKE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHIKKAKE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHIKKAKE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHIKKAKE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_90CDLHIKKAKE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":2987
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIKKAKE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIKKAKE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_90CDLHIKKAKE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHIKKAKE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3008
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3008; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3009
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3009; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3010
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3011
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3012
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3013
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3013; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3014
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3014; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3015
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3016
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3017
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3018
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3018; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3019
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3019; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3020
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3021
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3021; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3021; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3022
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3023
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3023; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3024
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3024; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3025
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3026
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3027
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3028
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3029
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3030
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3031
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3032
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3033
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3035
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_70), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3036
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHIKKAKE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3037
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHIKKAKE_Lookback());

  /* "talib/func.pyx":3038
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3038; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3038; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3039
 *     lookback = begidx + TA_CDLHIKKAKE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3040
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIKKAKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3041
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHIKKAKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIKKAKE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3042
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIKKAKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHIKKAKE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHIKKAKE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3043
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIKKAKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIKKAKE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHIKKAKE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3043; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3044
 *     retCode = TA_CDLHIKKAKE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIKKAKE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHIKKAKE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_93CDLHIKKAKEMOD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_92CDLHIKKAKEMOD[] = " CDLHIKKAKEMOD(open, high, low, close)\n\n    Modified Hikkake Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_93CDLHIKKAKEMOD = {__Pyx_NAMESTR("CDLHIKKAKEMOD"), (PyCFunction)__pyx_pw_5talib_4func_93CDLHIKKAKEMOD, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_92CDLHIKKAKEMOD)};
static PyObject *__pyx_pw_5talib_4func_93CDLHIKKAKEMOD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHIKKAKEMOD (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIKKAKEMOD", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIKKAKEMOD", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHIKKAKEMOD", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHIKKAKEMOD") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHIKKAKEMOD", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHIKKAKEMOD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_92CDLHIKKAKEMOD(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3048
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIKKAKEMOD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIKKAKEMOD(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_92CDLHIKKAKEMOD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHIKKAKEMOD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3069
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3070
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3071
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3072
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3072; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3072; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3073
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3074
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3074; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3075
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3075; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3076
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3077
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3077; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3077; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3078
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3079
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3079; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3080
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3081
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3082
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3082; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3082; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3083
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3084
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3084; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3085
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3085; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3086
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3087
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3087; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3087; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3088
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3089
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3090
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3091
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3092
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3093
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3094
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3096
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKEMOD_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_71), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3096; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3096; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3097
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHIKKAKEMOD_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3098
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKEMOD_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHIKKAKEMOD_Lookback());

  /* "talib/func.pyx":3099
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKEMOD_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3099; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3099; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3100
 *     lookback = begidx + TA_CDLHIKKAKEMOD_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3101
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIKKAKEMOD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3102
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHIKKAKEMOD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIKKAKEMOD", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3103
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIKKAKEMOD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHIKKAKEMOD", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHIKKAKEMOD(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3104
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHIKKAKEMOD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIKKAKEMOD", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHIKKAKEMOD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3105
 *     retCode = TA_CDLHIKKAKEMOD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHIKKAKEMOD", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHIKKAKEMOD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_95CDLHOMINGPIGEON(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_94CDLHOMINGPIGEON[] = " CDLHOMINGPIGEON(open, high, low, close)\n\n    Homing Pigeon (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_95CDLHOMINGPIGEON = {__Pyx_NAMESTR("CDLHOMINGPIGEON"), (PyCFunction)__pyx_pw_5talib_4func_95CDLHOMINGPIGEON, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_94CDLHOMINGPIGEON)};
static PyObject *__pyx_pw_5talib_4func_95CDLHOMINGPIGEON(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLHOMINGPIGEON (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHOMINGPIGEON", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHOMINGPIGEON", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLHOMINGPIGEON", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLHOMINGPIGEON") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLHOMINGPIGEON", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLHOMINGPIGEON", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_94CDLHOMINGPIGEON(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3109
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHOMINGPIGEON( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHOMINGPIGEON(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_94CDLHOMINGPIGEON(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLHOMINGPIGEON", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3130
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3131
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3132
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3133
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3134
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3135
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3136
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3137
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3138
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3139
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3140
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3141
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3142
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3143
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3144
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3145
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3145; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3146
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3147
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3148
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3149
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3150
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3151
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3152
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3153
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3154
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3155
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3157
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHOMINGPIGEON_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_72), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3158
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLHOMINGPIGEON_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3159
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHOMINGPIGEON_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLHOMINGPIGEON_Lookback());

  /* "talib/func.pyx":3160
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHOMINGPIGEON_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3161
 *     lookback = begidx + TA_CDLHOMINGPIGEON_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3162
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHOMINGPIGEON( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3163
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLHOMINGPIGEON( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHOMINGPIGEON", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3164
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHOMINGPIGEON( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLHOMINGPIGEON", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLHOMINGPIGEON(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3165
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLHOMINGPIGEON( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHOMINGPIGEON", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLHOMINGPIGEON, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3166
 *     retCode = TA_CDLHOMINGPIGEON( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLHOMINGPIGEON", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLHOMINGPIGEON", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_97CDLIDENTICAL3CROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_96CDLIDENTICAL3CROWS[] = " CDLIDENTICAL3CROWS(open, high, low, close)\n\n    Identical Three Crows (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_97CDLIDENTICAL3CROWS = {__Pyx_NAMESTR("CDLIDENTICAL3CROWS"), (PyCFunction)__pyx_pw_5talib_4func_97CDLIDENTICAL3CROWS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_96CDLIDENTICAL3CROWS)};
static PyObject *__pyx_pw_5talib_4func_97CDLIDENTICAL3CROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLIDENTICAL3CROWS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLIDENTICAL3CROWS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLIDENTICAL3CROWS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLIDENTICAL3CROWS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLIDENTICAL3CROWS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLIDENTICAL3CROWS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLIDENTICAL3CROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_96CDLIDENTICAL3CROWS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3170
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLIDENTICAL3CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLIDENTICAL3CROWS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_96CDLIDENTICAL3CROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLIDENTICAL3CROWS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3191
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3192
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3193
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3194
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3195
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3196
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3196; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3197
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3198
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3199
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3200
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3201
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3202
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3203
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3204
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3204; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3205
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3206
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3207
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3208
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3209
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3210
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3211
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3212
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3213
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3214
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3215
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3216
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3218
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLIDENTICAL3CROWS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_73), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3219
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLIDENTICAL3CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3220
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLIDENTICAL3CROWS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLIDENTICAL3CROWS_Lookback());

  /* "talib/func.pyx":3221
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLIDENTICAL3CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3222
 *     lookback = begidx + TA_CDLIDENTICAL3CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3223
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLIDENTICAL3CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3224
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLIDENTICAL3CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLIDENTICAL3CROWS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3225
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLIDENTICAL3CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLIDENTICAL3CROWS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLIDENTICAL3CROWS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3226
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLIDENTICAL3CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLIDENTICAL3CROWS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_74, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3227
 *     retCode = TA_CDLIDENTICAL3CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLIDENTICAL3CROWS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLIDENTICAL3CROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_99CDLINNECK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_98CDLINNECK[] = " CDLINNECK(open, high, low, close)\n\n    In-Neck Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_99CDLINNECK = {__Pyx_NAMESTR("CDLINNECK"), (PyCFunction)__pyx_pw_5talib_4func_99CDLINNECK, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_98CDLINNECK)};
static PyObject *__pyx_pw_5talib_4func_99CDLINNECK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLINNECK (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLINNECK", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLINNECK", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLINNECK", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLINNECK") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLINNECK", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLINNECK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_98CDLINNECK(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3231
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLINNECK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLINNECK(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_98CDLINNECK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLINNECK", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3252
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3253
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3254
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3255
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3256
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3257
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3258
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3259
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3260
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3261
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3262
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3263
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3263; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3264
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3265
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3266
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3267
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3268
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3269
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3270
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3271
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3272
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3273
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3274
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3275
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3276
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3277
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3279
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINNECK_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_75), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3280
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLINNECK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3281
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINNECK_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLINNECK_Lookback());

  /* "talib/func.pyx":3282
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINNECK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3282; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3282; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3283
 *     lookback = begidx + TA_CDLINNECK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3284
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLINNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3285
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLINNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLINNECK", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3286
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLINNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLINNECK", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLINNECK(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3287
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLINNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLINNECK", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLINNECK, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3288
 *     retCode = TA_CDLINNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLINNECK", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLINNECK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_101CDLINVERTEDHAMMER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_100CDLINVERTEDHAMMER[] = " CDLINVERTEDHAMMER(open, high, low, close)\n\n    Inverted Hammer (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_101CDLINVERTEDHAMMER = {__Pyx_NAMESTR("CDLINVERTEDHAMMER"), (PyCFunction)__pyx_pw_5talib_4func_101CDLINVERTEDHAMMER, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_100CDLINVERTEDHAMMER)};
static PyObject *__pyx_pw_5talib_4func_101CDLINVERTEDHAMMER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLINVERTEDHAMMER (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLINVERTEDHAMMER", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLINVERTEDHAMMER", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLINVERTEDHAMMER", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLINVERTEDHAMMER") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLINVERTEDHAMMER", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLINVERTEDHAMMER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_100CDLINVERTEDHAMMER(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3292
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLINVERTEDHAMMER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLINVERTEDHAMMER(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_100CDLINVERTEDHAMMER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLINVERTEDHAMMER", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3313
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3314
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3315
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3316
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3317
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3318
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3319
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3320
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3321
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3322
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3323
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3324
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3325
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3326
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3327
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3328
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3329
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3330
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3331
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3332
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3333
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3334
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3335
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3336
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3337
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3338
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3340
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINVERTEDHAMMER_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_76), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3341
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLINVERTEDHAMMER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3342
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINVERTEDHAMMER_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLINVERTEDHAMMER_Lookback());

  /* "talib/func.pyx":3343
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINVERTEDHAMMER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3344
 *     lookback = begidx + TA_CDLINVERTEDHAMMER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3345
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLINVERTEDHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3346
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLINVERTEDHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLINVERTEDHAMMER", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3347
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLINVERTEDHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLINVERTEDHAMMER", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLINVERTEDHAMMER(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3348
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLINVERTEDHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLINVERTEDHAMMER", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_77, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3349
 *     retCode = TA_CDLINVERTEDHAMMER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLINVERTEDHAMMER", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLINVERTEDHAMMER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_103CDLKICKING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_102CDLKICKING[] = " CDLKICKING(open, high, low, close)\n\n    Kicking (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_103CDLKICKING = {__Pyx_NAMESTR("CDLKICKING"), (PyCFunction)__pyx_pw_5talib_4func_103CDLKICKING, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_102CDLKICKING)};
static PyObject *__pyx_pw_5talib_4func_103CDLKICKING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLKICKING (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLKICKING", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLKICKING", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLKICKING", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLKICKING") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLKICKING", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLKICKING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_102CDLKICKING(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3353
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLKICKING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLKICKING(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_102CDLKICKING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLKICKING", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3374
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3375
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3376
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3377
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3378
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3379
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3380
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3381
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3382
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3383
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3384
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3385
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3385; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3386
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3387
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3388
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3389
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3389; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3390
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3391
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3392
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3393
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3394
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3395
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3396
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3397
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3398
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3399
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3401
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKING_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_78), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3402
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLKICKING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3403
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKING_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLKICKING_Lookback());

  /* "talib/func.pyx":3404
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3404; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3404; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3405
 *     lookback = begidx + TA_CDLKICKING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3406
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLKICKING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3407
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLKICKING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLKICKING", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3408
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLKICKING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLKICKING", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLKICKING(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3409
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLKICKING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLKICKING", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLKICKING, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3410
 *     retCode = TA_CDLKICKING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLKICKING", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLKICKING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_105CDLKICKINGBYLENGTH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_104CDLKICKINGBYLENGTH[] = " CDLKICKINGBYLENGTH(open, high, low, close)\n\n    Kicking - bull/bear determined by the longer marubozu (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_105CDLKICKINGBYLENGTH = {__Pyx_NAMESTR("CDLKICKINGBYLENGTH"), (PyCFunction)__pyx_pw_5talib_4func_105CDLKICKINGBYLENGTH, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_104CDLKICKINGBYLENGTH)};
static PyObject *__pyx_pw_5talib_4func_105CDLKICKINGBYLENGTH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLKICKINGBYLENGTH (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLKICKINGBYLENGTH", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLKICKINGBYLENGTH", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLKICKINGBYLENGTH", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLKICKINGBYLENGTH") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLKICKINGBYLENGTH", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLKICKINGBYLENGTH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_104CDLKICKINGBYLENGTH(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3414
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLKICKINGBYLENGTH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLKICKINGBYLENGTH(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_104CDLKICKINGBYLENGTH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLKICKINGBYLENGTH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3435
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3436
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3437
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3438
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3439
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3440
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3440; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3441
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3442
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3443
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3443; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3444
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3445
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3446
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3446; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3447
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3448
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3449
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3450
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3451
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3452
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3453
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3454
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3455
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3456
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3457
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3458
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3459
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3460
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3462
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKINGBYLENGTH_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_79), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3463
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLKICKINGBYLENGTH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3464
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKINGBYLENGTH_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLKICKINGBYLENGTH_Lookback());

  /* "talib/func.pyx":3465
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKINGBYLENGTH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3465; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3466
 *     lookback = begidx + TA_CDLKICKINGBYLENGTH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3467
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLKICKINGBYLENGTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3468
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLKICKINGBYLENGTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLKICKINGBYLENGTH", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3469
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLKICKINGBYLENGTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLKICKINGBYLENGTH", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLKICKINGBYLENGTH(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3470
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLKICKINGBYLENGTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLKICKINGBYLENGTH", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_80, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3471
 *     retCode = TA_CDLKICKINGBYLENGTH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLKICKINGBYLENGTH", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLKICKINGBYLENGTH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_107CDLLADDERBOTTOM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_106CDLLADDERBOTTOM[] = " CDLLADDERBOTTOM(open, high, low, close)\n\n    Ladder Bottom (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_107CDLLADDERBOTTOM = {__Pyx_NAMESTR("CDLLADDERBOTTOM"), (PyCFunction)__pyx_pw_5talib_4func_107CDLLADDERBOTTOM, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_106CDLLADDERBOTTOM)};
static PyObject *__pyx_pw_5talib_4func_107CDLLADDERBOTTOM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLLADDERBOTTOM (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLADDERBOTTOM", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLADDERBOTTOM", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLADDERBOTTOM", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLLADDERBOTTOM") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLLADDERBOTTOM", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLLADDERBOTTOM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_106CDLLADDERBOTTOM(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3475
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLADDERBOTTOM( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLADDERBOTTOM(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_106CDLLADDERBOTTOM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLLADDERBOTTOM", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3496
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3497
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3498
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3499
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3500
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3501
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3502
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3503
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3504
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3505
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3506
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3507
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3507; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3508
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3509
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3510
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3511
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3512
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3513
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3514
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3515
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3516
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3517
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3518
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3519
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3520
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3521
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3523
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLADDERBOTTOM_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_81), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3524
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLLADDERBOTTOM_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3525
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLADDERBOTTOM_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLLADDERBOTTOM_Lookback());

  /* "talib/func.pyx":3526
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLADDERBOTTOM_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3526; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3527
 *     lookback = begidx + TA_CDLLADDERBOTTOM_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3528
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLADDERBOTTOM( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3529
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLLADDERBOTTOM( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLADDERBOTTOM", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3530
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLADDERBOTTOM( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLLADDERBOTTOM", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLLADDERBOTTOM(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3531
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLADDERBOTTOM( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLADDERBOTTOM", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLLADDERBOTTOM, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3532
 *     retCode = TA_CDLLADDERBOTTOM( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLADDERBOTTOM", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLLADDERBOTTOM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_109CDLLONGLEGGEDDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_108CDLLONGLEGGEDDOJI[] = " CDLLONGLEGGEDDOJI(open, high, low, close)\n\n    Long Legged Doji (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_109CDLLONGLEGGEDDOJI = {__Pyx_NAMESTR("CDLLONGLEGGEDDOJI"), (PyCFunction)__pyx_pw_5talib_4func_109CDLLONGLEGGEDDOJI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_108CDLLONGLEGGEDDOJI)};
static PyObject *__pyx_pw_5talib_4func_109CDLLONGLEGGEDDOJI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLLONGLEGGEDDOJI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLONGLEGGEDDOJI", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLONGLEGGEDDOJI", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLONGLEGGEDDOJI", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLLONGLEGGEDDOJI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLLONGLEGGEDDOJI", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLLONGLEGGEDDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_108CDLLONGLEGGEDDOJI(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3536
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLONGLEGGEDDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLONGLEGGEDDOJI(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_108CDLLONGLEGGEDDOJI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLLONGLEGGEDDOJI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3557
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3558
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3559
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3560
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3561
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3562
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3562; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3563
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3564
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3565
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3566
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3567
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3568
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3569
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3570
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3570; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3571
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3572
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3573
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3574
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3575
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3576
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3577
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3578
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3579
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3580
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3581
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3582
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3584
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLEGGEDDOJI_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_82), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3585
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLLONGLEGGEDDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3586
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLEGGEDDOJI_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLLONGLEGGEDDOJI_Lookback());

  /* "talib/func.pyx":3587
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLEGGEDDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3587; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3588
 *     lookback = begidx + TA_CDLLONGLEGGEDDOJI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3589
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLONGLEGGEDDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3590
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLLONGLEGGEDDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLONGLEGGEDDOJI", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3591
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLONGLEGGEDDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLLONGLEGGEDDOJI", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLLONGLEGGEDDOJI(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3592
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLONGLEGGEDDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLONGLEGGEDDOJI", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_83, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3593
 *     retCode = TA_CDLLONGLEGGEDDOJI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLONGLEGGEDDOJI", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLLONGLEGGEDDOJI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_111CDLLONGLINE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_110CDLLONGLINE[] = " CDLLONGLINE(open, high, low, close)\n\n    Long Line Candle (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_111CDLLONGLINE = {__Pyx_NAMESTR("CDLLONGLINE"), (PyCFunction)__pyx_pw_5talib_4func_111CDLLONGLINE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_110CDLLONGLINE)};
static PyObject *__pyx_pw_5talib_4func_111CDLLONGLINE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLLONGLINE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLONGLINE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLONGLINE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLLONGLINE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLLONGLINE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLLONGLINE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLLONGLINE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_110CDLLONGLINE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3597
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLONGLINE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLONGLINE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_110CDLLONGLINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLLONGLINE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3618
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3619
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3619; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3620
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3621
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3622
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3623
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3624
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3625
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3626
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3627
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3628
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3629
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3629; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3630
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3631
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3632
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3633
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3634
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3635
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3636
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3636; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3636; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3637
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3638
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3639
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3640
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3641
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3642
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3643
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3645
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLINE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_84), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3646
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLLONGLINE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3647
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLINE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLLONGLINE_Lookback());

  /* "talib/func.pyx":3648
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLINE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3648; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3648; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3649
 *     lookback = begidx + TA_CDLLONGLINE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3650
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLONGLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3651
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLLONGLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLONGLINE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3652
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLONGLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLLONGLINE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLLONGLINE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3653
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLLONGLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLONGLINE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLLONGLINE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3654
 *     retCode = TA_CDLLONGLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLLONGLINE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLLONGLINE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_113CDLMARUBOZU(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_112CDLMARUBOZU[] = " CDLMARUBOZU(open, high, low, close)\n\n    Marubozu (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_113CDLMARUBOZU = {__Pyx_NAMESTR("CDLMARUBOZU"), (PyCFunction)__pyx_pw_5talib_4func_113CDLMARUBOZU, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_112CDLMARUBOZU)};
static PyObject *__pyx_pw_5talib_4func_113CDLMARUBOZU(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLMARUBOZU (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMARUBOZU", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMARUBOZU", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMARUBOZU", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLMARUBOZU") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLMARUBOZU", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLMARUBOZU", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_112CDLMARUBOZU(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3658
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMARUBOZU( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLMARUBOZU(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_112CDLMARUBOZU(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLMARUBOZU", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3679
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3680
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3680; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3681
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3682
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3683
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3684
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3684; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3685
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3686
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3687
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3688
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3689
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3689; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3690
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3690; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3691
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3692
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3692; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3692; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3693
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3694
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3695
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3695; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3696
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3697
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3697; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3697; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3698
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3699
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3700
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3701
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3702
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3703
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3704
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3706
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMARUBOZU_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_85), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3707
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLMARUBOZU_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3708
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMARUBOZU_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLMARUBOZU_Lookback());

  /* "talib/func.pyx":3709
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMARUBOZU_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3710
 *     lookback = begidx + TA_CDLMARUBOZU_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3711
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3712
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMARUBOZU", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3713
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLMARUBOZU", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLMARUBOZU(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3714
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMARUBOZU", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLMARUBOZU, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3715
 *     retCode = TA_CDLMARUBOZU( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMARUBOZU", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLMARUBOZU", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_115CDLMATCHINGLOW(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_114CDLMATCHINGLOW[] = " CDLMATCHINGLOW(open, high, low, close)\n\n    Matching Low (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_115CDLMATCHINGLOW = {__Pyx_NAMESTR("CDLMATCHINGLOW"), (PyCFunction)__pyx_pw_5talib_4func_115CDLMATCHINGLOW, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_114CDLMATCHINGLOW)};
static PyObject *__pyx_pw_5talib_4func_115CDLMATCHINGLOW(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLMATCHINGLOW (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMATCHINGLOW", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMATCHINGLOW", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMATCHINGLOW", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLMATCHINGLOW") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLMATCHINGLOW", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLMATCHINGLOW", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_114CDLMATCHINGLOW(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3719
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMATCHINGLOW( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLMATCHINGLOW(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_114CDLMATCHINGLOW(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLMATCHINGLOW", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3740
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3740; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3741
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3742
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3743
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3744
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3745
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3746
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3746; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3747
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3748
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3749
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3750
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3750; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3751
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3752
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3753
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3754
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3755
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3755; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3756
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3757
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3758
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3759
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3760
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3761
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3762
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3763
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3764
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3765
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3767
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATCHINGLOW_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_86), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3768
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLMATCHINGLOW_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3769
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATCHINGLOW_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLMATCHINGLOW_Lookback());

  /* "talib/func.pyx":3770
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATCHINGLOW_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3771
 *     lookback = begidx + TA_CDLMATCHINGLOW_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3772
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMATCHINGLOW( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3773
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLMATCHINGLOW( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMATCHINGLOW", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3774
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMATCHINGLOW( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLMATCHINGLOW", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLMATCHINGLOW(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3775
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMATCHINGLOW( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMATCHINGLOW", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLMATCHINGLOW, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3776
 *     retCode = TA_CDLMATCHINGLOW( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMATCHINGLOW", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLMATCHINGLOW", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_117CDLMATHOLD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_116CDLMATHOLD[] = " CDLMATHOLD(open, high, low, close[, penetration=?])\n\n    Mat Hold (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.5\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_117CDLMATHOLD = {__Pyx_NAMESTR("CDLMATHOLD"), (PyCFunction)__pyx_pw_5talib_4func_117CDLMATHOLD, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_116CDLMATHOLD)};
static PyObject *__pyx_pw_5talib_4func_117CDLMATHOLD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLMATHOLD (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMATHOLD", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMATHOLD", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMATHOLD", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLMATHOLD") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":3780
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMATHOLD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.5 ):             # <<<<<<<<<<<<<<
 *     """ CDLMATHOLD(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.5);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLMATHOLD", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLMATHOLD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_116CDLMATHOLD(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_116CDLMATHOLD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLMATHOLD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3803
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3804
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3805
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3806
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3806; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3806; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3807
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3808
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3809
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3810
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3811
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3811; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3811; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3812
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3813
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3814
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3814; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3815
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3816
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3816; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3817
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3818
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3819
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3820
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3821
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3822
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3823
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3824
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3825
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3826
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3827
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3828
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3830
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATHOLD_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_87), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3831
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLMATHOLD_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3832
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATHOLD_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLMATHOLD_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":3833
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATHOLD_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3834
 *     lookback = begidx + TA_CDLMATHOLD_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3835
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMATHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3836
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLMATHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMATHOLD", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3837
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMATHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLMATHOLD", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLMATHOLD(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3838
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMATHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMATHOLD", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLMATHOLD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3839
 *     retCode = TA_CDLMATHOLD( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMATHOLD", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLMATHOLD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_119CDLMORNINGDOJISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_118CDLMORNINGDOJISTAR[] = " CDLMORNINGDOJISTAR(open, high, low, close[, penetration=?])\n\n    Morning Doji Star (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.3\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_119CDLMORNINGDOJISTAR = {__Pyx_NAMESTR("CDLMORNINGDOJISTAR"), (PyCFunction)__pyx_pw_5talib_4func_119CDLMORNINGDOJISTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_118CDLMORNINGDOJISTAR)};
static PyObject *__pyx_pw_5talib_4func_119CDLMORNINGDOJISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLMORNINGDOJISTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMORNINGDOJISTAR", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMORNINGDOJISTAR", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMORNINGDOJISTAR", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLMORNINGDOJISTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":3843
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMORNINGDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLMORNINGDOJISTAR(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.3);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLMORNINGDOJISTAR", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLMORNINGDOJISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_118CDLMORNINGDOJISTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_118CDLMORNINGDOJISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLMORNINGDOJISTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3866
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3866; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3867
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3867; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3868
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3869
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3869; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3869; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3870
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3871
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3872
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3873
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3874
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3874; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3874; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3875
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3876
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3877
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3878
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3879
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3879; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3879; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3880
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3881
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3881; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3882
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3882; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3883
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3884
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3885
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3886
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3887
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3888
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3889
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3890
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3891
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3893
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGDOJISTAR_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_88), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3893; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3893; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3894
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLMORNINGDOJISTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3895
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGDOJISTAR_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLMORNINGDOJISTAR_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":3896
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGDOJISTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3897
 *     lookback = begidx + TA_CDLMORNINGDOJISTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3898
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMORNINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3899
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLMORNINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMORNINGDOJISTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3900
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMORNINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLMORNINGDOJISTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLMORNINGDOJISTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3901
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMORNINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMORNINGDOJISTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_89, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3902
 *     retCode = TA_CDLMORNINGDOJISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMORNINGDOJISTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLMORNINGDOJISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_121CDLMORNINGSTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_120CDLMORNINGSTAR[] = " CDLMORNINGSTAR(open, high, low, close[, penetration=?])\n\n    Morning Star (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Parameters:\n        penetration: 0.3\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_121CDLMORNINGSTAR = {__Pyx_NAMESTR("CDLMORNINGSTAR"), (PyCFunction)__pyx_pw_5talib_4func_121CDLMORNINGSTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_120CDLMORNINGSTAR)};
static PyObject *__pyx_pw_5talib_4func_121CDLMORNINGSTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  double __pyx_v_penetration;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLMORNINGSTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__penetration,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMORNINGSTAR", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMORNINGSTAR", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLMORNINGSTAR", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__penetration);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLMORNINGSTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_penetration = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_penetration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":3906
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMORNINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLMORNINGSTAR(open, high, low, close[, penetration=?])
 * 
 */
      __pyx_v_penetration = ((double)0.3);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLMORNINGSTAR", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLMORNINGSTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_120CDLMORNINGSTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_penetration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_120CDLMORNINGSTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, double __pyx_v_penetration) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLMORNINGSTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3929
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3929; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3930
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3930; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3931
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3932
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3933
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3934
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3935
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3936
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3937
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3937; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3937; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3938
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":3939
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3939; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3940
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3940; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3941
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3942
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":3943
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":3944
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3945
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3946
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3947
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":3948
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":3949
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":3950
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":3951
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":3952
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":3953
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":3954
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":3956
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGSTAR_Lookback( penetration )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_90), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":3957
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLMORNINGSTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":3958
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGSTAR_Lookback( penetration )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLMORNINGSTAR_Lookback(__pyx_v_penetration));

  /* "talib/func.pyx":3959
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGSTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3959; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3959; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":3960
 *     lookback = begidx + TA_CDLMORNINGSTAR_Lookback( penetration )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":3961
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMORNINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":3962
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLMORNINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMORNINGSTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":3963
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMORNINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLMORNINGSTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLMORNINGSTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_penetration, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":3964
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLMORNINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMORNINGSTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLMORNINGSTAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3964; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":3965
 *     retCode = TA_CDLMORNINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , penetration , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLMORNINGSTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLMORNINGSTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_123CDLONNECK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_122CDLONNECK[] = " CDLONNECK(open, high, low, close)\n\n    On-Neck Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_123CDLONNECK = {__Pyx_NAMESTR("CDLONNECK"), (PyCFunction)__pyx_pw_5talib_4func_123CDLONNECK, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_122CDLONNECK)};
static PyObject *__pyx_pw_5talib_4func_123CDLONNECK(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLONNECK (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLONNECK", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLONNECK", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLONNECK", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLONNECK") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLONNECK", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLONNECK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_122CDLONNECK(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":3969
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLONNECK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLONNECK(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_122CDLONNECK(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLONNECK", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":3990
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3991
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3991; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3992
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3993
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3993; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3993; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":3994
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":3995
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3995; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3996
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3996; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":3997
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":3998
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3998; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3998; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":3999
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4000
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4000; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4001
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4001; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4002
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4003
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4004
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4005
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4006
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4007
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4008
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4008; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4008; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4009
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4010
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4011
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4012
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4013
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4014
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4015
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4017
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLONNECK_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_91), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4018
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLONNECK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4019
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLONNECK_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLONNECK_Lookback());

  /* "talib/func.pyx":4020
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLONNECK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4020; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4020; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4021
 *     lookback = begidx + TA_CDLONNECK_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4022
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLONNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4023
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLONNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLONNECK", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4024
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLONNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLONNECK", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLONNECK(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4025
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLONNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLONNECK", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLONNECK, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4026
 *     retCode = TA_CDLONNECK( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLONNECK", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLONNECK", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_125CDLPIERCING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_124CDLPIERCING[] = " CDLPIERCING(open, high, low, close)\n\n    Piercing Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_125CDLPIERCING = {__Pyx_NAMESTR("CDLPIERCING"), (PyCFunction)__pyx_pw_5talib_4func_125CDLPIERCING, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_124CDLPIERCING)};
static PyObject *__pyx_pw_5talib_4func_125CDLPIERCING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLPIERCING (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLPIERCING", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLPIERCING", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLPIERCING", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLPIERCING") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLPIERCING", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLPIERCING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_124CDLPIERCING(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4030
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLPIERCING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLPIERCING(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_124CDLPIERCING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLPIERCING", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4051
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4051; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4052
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4053
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4054
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4054; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4054; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4055
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4056
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4057
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4057; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4058
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4059
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4059; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4059; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4060
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4061
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4061; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4062
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4062; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4063
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4064
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4065
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4066
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4067
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4068
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4069
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4070
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4071
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4072
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4073
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4074
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4075
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4076
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4078
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLPIERCING_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_92), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4078; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4078; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4079
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLPIERCING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4080
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLPIERCING_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLPIERCING_Lookback());

  /* "talib/func.pyx":4081
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLPIERCING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4082
 *     lookback = begidx + TA_CDLPIERCING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4083
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLPIERCING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4084
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLPIERCING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLPIERCING", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4085
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLPIERCING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLPIERCING", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLPIERCING(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4086
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLPIERCING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLPIERCING", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLPIERCING, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4086; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4087
 *     retCode = TA_CDLPIERCING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLPIERCING", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLPIERCING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_127CDLRICKSHAWMAN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_126CDLRICKSHAWMAN[] = " CDLRICKSHAWMAN(open, high, low, close)\n\n    Rickshaw Man (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_127CDLRICKSHAWMAN = {__Pyx_NAMESTR("CDLRICKSHAWMAN"), (PyCFunction)__pyx_pw_5talib_4func_127CDLRICKSHAWMAN, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_126CDLRICKSHAWMAN)};
static PyObject *__pyx_pw_5talib_4func_127CDLRICKSHAWMAN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLRICKSHAWMAN (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLRICKSHAWMAN", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLRICKSHAWMAN", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLRICKSHAWMAN", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLRICKSHAWMAN") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLRICKSHAWMAN", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLRICKSHAWMAN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_126CDLRICKSHAWMAN(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4091
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLRICKSHAWMAN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLRICKSHAWMAN(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_126CDLRICKSHAWMAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLRICKSHAWMAN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4112
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4113
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4114
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4115
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4116
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4117
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4118
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4119
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4120
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4121
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4122
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4123
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4124
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4125
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4126
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4127
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4128
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4129
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4130
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4131
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4132
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4133
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4134
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4135
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4136
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4137
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4139
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRICKSHAWMAN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_93), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4140
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLRICKSHAWMAN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4141
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRICKSHAWMAN_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLRICKSHAWMAN_Lookback());

  /* "talib/func.pyx":4142
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRICKSHAWMAN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4142; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4142; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4143
 *     lookback = begidx + TA_CDLRICKSHAWMAN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4144
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLRICKSHAWMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4145
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLRICKSHAWMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLRICKSHAWMAN", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4146
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLRICKSHAWMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLRICKSHAWMAN", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLRICKSHAWMAN(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4147
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLRICKSHAWMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLRICKSHAWMAN", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLRICKSHAWMAN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4148
 *     retCode = TA_CDLRICKSHAWMAN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLRICKSHAWMAN", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLRICKSHAWMAN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_129CDLRISEFALL3METHODS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_128CDLRISEFALL3METHODS[] = " CDLRISEFALL3METHODS(open, high, low, close)\n\n    Rising/Falling Three Methods (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_129CDLRISEFALL3METHODS = {__Pyx_NAMESTR("CDLRISEFALL3METHODS"), (PyCFunction)__pyx_pw_5talib_4func_129CDLRISEFALL3METHODS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_128CDLRISEFALL3METHODS)};
static PyObject *__pyx_pw_5talib_4func_129CDLRISEFALL3METHODS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLRISEFALL3METHODS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLRISEFALL3METHODS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLRISEFALL3METHODS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLRISEFALL3METHODS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLRISEFALL3METHODS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLRISEFALL3METHODS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLRISEFALL3METHODS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_128CDLRISEFALL3METHODS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4152
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLRISEFALL3METHODS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLRISEFALL3METHODS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_128CDLRISEFALL3METHODS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLRISEFALL3METHODS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4173
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4174
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4175
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4176
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4177
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4178
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4179
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4180
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4181
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4182
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4183
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4183; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4184
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4185
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4186
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4187
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4188
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4188; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4189
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4190
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4191
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4192
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4193
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4194
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4195
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4196
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4197
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4198
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4200
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRISEFALL3METHODS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_94), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4201
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLRISEFALL3METHODS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4202
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRISEFALL3METHODS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLRISEFALL3METHODS_Lookback());

  /* "talib/func.pyx":4203
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRISEFALL3METHODS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4204
 *     lookback = begidx + TA_CDLRISEFALL3METHODS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4205
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLRISEFALL3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4206
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLRISEFALL3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLRISEFALL3METHODS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4207
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLRISEFALL3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLRISEFALL3METHODS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLRISEFALL3METHODS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4208
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLRISEFALL3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLRISEFALL3METHODS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_95, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4209
 *     retCode = TA_CDLRISEFALL3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLRISEFALL3METHODS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLRISEFALL3METHODS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_131CDLSEPARATINGLINES(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_130CDLSEPARATINGLINES[] = " CDLSEPARATINGLINES(open, high, low, close)\n\n    Separating Lines (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_131CDLSEPARATINGLINES = {__Pyx_NAMESTR("CDLSEPARATINGLINES"), (PyCFunction)__pyx_pw_5talib_4func_131CDLSEPARATINGLINES, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_130CDLSEPARATINGLINES)};
static PyObject *__pyx_pw_5talib_4func_131CDLSEPARATINGLINES(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLSEPARATINGLINES (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSEPARATINGLINES", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSEPARATINGLINES", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSEPARATINGLINES", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLSEPARATINGLINES") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLSEPARATINGLINES", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLSEPARATINGLINES", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_130CDLSEPARATINGLINES(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4213
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSEPARATINGLINES( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSEPARATINGLINES(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_130CDLSEPARATINGLINES(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLSEPARATINGLINES", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4234
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4234; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4235
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4235; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4236
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4237
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4238
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4239
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4240
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4240; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4241
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4242
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4242; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4243
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4244
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4245
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4246
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4247
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4247; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4248
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4249
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4249; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4250
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4251
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4252
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4253
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4254
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4255
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4256
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4257
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4258
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4259
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4261
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSEPARATINGLINES_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_96), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4262
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLSEPARATINGLINES_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4263
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSEPARATINGLINES_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLSEPARATINGLINES_Lookback());

  /* "talib/func.pyx":4264
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSEPARATINGLINES_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4265
 *     lookback = begidx + TA_CDLSEPARATINGLINES_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4266
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSEPARATINGLINES( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4267
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLSEPARATINGLINES( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSEPARATINGLINES", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4268
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSEPARATINGLINES( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLSEPARATINGLINES", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLSEPARATINGLINES(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4269
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSEPARATINGLINES( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSEPARATINGLINES", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_97, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4270
 *     retCode = TA_CDLSEPARATINGLINES( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSEPARATINGLINES", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLSEPARATINGLINES", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_133CDLSHOOTINGSTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_132CDLSHOOTINGSTAR[] = " CDLSHOOTINGSTAR(open, high, low, close)\n\n    Shooting Star (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_133CDLSHOOTINGSTAR = {__Pyx_NAMESTR("CDLSHOOTINGSTAR"), (PyCFunction)__pyx_pw_5talib_4func_133CDLSHOOTINGSTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_132CDLSHOOTINGSTAR)};
static PyObject *__pyx_pw_5talib_4func_133CDLSHOOTINGSTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLSHOOTINGSTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSHOOTINGSTAR", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSHOOTINGSTAR", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSHOOTINGSTAR", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLSHOOTINGSTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLSHOOTINGSTAR", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLSHOOTINGSTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_132CDLSHOOTINGSTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4274
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSHOOTINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSHOOTINGSTAR(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_132CDLSHOOTINGSTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLSHOOTINGSTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4295
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4296
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4297
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4298
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4299
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4300
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4301
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4302
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4303
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4304
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4305
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4306
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4307
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4308
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4309
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4310
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4311
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4312
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4313
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4314
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4315
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4316
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4317
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4318
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4319
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4320
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4322
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHOOTINGSTAR_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_98), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4323
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLSHOOTINGSTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4324
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHOOTINGSTAR_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLSHOOTINGSTAR_Lookback());

  /* "talib/func.pyx":4325
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHOOTINGSTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4326
 *     lookback = begidx + TA_CDLSHOOTINGSTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4327
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSHOOTINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4328
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLSHOOTINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSHOOTINGSTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4329
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSHOOTINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLSHOOTINGSTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLSHOOTINGSTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4330
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSHOOTINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSHOOTINGSTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLSHOOTINGSTAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4331
 *     retCode = TA_CDLSHOOTINGSTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSHOOTINGSTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLSHOOTINGSTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_135CDLSHORTLINE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_134CDLSHORTLINE[] = " CDLSHORTLINE(open, high, low, close)\n\n    Short Line Candle (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_135CDLSHORTLINE = {__Pyx_NAMESTR("CDLSHORTLINE"), (PyCFunction)__pyx_pw_5talib_4func_135CDLSHORTLINE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_134CDLSHORTLINE)};
static PyObject *__pyx_pw_5talib_4func_135CDLSHORTLINE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLSHORTLINE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSHORTLINE", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSHORTLINE", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSHORTLINE", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLSHORTLINE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLSHORTLINE", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLSHORTLINE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_134CDLSHORTLINE(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4335
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSHORTLINE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSHORTLINE(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_134CDLSHORTLINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLSHORTLINE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4356
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4356; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4357
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4358
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4359
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4360
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4361
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4362
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4363
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4364
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4365
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4366
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4366; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4367
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4368
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4369
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4370
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4371
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4372
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4372; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4373
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4374
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4375
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4376
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4377
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4378
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4379
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4380
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4381
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4383
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHORTLINE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_99), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4384
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLSHORTLINE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4385
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHORTLINE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLSHORTLINE_Lookback());

  /* "talib/func.pyx":4386
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHORTLINE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4387
 *     lookback = begidx + TA_CDLSHORTLINE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4388
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSHORTLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4389
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLSHORTLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSHORTLINE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4390
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSHORTLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLSHORTLINE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLSHORTLINE(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4391
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSHORTLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSHORTLINE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLSHORTLINE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4391; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4392
 *     retCode = TA_CDLSHORTLINE( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSHORTLINE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLSHORTLINE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_137CDLSPINNINGTOP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_136CDLSPINNINGTOP[] = " CDLSPINNINGTOP(open, high, low, close)\n\n    Spinning Top (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_137CDLSPINNINGTOP = {__Pyx_NAMESTR("CDLSPINNINGTOP"), (PyCFunction)__pyx_pw_5talib_4func_137CDLSPINNINGTOP, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_136CDLSPINNINGTOP)};
static PyObject *__pyx_pw_5talib_4func_137CDLSPINNINGTOP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLSPINNINGTOP (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSPINNINGTOP", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSPINNINGTOP", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSPINNINGTOP", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLSPINNINGTOP") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLSPINNINGTOP", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLSPINNINGTOP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_136CDLSPINNINGTOP(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4396
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSPINNINGTOP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSPINNINGTOP(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_136CDLSPINNINGTOP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLSPINNINGTOP", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4417
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4418
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4419
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4420
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4421
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4422
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4423
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4423; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4424
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4425
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4426
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4427
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4428
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4429
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4430
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4431
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4432
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4433
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4434
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4435
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4436
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4437
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4438
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4439
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4440
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4441
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4442
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4444
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSPINNINGTOP_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_100), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4445
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLSPINNINGTOP_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4446
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSPINNINGTOP_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLSPINNINGTOP_Lookback());

  /* "talib/func.pyx":4447
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSPINNINGTOP_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4447; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4447; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4448
 *     lookback = begidx + TA_CDLSPINNINGTOP_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4449
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSPINNINGTOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4450
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLSPINNINGTOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSPINNINGTOP", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4451
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSPINNINGTOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLSPINNINGTOP", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLSPINNINGTOP(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4452
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSPINNINGTOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSPINNINGTOP", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLSPINNINGTOP, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4453
 *     retCode = TA_CDLSPINNINGTOP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSPINNINGTOP", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLSPINNINGTOP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_139CDLSTALLEDPATTERN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_138CDLSTALLEDPATTERN[] = " CDLSTALLEDPATTERN(open, high, low, close)\n\n    Stalled Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_139CDLSTALLEDPATTERN = {__Pyx_NAMESTR("CDLSTALLEDPATTERN"), (PyCFunction)__pyx_pw_5talib_4func_139CDLSTALLEDPATTERN, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_138CDLSTALLEDPATTERN)};
static PyObject *__pyx_pw_5talib_4func_139CDLSTALLEDPATTERN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLSTALLEDPATTERN (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSTALLEDPATTERN", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSTALLEDPATTERN", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSTALLEDPATTERN", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLSTALLEDPATTERN") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLSTALLEDPATTERN", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLSTALLEDPATTERN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_138CDLSTALLEDPATTERN(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4457
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSTALLEDPATTERN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSTALLEDPATTERN(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_138CDLSTALLEDPATTERN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLSTALLEDPATTERN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4478
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4478; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4479
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4479; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4480
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4481
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4481; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4482
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4483
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4484
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4485
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4486
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4487
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4488
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4489
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4489; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4490
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4491
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4492
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4493
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4494
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4495
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4496
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4496; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4497
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4498
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4499
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4500
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4501
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4502
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4503
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4505
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTALLEDPATTERN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_101), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4506
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLSTALLEDPATTERN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4507
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTALLEDPATTERN_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLSTALLEDPATTERN_Lookback());

  /* "talib/func.pyx":4508
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTALLEDPATTERN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4509
 *     lookback = begidx + TA_CDLSTALLEDPATTERN_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4510
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSTALLEDPATTERN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4511
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLSTALLEDPATTERN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSTALLEDPATTERN", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4512
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSTALLEDPATTERN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLSTALLEDPATTERN", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLSTALLEDPATTERN(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4513
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSTALLEDPATTERN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSTALLEDPATTERN", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_102, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4514
 *     retCode = TA_CDLSTALLEDPATTERN( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSTALLEDPATTERN", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLSTALLEDPATTERN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_141CDLSTICKSANDWICH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_140CDLSTICKSANDWICH[] = " CDLSTICKSANDWICH(open, high, low, close)\n\n    Stick Sandwich (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_141CDLSTICKSANDWICH = {__Pyx_NAMESTR("CDLSTICKSANDWICH"), (PyCFunction)__pyx_pw_5talib_4func_141CDLSTICKSANDWICH, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_140CDLSTICKSANDWICH)};
static PyObject *__pyx_pw_5talib_4func_141CDLSTICKSANDWICH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLSTICKSANDWICH (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSTICKSANDWICH", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSTICKSANDWICH", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLSTICKSANDWICH", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLSTICKSANDWICH") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLSTICKSANDWICH", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLSTICKSANDWICH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_140CDLSTICKSANDWICH(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4518
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSTICKSANDWICH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSTICKSANDWICH(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_140CDLSTICKSANDWICH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLSTICKSANDWICH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4539
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4539; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4540
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4541
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4542
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4543
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4544
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4545
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4546
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4547
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4548
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4549
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4550
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4551
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4552
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4553
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4554
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4554; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4555
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4555; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4556
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4557
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4558
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4559
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4560
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4561
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4562
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4563
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4564
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4566
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTICKSANDWICH_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_103), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4567
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLSTICKSANDWICH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4568
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTICKSANDWICH_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLSTICKSANDWICH_Lookback());

  /* "talib/func.pyx":4569
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTICKSANDWICH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4570
 *     lookback = begidx + TA_CDLSTICKSANDWICH_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4571
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSTICKSANDWICH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4572
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLSTICKSANDWICH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSTICKSANDWICH", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4573
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSTICKSANDWICH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLSTICKSANDWICH", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLSTICKSANDWICH(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4574
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLSTICKSANDWICH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSTICKSANDWICH", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLSTICKSANDWICH, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4575
 *     retCode = TA_CDLSTICKSANDWICH( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLSTICKSANDWICH", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLSTICKSANDWICH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_143CDLTAKURI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_142CDLTAKURI[] = " CDLTAKURI(open, high, low, close)\n\n    Takuri (Dragonfly Doji with very long lower shadow) (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_143CDLTAKURI = {__Pyx_NAMESTR("CDLTAKURI"), (PyCFunction)__pyx_pw_5talib_4func_143CDLTAKURI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_142CDLTAKURI)};
static PyObject *__pyx_pw_5talib_4func_143CDLTAKURI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLTAKURI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTAKURI", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTAKURI", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTAKURI", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLTAKURI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLTAKURI", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLTAKURI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_142CDLTAKURI(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4579
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTAKURI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTAKURI(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_142CDLTAKURI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLTAKURI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4600
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4601
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4602
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4603
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4603; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4603; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4604
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4605
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4605; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4606
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4606; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4607
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4608
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4609
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4610
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4611
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4611; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4612
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4613
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4614
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4615
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4616
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4617
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4618
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4619
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4620
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4621
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4622
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4623
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4624
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4625
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4627
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTAKURI_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_104), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4628
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLTAKURI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4629
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTAKURI_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLTAKURI_Lookback());

  /* "talib/func.pyx":4630
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTAKURI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4630; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4631
 *     lookback = begidx + TA_CDLTAKURI_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4632
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTAKURI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4633
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLTAKURI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTAKURI", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4634
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTAKURI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLTAKURI", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLTAKURI(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4635
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTAKURI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTAKURI", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLTAKURI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4635; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4636
 *     retCode = TA_CDLTAKURI( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTAKURI", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLTAKURI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_145CDLTASUKIGAP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_144CDLTASUKIGAP[] = " CDLTASUKIGAP(open, high, low, close)\n\n    Tasuki Gap (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_145CDLTASUKIGAP = {__Pyx_NAMESTR("CDLTASUKIGAP"), (PyCFunction)__pyx_pw_5talib_4func_145CDLTASUKIGAP, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_144CDLTASUKIGAP)};
static PyObject *__pyx_pw_5talib_4func_145CDLTASUKIGAP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLTASUKIGAP (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTASUKIGAP", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTASUKIGAP", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTASUKIGAP", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLTASUKIGAP") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLTASUKIGAP", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLTASUKIGAP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_144CDLTASUKIGAP(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4640
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTASUKIGAP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTASUKIGAP(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_144CDLTASUKIGAP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLTASUKIGAP", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4661
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4661; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4662
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4662; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4663
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4664
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4664; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4664; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4665
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4666
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4667
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4667; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4668
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4669
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4670
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4671
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4671; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4672
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4672; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4673
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4674
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4674; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4674; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4675
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4676
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4677
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4677; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4678
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4679
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4680
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4681
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4682
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4683
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4684
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4685
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4686
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4688
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTASUKIGAP_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_105), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4689
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLTASUKIGAP_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4690
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTASUKIGAP_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLTASUKIGAP_Lookback());

  /* "talib/func.pyx":4691
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTASUKIGAP_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4692
 *     lookback = begidx + TA_CDLTASUKIGAP_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4693
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTASUKIGAP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4694
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLTASUKIGAP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTASUKIGAP", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4695
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTASUKIGAP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLTASUKIGAP", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLTASUKIGAP(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4696
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTASUKIGAP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTASUKIGAP", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLTASUKIGAP, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4697
 *     retCode = TA_CDLTASUKIGAP( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTASUKIGAP", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLTASUKIGAP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_147CDLTHRUSTING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_146CDLTHRUSTING[] = " CDLTHRUSTING(open, high, low, close)\n\n    Thrusting Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_147CDLTHRUSTING = {__Pyx_NAMESTR("CDLTHRUSTING"), (PyCFunction)__pyx_pw_5talib_4func_147CDLTHRUSTING, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_146CDLTHRUSTING)};
static PyObject *__pyx_pw_5talib_4func_147CDLTHRUSTING(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLTHRUSTING (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTHRUSTING", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTHRUSTING", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTHRUSTING", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLTHRUSTING") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLTHRUSTING", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLTHRUSTING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_146CDLTHRUSTING(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4701
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTHRUSTING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTHRUSTING(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_146CDLTHRUSTING(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLTHRUSTING", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4722
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4723
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4724
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4725
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4726
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4727
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4728
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4728; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4729
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4730
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4731
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4732
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4732; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4733
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4734
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4735
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4735; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4735; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4736
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4737
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4737; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4738
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4739
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4740
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4740; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4740; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4741
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4742
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4743
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4744
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4745
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4746
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4747
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4749
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTHRUSTING_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_106), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4749; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4749; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4750
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLTHRUSTING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4751
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTHRUSTING_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLTHRUSTING_Lookback());

  /* "talib/func.pyx":4752
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTHRUSTING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4752; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4752; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4753
 *     lookback = begidx + TA_CDLTHRUSTING_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4754
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTHRUSTING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4755
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLTHRUSTING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTHRUSTING", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4756
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTHRUSTING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLTHRUSTING", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLTHRUSTING(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4757
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTHRUSTING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTHRUSTING", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLTHRUSTING, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4757; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4758
 *     retCode = TA_CDLTHRUSTING( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTHRUSTING", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLTHRUSTING", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_149CDLTRISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_148CDLTRISTAR[] = " CDLTRISTAR(open, high, low, close)\n\n    Tristar Pattern (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_149CDLTRISTAR = {__Pyx_NAMESTR("CDLTRISTAR"), (PyCFunction)__pyx_pw_5talib_4func_149CDLTRISTAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_148CDLTRISTAR)};
static PyObject *__pyx_pw_5talib_4func_149CDLTRISTAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLTRISTAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTRISTAR", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTRISTAR", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLTRISTAR", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLTRISTAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLTRISTAR", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLTRISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_148CDLTRISTAR(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4762
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTRISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTRISTAR(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_148CDLTRISTAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLTRISTAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4783
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4784
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4785
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4786
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4787
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4788
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4788; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4789
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4789; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4790
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4791
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4792
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4793
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4793; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4794
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4795
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4796
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4797
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4798
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4799
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4800
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4801
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4802
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4803
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4804
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4805
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4806
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4807
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4808
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4810
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTRISTAR_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_107), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4811
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLTRISTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4812
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTRISTAR_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLTRISTAR_Lookback());

  /* "talib/func.pyx":4813
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTRISTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4814
 *     lookback = begidx + TA_CDLTRISTAR_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4815
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTRISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4816
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLTRISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTRISTAR", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4817
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTRISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLTRISTAR", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLTRISTAR(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4818
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLTRISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTRISTAR", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLTRISTAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4819
 *     retCode = TA_CDLTRISTAR( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLTRISTAR", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLTRISTAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_151CDLUNIQUE3RIVER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_150CDLUNIQUE3RIVER[] = " CDLUNIQUE3RIVER(open, high, low, close)\n\n    Unique 3 River (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_151CDLUNIQUE3RIVER = {__Pyx_NAMESTR("CDLUNIQUE3RIVER"), (PyCFunction)__pyx_pw_5talib_4func_151CDLUNIQUE3RIVER, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_150CDLUNIQUE3RIVER)};
static PyObject *__pyx_pw_5talib_4func_151CDLUNIQUE3RIVER(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLUNIQUE3RIVER (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLUNIQUE3RIVER", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLUNIQUE3RIVER", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLUNIQUE3RIVER", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLUNIQUE3RIVER") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLUNIQUE3RIVER", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLUNIQUE3RIVER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_150CDLUNIQUE3RIVER(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4823
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLUNIQUE3RIVER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLUNIQUE3RIVER(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_150CDLUNIQUE3RIVER(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLUNIQUE3RIVER", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4844
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4845
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4846
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4847
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4847; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4847; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4848
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4849
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4850
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4850; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4851
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4852
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4853
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4854
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4854; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4855
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4855; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4856
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4857
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4858
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4859
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4859; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4860
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4860; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4861
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4862
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4862; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4862; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4863
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4864
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4865
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4866
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4867
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4868
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4869
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4871
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUNIQUE3RIVER_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_108), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4872
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLUNIQUE3RIVER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4873
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUNIQUE3RIVER_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLUNIQUE3RIVER_Lookback());

  /* "talib/func.pyx":4874
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUNIQUE3RIVER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4874; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4874; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4875
 *     lookback = begidx + TA_CDLUNIQUE3RIVER_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4876
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLUNIQUE3RIVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4877
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLUNIQUE3RIVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLUNIQUE3RIVER", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4878
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLUNIQUE3RIVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLUNIQUE3RIVER", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLUNIQUE3RIVER(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4879
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLUNIQUE3RIVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLUNIQUE3RIVER", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CDLUNIQUE3RIVER, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4879; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4880
 *     retCode = TA_CDLUNIQUE3RIVER( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLUNIQUE3RIVER", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLUNIQUE3RIVER", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_153CDLUPSIDEGAP2CROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_152CDLUPSIDEGAP2CROWS[] = " CDLUPSIDEGAP2CROWS(open, high, low, close)\n\n    Upside Gap Two Crows (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_153CDLUPSIDEGAP2CROWS = {__Pyx_NAMESTR("CDLUPSIDEGAP2CROWS"), (PyCFunction)__pyx_pw_5talib_4func_153CDLUPSIDEGAP2CROWS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_152CDLUPSIDEGAP2CROWS)};
static PyObject *__pyx_pw_5talib_4func_153CDLUPSIDEGAP2CROWS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLUPSIDEGAP2CROWS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLUPSIDEGAP2CROWS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLUPSIDEGAP2CROWS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLUPSIDEGAP2CROWS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLUPSIDEGAP2CROWS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLUPSIDEGAP2CROWS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLUPSIDEGAP2CROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_152CDLUPSIDEGAP2CROWS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4884
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLUPSIDEGAP2CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLUPSIDEGAP2CROWS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_152CDLUPSIDEGAP2CROWS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLUPSIDEGAP2CROWS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4905
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4906
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4907
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4908
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4909
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4910
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4911
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4911; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4912
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4913
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4914
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4915
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4915; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4916
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4916; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4917
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4918
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4918; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4918; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4919
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4920
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4920; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4921
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4922
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4923
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4923; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4923; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4924
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4925
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4926
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4927
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4928
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4929
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4930
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4932
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUPSIDEGAP2CROWS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_109), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4933
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLUPSIDEGAP2CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4934
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUPSIDEGAP2CROWS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLUPSIDEGAP2CROWS_Lookback());

  /* "talib/func.pyx":4935
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUPSIDEGAP2CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4935; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4936
 *     lookback = begidx + TA_CDLUPSIDEGAP2CROWS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4937
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLUPSIDEGAP2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4938
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLUPSIDEGAP2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLUPSIDEGAP2CROWS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":4939
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLUPSIDEGAP2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLUPSIDEGAP2CROWS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLUPSIDEGAP2CROWS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":4940
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLUPSIDEGAP2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLUPSIDEGAP2CROWS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_110, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4940; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":4941
 *     retCode = TA_CDLUPSIDEGAP2CROWS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLUPSIDEGAP2CROWS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLUPSIDEGAP2CROWS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_155CDLXSIDEGAP3METHODS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_154CDLXSIDEGAP3METHODS[] = " CDLXSIDEGAP3METHODS(open, high, low, close)\n\n    Upside/Downside Gap Three Methods (Pattern Recognition)\n\n    Inputs:\n        prices: ['open', 'high', 'low', 'close']\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_155CDLXSIDEGAP3METHODS = {__Pyx_NAMESTR("CDLXSIDEGAP3METHODS"), (PyCFunction)__pyx_pw_5talib_4func_155CDLXSIDEGAP3METHODS, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_154CDLXSIDEGAP3METHODS)};
static PyObject *__pyx_pw_5talib_4func_155CDLXSIDEGAP3METHODS(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_open = 0;
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CDLXSIDEGAP3METHODS (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__open,&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__open)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLXSIDEGAP3METHODS", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLXSIDEGAP3METHODS", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CDLXSIDEGAP3METHODS", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CDLXSIDEGAP3METHODS") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_open = ((PyArrayObject *)values[0]);
    __pyx_v_high = ((PyArrayObject *)values[1]);
    __pyx_v_low = ((PyArrayObject *)values[2]);
    __pyx_v_close = ((PyArrayObject *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CDLXSIDEGAP3METHODS", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CDLXSIDEGAP3METHODS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_open), __pyx_ptype_5numpy_ndarray, 0, "open", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_154CDLXSIDEGAP3METHODS(__pyx_self, __pyx_v_open, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":4945
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLXSIDEGAP3METHODS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLXSIDEGAP3METHODS(open, high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_154CDLXSIDEGAP3METHODS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_open, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_open_data;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CDLXSIDEGAP3METHODS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_open);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":4966
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"             # <<<<<<<<<<<<<<
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_open) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_28));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4966; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4967
 *         int* outinteger_data
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_open->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_29));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4967; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4968
 *     assert PyArray_TYPE(open) == np.NPY_DOUBLE, "open is not double"
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_open) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4969
 *     assert open.ndim == 1, "open has wrong dimensions"
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)             # <<<<<<<<<<<<<<
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_open); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_open));
    __pyx_v_open = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":4970
 *     if not (PyArray_FLAGS(open) & np.NPY_C_CONTIGUOUS):
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 */
  __pyx_v_open_data = ((double *)__pyx_v_open->data);

  /* "talib/func.pyx":4971
 *         open = PyArray_GETCONTIGUOUS(open)
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4972
 *     open_data = <double*>open.data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4972; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4973
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4974
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":4975
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":4976
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4976; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4977
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4978
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4979
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":4980
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":4981
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4982
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":4983
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":4984
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":4985
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":4986
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":4987
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":4988
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":4989
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":4990
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":4991
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":4993
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLXSIDEGAP3METHODS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_111), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4993; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4993; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":4994
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CDLXSIDEGAP3METHODS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":4995
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLXSIDEGAP3METHODS_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CDLXSIDEGAP3METHODS_Lookback());

  /* "talib/func.pyx":4996
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLXSIDEGAP3METHODS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4996; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4996; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":4997
 *     lookback = begidx + TA_CDLXSIDEGAP3METHODS_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":4998
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLXSIDEGAP3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":4999
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_CDLXSIDEGAP3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLXSIDEGAP3METHODS", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":5000
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLXSIDEGAP3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CDLXSIDEGAP3METHODS", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_CDLXSIDEGAP3METHODS(0, __pyx_v_endidx, ((double *)(__pyx_v_open_data + __pyx_v_begidx)), ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5001
 *         outinteger_data[i] = 0
 *     retCode = TA_CDLXSIDEGAP3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLXSIDEGAP3METHODS", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_112, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5001; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5002
 *     retCode = TA_CDLXSIDEGAP3METHODS( 0 , endidx , <double *>(open_data+begidx) , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_CDLXSIDEGAP3METHODS", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CDLXSIDEGAP3METHODS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_open);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_157CEIL(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_156CEIL[] = " CEIL(real)\n\n    Vector Ceil (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_157CEIL = {__Pyx_NAMESTR("CEIL"), (PyCFunction)__pyx_pw_5talib_4func_157CEIL, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_156CEIL)};
static PyObject *__pyx_pw_5talib_4func_157CEIL(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CEIL (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_156CEIL(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5006
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CEIL( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ CEIL(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_156CEIL(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CEIL", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5024
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5024; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5025
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5026
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5027
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5027; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5028
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5029
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5030
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5031
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5032
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5033
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5034
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5036
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CEIL_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_113), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5036; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5036; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5037
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CEIL_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5038
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CEIL_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CEIL_Lookback());

  /* "talib/func.pyx":5039
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CEIL_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5040
 *     lookback = begidx + TA_CEIL_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5041
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_CEIL( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5042
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_CEIL( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CEIL", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5043
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_CEIL( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CEIL", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_CEIL(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5044
 *         outreal_data[i] = NaN
 *     retCode = TA_CEIL( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CEIL", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CEIL, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5044; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5045
 *     retCode = TA_CEIL( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CEIL", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CEIL", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_159CMO(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_158CMO[] = " CMO(real[, timeperiod=?])\n\n    Chande Momentum Oscillator (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_159CMO = {__Pyx_NAMESTR("CMO"), (PyCFunction)__pyx_pw_5talib_4func_159CMO, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_158CMO)};
static PyObject *__pyx_pw_5talib_4func_159CMO(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CMO (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CMO") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CMO", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CMO", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_158CMO(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5049
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CMO( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CMO(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_158CMO(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CMO", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5069
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5069; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5070
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5071
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5072
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5072; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5072; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5073
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5074
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5075
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5076
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5077
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5078
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5079
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5081
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CMO_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_114), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5082
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CMO_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5083
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CMO_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CMO_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5084
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CMO_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5084; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5084; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5085
 *     lookback = begidx + TA_CMO_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5086
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_CMO( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5087
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_CMO( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CMO", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5088
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_CMO( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CMO", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_CMO(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5089
 *         outreal_data[i] = NaN
 *     retCode = TA_CMO( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CMO", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CMO, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5089; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5090
 *     retCode = TA_CMO( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CMO", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CMO", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_161CORREL(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_160CORREL[] = " CORREL(real0, real1[, timeperiod=?])\n\n    Pearson's Correlation Coefficient (r) (Statistic Functions)\n\n    Inputs:\n        real0: (any ndarray)\n        real1: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_161CORREL = {__Pyx_NAMESTR("CORREL"), (PyCFunction)__pyx_pw_5talib_4func_161CORREL, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_160CORREL)};
static PyObject *__pyx_pw_5talib_4func_161CORREL(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real0 = 0;
  PyArrayObject *__pyx_v_real1 = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("CORREL (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real0,&__pyx_n_s__real1,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real0)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("CORREL", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "CORREL") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real0 = ((PyArrayObject *)values[0]);
    __pyx_v_real1 = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("CORREL", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.CORREL", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real0), __pyx_ptype_5numpy_ndarray, 0, "real0", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real1), __pyx_ptype_5numpy_ndarray, 0, "real1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_160CORREL(__pyx_self, __pyx_v_real0, __pyx_v_real1, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5094
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CORREL( np.ndarray real0 not None , np.ndarray real1 not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CORREL(real0, real1[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_160CORREL(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real0_data;
  double *__pyx_v_real1_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("CORREL", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real0);
  __Pyx_INCREF((PyObject *)__pyx_v_real1);

  /* "talib/func.pyx":5116
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"             # <<<<<<<<<<<<<<
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real0) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_14));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5116; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5117
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real0->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_15));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5118
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real0) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5119
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)             # <<<<<<<<<<<<<<
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real0));
    __pyx_v_real0 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5120
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 */
  __pyx_v_real0_data = ((double *)__pyx_v_real0->data);

  /* "talib/func.pyx":5121
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"             # <<<<<<<<<<<<<<
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real1) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_16));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5122
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real1->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_17));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5123
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real1) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5124
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)             # <<<<<<<<<<<<<<
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real1));
    __pyx_v_real1 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":5125
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data             # <<<<<<<<<<<<<<
 *     length = real0.shape[0]
 *     begidx = 0
 */
  __pyx_v_real1_data = ((double *)__pyx_v_real1->data);

  /* "talib/func.pyx":5126
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real0->dimensions[0]);

  /* "talib/func.pyx":5127
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5128
 *     length = real0.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real0_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5129
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real0_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5130
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5131
 *         if not isnan(real0_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":5133
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CORREL_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_115), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":5134
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_CORREL_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5135
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CORREL_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_CORREL_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5136
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CORREL_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5137
 *     lookback = begidx + TA_CORREL_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5138
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_CORREL( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5139
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_CORREL( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CORREL", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5140
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_CORREL( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_CORREL", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_CORREL(0, __pyx_v_endidx, ((double *)(__pyx_v_real0_data + __pyx_v_begidx)), ((double *)(__pyx_v_real1_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5141
 *         outreal_data[i] = NaN
 *     retCode = TA_CORREL( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CORREL", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_CORREL, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5142
 *     retCode = TA_CORREL( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_CORREL", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.CORREL", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real0);
  __Pyx_XDECREF((PyObject *)__pyx_v_real1);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_163COS(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_162COS[] = " COS(real)\n\n    Vector Trigonometric Cos (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_163COS = {__Pyx_NAMESTR("COS"), (PyCFunction)__pyx_pw_5talib_4func_163COS, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_162COS)};
static PyObject *__pyx_pw_5talib_4func_163COS(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("COS (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_162COS(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5146
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def COS( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ COS(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_162COS(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("COS", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5164
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5165
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5166
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5167
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5167; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5168
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5169
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5170
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5171
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5172
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5173
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5174
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5176
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COS_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_116), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5177
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_COS_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5178
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COS_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_COS_Lookback());

  /* "talib/func.pyx":5179
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COS_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5180
 *     lookback = begidx + TA_COS_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5181
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_COS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5182
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_COS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_COS", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5183
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_COS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_COS", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_COS(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5184
 *         outreal_data[i] = NaN
 *     retCode = TA_COS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_COS", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_COS, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5185
 *     retCode = TA_COS( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_COS", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.COS", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_165COSH(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_164COSH[] = " COSH(real)\n\n    Vector Trigonometric Cosh (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_165COSH = {__Pyx_NAMESTR("COSH"), (PyCFunction)__pyx_pw_5talib_4func_165COSH, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_164COSH)};
static PyObject *__pyx_pw_5talib_4func_165COSH(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("COSH (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_164COSH(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5189
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def COSH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ COSH(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_164COSH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("COSH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5207
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5208
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5209
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5210
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5211
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5212
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5213
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5214
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5215
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5216
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5217
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5219
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COSH_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_117), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5220
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_COSH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5221
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COSH_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_COSH_Lookback());

  /* "talib/func.pyx":5222
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COSH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5222; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5223
 *     lookback = begidx + TA_COSH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5224
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_COSH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5225
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_COSH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_COSH", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5226
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_COSH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_COSH", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_COSH(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5227
 *         outreal_data[i] = NaN
 *     retCode = TA_COSH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_COSH", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_COSH, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5228
 *     retCode = TA_COSH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_COSH", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.COSH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_167DEMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_166DEMA[] = " DEMA(real[, timeperiod=?])\n\n    Double Exponential Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_167DEMA = {__Pyx_NAMESTR("DEMA"), (PyCFunction)__pyx_pw_5talib_4func_167DEMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_166DEMA)};
static PyObject *__pyx_pw_5talib_4func_167DEMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("DEMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "DEMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("DEMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.DEMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_166DEMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5232
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DEMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ DEMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_166DEMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("DEMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5252
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5253
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5254
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5255
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5256
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5257
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5258
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5259
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5260
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5261
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5262
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5264
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DEMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_118), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5265
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_DEMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5266
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DEMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_DEMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5267
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DEMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5268
 *     lookback = begidx + TA_DEMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5269
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_DEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5270
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_DEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DEMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5271
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_DEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_DEMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_DEMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5272
 *         outreal_data[i] = NaN
 *     retCode = TA_DEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DEMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_DEMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5273
 *     retCode = TA_DEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DEMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.DEMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_169DIV(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_168DIV[] = " DIV(real0, real1)\n\n    Vector Arithmetic Div (Math Operators)\n\n    Inputs:\n        real0: (any ndarray)\n        real1: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_169DIV = {__Pyx_NAMESTR("DIV"), (PyCFunction)__pyx_pw_5talib_4func_169DIV, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_168DIV)};
static PyObject *__pyx_pw_5talib_4func_169DIV(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real0 = 0;
  PyArrayObject *__pyx_v_real1 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("DIV (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real0,&__pyx_n_s__real1,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real0)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("DIV", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "DIV") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_real0 = ((PyArrayObject *)values[0]);
    __pyx_v_real1 = ((PyArrayObject *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("DIV", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.DIV", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real0), __pyx_ptype_5numpy_ndarray, 0, "real0", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real1), __pyx_ptype_5numpy_ndarray, 0, "real1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_168DIV(__pyx_self, __pyx_v_real0, __pyx_v_real1);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5277
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DIV( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ DIV(real0, real1)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_168DIV(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real0_data;
  double *__pyx_v_real1_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("DIV", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real0);
  __Pyx_INCREF((PyObject *)__pyx_v_real1);

  /* "talib/func.pyx":5297
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"             # <<<<<<<<<<<<<<
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real0) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_14));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5297; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5298
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real0->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_15));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5299
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real0) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5300
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)             # <<<<<<<<<<<<<<
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real0));
    __pyx_v_real0 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5301
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 */
  __pyx_v_real0_data = ((double *)__pyx_v_real0->data);

  /* "talib/func.pyx":5302
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"             # <<<<<<<<<<<<<<
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real1) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_16));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5302; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5303
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real1->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_17));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5304
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real1) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5305
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)             # <<<<<<<<<<<<<<
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real1));
    __pyx_v_real1 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":5306
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data             # <<<<<<<<<<<<<<
 *     length = real0.shape[0]
 *     begidx = 0
 */
  __pyx_v_real1_data = ((double *)__pyx_v_real1->data);

  /* "talib/func.pyx":5307
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real0->dimensions[0]);

  /* "talib/func.pyx":5308
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5309
 *     length = real0.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real0_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5310
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real0_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5311
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5312
 *         if not isnan(real0_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":5314
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DIV_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_119), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":5315
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_DIV_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5316
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DIV_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_DIV_Lookback());

  /* "talib/func.pyx":5317
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DIV_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5317; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5317; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5318
 *     lookback = begidx + TA_DIV_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5319
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_DIV( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5320
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_DIV( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DIV", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5321
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_DIV( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_DIV", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_DIV(0, __pyx_v_endidx, ((double *)(__pyx_v_real0_data + __pyx_v_begidx)), ((double *)(__pyx_v_real1_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5322
 *         outreal_data[i] = NaN
 *     retCode = TA_DIV( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DIV", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_DIV, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5323
 *     retCode = TA_DIV( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DIV", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.DIV", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real0);
  __Pyx_XDECREF((PyObject *)__pyx_v_real1);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_171DX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_170DX[] = " DX(high, low, close[, timeperiod=?])\n\n    Directional Movement Index (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_171DX = {__Pyx_NAMESTR("DX"), (PyCFunction)__pyx_pw_5talib_4func_171DX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_170DX)};
static PyObject *__pyx_pw_5talib_4func_171DX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("DX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("DX", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("DX", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "DX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("DX", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.DX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_170DX(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5327
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DX( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ DX(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_170DX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("DX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":5349
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5350
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5351
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5352
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5353
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":5354
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5354; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5355
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5356
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5357
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":5358
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":5359
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5360
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5361
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5362
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":5363
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":5364
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":5365
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5366
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5367
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5368
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5369
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":5371
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_120), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":5372
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_DX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5373
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_DX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5374
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5375
 *     lookback = begidx + TA_DX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5376
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_DX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5377
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_DX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DX", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5378
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_DX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_DX", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_DX(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5379
 *         outreal_data[i] = NaN
 *     retCode = TA_DX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DX", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_DX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5380
 *     retCode = TA_DX( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_DX", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.DX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_173EMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_172EMA[] = " EMA(real[, timeperiod=?])\n\n    Exponential Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_173EMA = {__Pyx_NAMESTR("EMA"), (PyCFunction)__pyx_pw_5talib_4func_173EMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_172EMA)};
static PyObject *__pyx_pw_5talib_4func_173EMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("EMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "EMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("EMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.EMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_172EMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5384
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def EMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ EMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_172EMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("EMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5404
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5404; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5405
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5406
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5407
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5408
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5409
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5410
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5411
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5412
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5413
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5414
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5416
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_121), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5417
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_EMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5418
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_EMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5419
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5420
 *     lookback = begidx + TA_EMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5421
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_EMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5422
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_EMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_EMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5423
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_EMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_EMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_EMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5424
 *         outreal_data[i] = NaN
 *     retCode = TA_EMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_EMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_EMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5425
 *     retCode = TA_EMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_EMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.EMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_175EXP(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_174EXP[] = " EXP(real)\n\n    Vector Arithmetic Exp (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_175EXP = {__Pyx_NAMESTR("EXP"), (PyCFunction)__pyx_pw_5talib_4func_175EXP, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_174EXP)};
static PyObject *__pyx_pw_5talib_4func_175EXP(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("EXP (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_174EXP(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5429
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def EXP( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ EXP(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_174EXP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("EXP", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5447
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5447; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5448
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5449
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5450
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5451
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5452
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5453
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5454
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5455
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5456
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5457
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5459
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EXP_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_122), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5460
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_EXP_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5461
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EXP_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_EXP_Lookback());

  /* "talib/func.pyx":5462
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EXP_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5463
 *     lookback = begidx + TA_EXP_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5464
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_EXP( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5465
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_EXP( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_EXP", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5466
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_EXP( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_EXP", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_EXP(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5467
 *         outreal_data[i] = NaN
 *     retCode = TA_EXP( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_EXP", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_EXP, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5468
 *     retCode = TA_EXP( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_EXP", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.EXP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_177FLOOR(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_176FLOOR[] = " FLOOR(real)\n\n    Vector Floor (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_177FLOOR = {__Pyx_NAMESTR("FLOOR"), (PyCFunction)__pyx_pw_5talib_4func_177FLOOR, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_176FLOOR)};
static PyObject *__pyx_pw_5talib_4func_177FLOOR(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("FLOOR (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_176FLOOR(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5472
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def FLOOR( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ FLOOR(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_176FLOOR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("FLOOR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5490
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5490; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5491
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5491; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5492
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5493
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5493; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5494
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5495
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5496
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5497
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5498
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5499
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5500
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5502
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_FLOOR_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_123), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5503
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_FLOOR_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5504
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_FLOOR_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_FLOOR_Lookback());

  /* "talib/func.pyx":5505
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_FLOOR_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5506
 *     lookback = begidx + TA_FLOOR_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5507
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_FLOOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5508
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_FLOOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_FLOOR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5509
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_FLOOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_FLOOR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_FLOOR(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5510
 *         outreal_data[i] = NaN
 *     retCode = TA_FLOOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_FLOOR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_FLOOR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5510; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5511
 *     retCode = TA_FLOOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_FLOOR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.FLOOR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_179HT_DCPERIOD(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_178HT_DCPERIOD[] = " HT_DCPERIOD(real)\n\n    Hilbert Transform - Dominant Cycle Period (Cycle Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_179HT_DCPERIOD = {__Pyx_NAMESTR("HT_DCPERIOD"), (PyCFunction)__pyx_pw_5talib_4func_179HT_DCPERIOD, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_178HT_DCPERIOD)};
static PyObject *__pyx_pw_5talib_4func_179HT_DCPERIOD(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HT_DCPERIOD (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_178HT_DCPERIOD(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5515
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_DCPERIOD( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_DCPERIOD(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_178HT_DCPERIOD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HT_DCPERIOD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5533
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5534
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5535
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5536
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5537
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5538
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5539
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5540
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5541
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5542
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5543
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5545
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPERIOD_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_124), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5546
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_HT_DCPERIOD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5547
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPERIOD_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_HT_DCPERIOD_Lookback());

  /* "talib/func.pyx":5548
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPERIOD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5549
 *     lookback = begidx + TA_HT_DCPERIOD_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5550
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_DCPERIOD( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5551
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_HT_DCPERIOD( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_DCPERIOD", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5552
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_DCPERIOD( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_HT_DCPERIOD", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_HT_DCPERIOD(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5553
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_DCPERIOD( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_DCPERIOD", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_HT_DCPERIOD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5554
 *     retCode = TA_HT_DCPERIOD( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_DCPERIOD", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.HT_DCPERIOD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_181HT_DCPHASE(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_180HT_DCPHASE[] = " HT_DCPHASE(real)\n\n    Hilbert Transform - Dominant Cycle Phase (Cycle Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_181HT_DCPHASE = {__Pyx_NAMESTR("HT_DCPHASE"), (PyCFunction)__pyx_pw_5talib_4func_181HT_DCPHASE, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_180HT_DCPHASE)};
static PyObject *__pyx_pw_5talib_4func_181HT_DCPHASE(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HT_DCPHASE (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_180HT_DCPHASE(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5558
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_DCPHASE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_DCPHASE(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_180HT_DCPHASE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HT_DCPHASE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5576
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5577
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5578
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5579
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5580
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5581
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5582
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5583
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5584
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5585
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5586
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5588
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPHASE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_125), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5589
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_HT_DCPHASE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5590
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPHASE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_HT_DCPHASE_Lookback());

  /* "talib/func.pyx":5591
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPHASE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5592
 *     lookback = begidx + TA_HT_DCPHASE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5593
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_DCPHASE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5594
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_HT_DCPHASE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_DCPHASE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5595
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_DCPHASE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_HT_DCPHASE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_HT_DCPHASE(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5596
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_DCPHASE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_DCPHASE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_HT_DCPHASE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5597
 *     retCode = TA_HT_DCPHASE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_DCPHASE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.HT_DCPHASE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_183HT_PHASOR(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_182HT_PHASOR[] = " HT_PHASOR(real)\n\n    Hilbert Transform - Phasor Components (Cycle Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        inphase\n        quadrature\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_183HT_PHASOR = {__Pyx_NAMESTR("HT_PHASOR"), (PyCFunction)__pyx_pw_5talib_4func_183HT_PHASOR, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_182HT_PHASOR)};
static PyObject *__pyx_pw_5talib_4func_183HT_PHASOR(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HT_PHASOR (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_182HT_PHASOR(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5601
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_PHASOR( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_PHASOR(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_182HT_PHASOR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinphase = 0;
  double *__pyx_v_outinphase_data;
  PyArrayObject *__pyx_v_outquadrature = 0;
  double *__pyx_v_outquadrature_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HT_PHASOR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5622
 *         np.ndarray outquadrature
 *         double* outquadrature_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5623
 *         double* outquadrature_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5624
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5625
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5625; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5626
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5627
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5628
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5629
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5630
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5631
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5632
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5634
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_PHASOR_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_126), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5635
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_HT_PHASOR_Lookback( )
 *     outinphase = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5636
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_PHASOR_Lookback( )             # <<<<<<<<<<<<<<
 *     outinphase = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outinphase_data = <double*>outinphase.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_HT_PHASOR_Lookback());

  /* "talib/func.pyx":5637
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_PHASOR_Lookback( )
 *     outinphase = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinphase_data = <double*>outinphase.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinphase = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5638
 *     lookback = begidx + TA_HT_PHASOR_Lookback( )
 *     outinphase = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outinphase_data = <double*>outinphase.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinphase_data[i] = NaN
 */
  __pyx_v_outinphase_data = ((double *)__pyx_v_outinphase->data);

  /* "talib/func.pyx":5639
 *     outinphase = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outinphase_data = <double*>outinphase.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinphase_data[i] = NaN
 *     outquadrature = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5640
 *     outinphase_data = <double*>outinphase.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinphase_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outquadrature = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outquadrature_data = <double*>outquadrature.data
 */
    (__pyx_v_outinphase_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5641
 *     for i from 0 <= i < min(lookback, length):
 *         outinphase_data[i] = NaN
 *     outquadrature = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outquadrature_data = <double*>outquadrature.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5641; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5641; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outquadrature = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5642
 *         outinphase_data[i] = NaN
 *     outquadrature = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outquadrature_data = <double*>outquadrature.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outquadrature_data[i] = NaN
 */
  __pyx_v_outquadrature_data = ((double *)__pyx_v_outquadrature->data);

  /* "talib/func.pyx":5643
 *     outquadrature = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outquadrature_data = <double*>outquadrature.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outquadrature_data[i] = NaN
 *     retCode = TA_HT_PHASOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outinphase_data+lookback) , <double *>(outquadrature_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5644
 *     outquadrature_data = <double*>outquadrature.data
 *     for i from 0 <= i < min(lookback, length):
 *         outquadrature_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_HT_PHASOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outinphase_data+lookback) , <double *>(outquadrature_data+lookback) )
 *     _ta_check_success("TA_HT_PHASOR", retCode)
 */
    (__pyx_v_outquadrature_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5645
 *     for i from 0 <= i < min(lookback, length):
 *         outquadrature_data[i] = NaN
 *     retCode = TA_HT_PHASOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outinphase_data+lookback) , <double *>(outquadrature_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_HT_PHASOR", retCode)
 *     return outinphase , outquadrature
 */
  __pyx_v_retCode = TA_HT_PHASOR(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outinphase_data + __pyx_v_lookback)), ((double *)(__pyx_v_outquadrature_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5646
 *         outquadrature_data[i] = NaN
 *     retCode = TA_HT_PHASOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outinphase_data+lookback) , <double *>(outquadrature_data+lookback) )
 *     _ta_check_success("TA_HT_PHASOR", retCode)             # <<<<<<<<<<<<<<
 *     return outinphase , outquadrature
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_HT_PHASOR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5646; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5647
 *     retCode = TA_HT_PHASOR( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outinphase_data+lookback) , <double *>(outquadrature_data+lookback) )
 *     _ta_check_success("TA_HT_PHASOR", retCode)
 *     return outinphase , outquadrature             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinphase));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outinphase));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outinphase));
  __Pyx_INCREF(((PyObject *)__pyx_v_outquadrature));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outquadrature));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outquadrature));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.HT_PHASOR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinphase);
  __Pyx_XDECREF((PyObject *)__pyx_v_outquadrature);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_185HT_SINE(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_184HT_SINE[] = " HT_SINE(real)\n\n    Hilbert Transform - SineWave (Cycle Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        sine\n        leadsine\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_185HT_SINE = {__Pyx_NAMESTR("HT_SINE"), (PyCFunction)__pyx_pw_5talib_4func_185HT_SINE, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_184HT_SINE)};
static PyObject *__pyx_pw_5talib_4func_185HT_SINE(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HT_SINE (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5651; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_184HT_SINE(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5651
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_SINE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_SINE(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_184HT_SINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outsine = 0;
  double *__pyx_v_outsine_data;
  PyArrayObject *__pyx_v_outleadsine = 0;
  double *__pyx_v_outleadsine_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HT_SINE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5672
 *         np.ndarray outleadsine
 *         double* outleadsine_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5672; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5673
 *         double* outleadsine_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5673; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5674
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5675
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5675; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5675; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5676
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5677
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5678
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5679
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5680
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5681
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5682
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5684
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_SINE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_127), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5684; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5684; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5685
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_HT_SINE_Lookback( )
 *     outsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5686
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_SINE_Lookback( )             # <<<<<<<<<<<<<<
 *     outsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outsine_data = <double*>outsine.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_HT_SINE_Lookback());

  /* "talib/func.pyx":5687
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_SINE_Lookback( )
 *     outsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outsine_data = <double*>outsine.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outsine = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5688
 *     lookback = begidx + TA_HT_SINE_Lookback( )
 *     outsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outsine_data = <double*>outsine.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outsine_data[i] = NaN
 */
  __pyx_v_outsine_data = ((double *)__pyx_v_outsine->data);

  /* "talib/func.pyx":5689
 *     outsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outsine_data = <double*>outsine.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outsine_data[i] = NaN
 *     outleadsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5690
 *     outsine_data = <double*>outsine.data
 *     for i from 0 <= i < min(lookback, length):
 *         outsine_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outleadsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outleadsine_data = <double*>outleadsine.data
 */
    (__pyx_v_outsine_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5691
 *     for i from 0 <= i < min(lookback, length):
 *         outsine_data[i] = NaN
 *     outleadsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outleadsine_data = <double*>outleadsine.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outleadsine = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5692
 *         outsine_data[i] = NaN
 *     outleadsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outleadsine_data = <double*>outleadsine.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outleadsine_data[i] = NaN
 */
  __pyx_v_outleadsine_data = ((double *)__pyx_v_outleadsine->data);

  /* "talib/func.pyx":5693
 *     outleadsine = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outleadsine_data = <double*>outleadsine.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outleadsine_data[i] = NaN
 *     retCode = TA_HT_SINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outsine_data+lookback) , <double *>(outleadsine_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5694
 *     outleadsine_data = <double*>outleadsine.data
 *     for i from 0 <= i < min(lookback, length):
 *         outleadsine_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_HT_SINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outsine_data+lookback) , <double *>(outleadsine_data+lookback) )
 *     _ta_check_success("TA_HT_SINE", retCode)
 */
    (__pyx_v_outleadsine_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5695
 *     for i from 0 <= i < min(lookback, length):
 *         outleadsine_data[i] = NaN
 *     retCode = TA_HT_SINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outsine_data+lookback) , <double *>(outleadsine_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_HT_SINE", retCode)
 *     return outsine , outleadsine
 */
  __pyx_v_retCode = TA_HT_SINE(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outsine_data + __pyx_v_lookback)), ((double *)(__pyx_v_outleadsine_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5696
 *         outleadsine_data[i] = NaN
 *     retCode = TA_HT_SINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outsine_data+lookback) , <double *>(outleadsine_data+lookback) )
 *     _ta_check_success("TA_HT_SINE", retCode)             # <<<<<<<<<<<<<<
 *     return outsine , outleadsine
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_HT_SINE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5697
 *     retCode = TA_HT_SINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outsine_data+lookback) , <double *>(outleadsine_data+lookback) )
 *     _ta_check_success("TA_HT_SINE", retCode)
 *     return outsine , outleadsine             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5697; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outsine));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outsine));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outsine));
  __Pyx_INCREF(((PyObject *)__pyx_v_outleadsine));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outleadsine));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outleadsine));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.HT_SINE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outsine);
  __Pyx_XDECREF((PyObject *)__pyx_v_outleadsine);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_187HT_TRENDLINE(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_186HT_TRENDLINE[] = " HT_TRENDLINE(real)\n\n    Hilbert Transform - Instantaneous Trendline (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_187HT_TRENDLINE = {__Pyx_NAMESTR("HT_TRENDLINE"), (PyCFunction)__pyx_pw_5talib_4func_187HT_TRENDLINE, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_186HT_TRENDLINE)};
static PyObject *__pyx_pw_5talib_4func_187HT_TRENDLINE(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HT_TRENDLINE (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_186HT_TRENDLINE(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5701
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_TRENDLINE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_TRENDLINE(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_186HT_TRENDLINE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HT_TRENDLINE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5719
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5720
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5720; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5721
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5722
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5723
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5724
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5725
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5726
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5727
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5728
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5729
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5731
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDLINE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_128), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5732
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_HT_TRENDLINE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5733
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDLINE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_HT_TRENDLINE_Lookback());

  /* "talib/func.pyx":5734
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDLINE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5735
 *     lookback = begidx + TA_HT_TRENDLINE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5736
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_TRENDLINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5737
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_HT_TRENDLINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_TRENDLINE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5738
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_TRENDLINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_HT_TRENDLINE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_HT_TRENDLINE(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5739
 *         outreal_data[i] = NaN
 *     retCode = TA_HT_TRENDLINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_TRENDLINE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_HT_TRENDLINE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5740
 *     retCode = TA_HT_TRENDLINE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_HT_TRENDLINE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.HT_TRENDLINE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_189HT_TRENDMODE(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_188HT_TRENDMODE[] = " HT_TRENDMODE(real)\n\n    Hilbert Transform - Trend vs Cycle Mode (Cycle Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_189HT_TRENDMODE = {__Pyx_NAMESTR("HT_TRENDMODE"), (PyCFunction)__pyx_pw_5talib_4func_189HT_TRENDMODE, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_188HT_TRENDMODE)};
static PyObject *__pyx_pw_5talib_4func_189HT_TRENDMODE(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("HT_TRENDMODE (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_188HT_TRENDMODE(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5744
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_TRENDMODE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_TRENDMODE(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_188HT_TRENDMODE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("HT_TRENDMODE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5762
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5763
 *         int* outinteger_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5763; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5764
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5765
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5766
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5767
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5768
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5769
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5770
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5771
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5772
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5774
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDMODE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_129), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5775
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_HT_TRENDMODE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5776
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDMODE_Lookback( )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_HT_TRENDMODE_Lookback());

  /* "talib/func.pyx":5777
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDMODE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5778
 *     lookback = begidx + TA_HT_TRENDMODE_Lookback( )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":5779
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_HT_TRENDMODE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5780
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_HT_TRENDMODE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_HT_TRENDMODE", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":5781
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_HT_TRENDMODE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_HT_TRENDMODE", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_HT_TRENDMODE(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5782
 *         outinteger_data[i] = 0
 *     retCode = TA_HT_TRENDMODE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_HT_TRENDMODE", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_HT_TRENDMODE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5782; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5783
 *     retCode = TA_HT_TRENDMODE( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_HT_TRENDMODE", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.HT_TRENDMODE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_191KAMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_190KAMA[] = " KAMA(real[, timeperiod=?])\n\n    Kaufman Adaptive Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_191KAMA = {__Pyx_NAMESTR("KAMA"), (PyCFunction)__pyx_pw_5talib_4func_191KAMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_190KAMA)};
static PyObject *__pyx_pw_5talib_4func_191KAMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("KAMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "KAMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("KAMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.KAMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_190KAMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5787
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def KAMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ KAMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_190KAMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("KAMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5807
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5807; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5808
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5809
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5810
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5811
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5812
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5813
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5814
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5815
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5816
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5817
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5819
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_KAMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_130), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5820
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_KAMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5821
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_KAMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_KAMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5822
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_KAMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5823
 *     lookback = begidx + TA_KAMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5824
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_KAMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5825
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_KAMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_KAMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5826
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_KAMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_KAMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_KAMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5827
 *         outreal_data[i] = NaN
 *     retCode = TA_KAMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_KAMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_KAMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5828
 *     retCode = TA_KAMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_KAMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.KAMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_193LINEARREG(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_192LINEARREG[] = " LINEARREG(real[, timeperiod=?])\n\n    Linear Regression (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_193LINEARREG = {__Pyx_NAMESTR("LINEARREG"), (PyCFunction)__pyx_pw_5talib_4func_193LINEARREG, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_192LINEARREG)};
static PyObject *__pyx_pw_5talib_4func_193LINEARREG(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("LINEARREG (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "LINEARREG") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("LINEARREG", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.LINEARREG", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_192LINEARREG(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5832
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_192LINEARREG(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("LINEARREG", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5852
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5853
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5854
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5855
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5855; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5855; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5856
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5857
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5858
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5859
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5860
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5861
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5862
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5864
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_131), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5865
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_LINEARREG_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5866
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_LINEARREG_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5867
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5867; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5867; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5868
 *     lookback = begidx + TA_LINEARREG_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5869
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5870
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_LINEARREG( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5871
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_LINEARREG", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_LINEARREG(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5872
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_LINEARREG, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5872; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5873
 *     retCode = TA_LINEARREG( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.LINEARREG", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_195LINEARREG_ANGLE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_194LINEARREG_ANGLE[] = " LINEARREG_ANGLE(real[, timeperiod=?])\n\n    Linear Regression Angle (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_195LINEARREG_ANGLE = {__Pyx_NAMESTR("LINEARREG_ANGLE"), (PyCFunction)__pyx_pw_5talib_4func_195LINEARREG_ANGLE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_194LINEARREG_ANGLE)};
static PyObject *__pyx_pw_5talib_4func_195LINEARREG_ANGLE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("LINEARREG_ANGLE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "LINEARREG_ANGLE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("LINEARREG_ANGLE", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.LINEARREG_ANGLE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_194LINEARREG_ANGLE(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5877
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_ANGLE( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_ANGLE(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_194LINEARREG_ANGLE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("LINEARREG_ANGLE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5897
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5898
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5898; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5899
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5900
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5900; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5900; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5901
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5902
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5903
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5904
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5905
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5906
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5907
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5909
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_ANGLE_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_132), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5909; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5909; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5910
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_LINEARREG_ANGLE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5911
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_ANGLE_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_LINEARREG_ANGLE_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5912
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_ANGLE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5912; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5912; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5913
 *     lookback = begidx + TA_LINEARREG_ANGLE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5914
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_ANGLE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5915
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_LINEARREG_ANGLE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_ANGLE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5916
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_ANGLE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_LINEARREG_ANGLE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_LINEARREG_ANGLE(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5917
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_ANGLE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_ANGLE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_LINEARREG_ANGLE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5918
 *     retCode = TA_LINEARREG_ANGLE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_ANGLE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.LINEARREG_ANGLE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_197LINEARREG_INTERCEPT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_196LINEARREG_INTERCEPT[] = " LINEARREG_INTERCEPT(real[, timeperiod=?])\n\n    Linear Regression Intercept (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_197LINEARREG_INTERCEPT = {__Pyx_NAMESTR("LINEARREG_INTERCEPT"), (PyCFunction)__pyx_pw_5talib_4func_197LINEARREG_INTERCEPT, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_196LINEARREG_INTERCEPT)};
static PyObject *__pyx_pw_5talib_4func_197LINEARREG_INTERCEPT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("LINEARREG_INTERCEPT (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "LINEARREG_INTERCEPT") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("LINEARREG_INTERCEPT", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.LINEARREG_INTERCEPT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_196LINEARREG_INTERCEPT(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5922
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_INTERCEPT( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_INTERCEPT(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_196LINEARREG_INTERCEPT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("LINEARREG_INTERCEPT", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5942
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5943
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5943; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5944
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5945
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5946
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5947
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5948
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5949
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5950
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5951
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5952
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5954
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_INTERCEPT_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_133), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":5955
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_LINEARREG_INTERCEPT_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":5956
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_INTERCEPT_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_LINEARREG_INTERCEPT_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":5957
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_INTERCEPT_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":5958
 *     lookback = begidx + TA_LINEARREG_INTERCEPT_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":5959
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_INTERCEPT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":5960
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_LINEARREG_INTERCEPT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_INTERCEPT", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":5961
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_INTERCEPT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_LINEARREG_INTERCEPT", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_LINEARREG_INTERCEPT(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":5962
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_INTERCEPT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_INTERCEPT", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s_134, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5962; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":5963
 *     retCode = TA_LINEARREG_INTERCEPT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_INTERCEPT", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.LINEARREG_INTERCEPT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_199LINEARREG_SLOPE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_198LINEARREG_SLOPE[] = " LINEARREG_SLOPE(real[, timeperiod=?])\n\n    Linear Regression Slope (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_199LINEARREG_SLOPE = {__Pyx_NAMESTR("LINEARREG_SLOPE"), (PyCFunction)__pyx_pw_5talib_4func_199LINEARREG_SLOPE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_198LINEARREG_SLOPE)};
static PyObject *__pyx_pw_5talib_4func_199LINEARREG_SLOPE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("LINEARREG_SLOPE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "LINEARREG_SLOPE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("LINEARREG_SLOPE", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.LINEARREG_SLOPE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_198LINEARREG_SLOPE(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":5967
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_SLOPE( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_SLOPE(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_198LINEARREG_SLOPE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("LINEARREG_SLOPE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":5987
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5988
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5988; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":5989
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":5990
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":5991
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":5992
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":5993
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":5994
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":5995
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":5996
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":5997
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":5999
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_SLOPE_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_135), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6000
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_LINEARREG_SLOPE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6001
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_SLOPE_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_LINEARREG_SLOPE_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6002
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_SLOPE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6003
 *     lookback = begidx + TA_LINEARREG_SLOPE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6004
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_SLOPE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6005
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_LINEARREG_SLOPE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_SLOPE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6006
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_SLOPE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_LINEARREG_SLOPE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_LINEARREG_SLOPE(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6007
 *         outreal_data[i] = NaN
 *     retCode = TA_LINEARREG_SLOPE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_SLOPE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_LINEARREG_SLOPE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6007; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6008
 *     retCode = TA_LINEARREG_SLOPE( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LINEARREG_SLOPE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.LINEARREG_SLOPE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_201LN(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_200LN[] = " LN(real)\n\n    Vector Log Natural (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_201LN = {__Pyx_NAMESTR("LN"), (PyCFunction)__pyx_pw_5talib_4func_201LN, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_200LN)};
static PyObject *__pyx_pw_5talib_4func_201LN(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("LN (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_200LN(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6012
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ LN(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_200LN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("LN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6030
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6031
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6031; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6032
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6033
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6033; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6033; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6034
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6035
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6036
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6037
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6038
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6039
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6040
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6042
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_136), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6042; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6042; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6043
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_LN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6044
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LN_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_LN_Lookback());

  /* "talib/func.pyx":6045
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6046
 *     lookback = begidx + TA_LN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6047
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_LN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6048
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_LN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LN", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6049
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_LN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_LN", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_LN(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6050
 *         outreal_data[i] = NaN
 *     retCode = TA_LN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LN", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_LN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6050; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6051
 *     retCode = TA_LN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LN", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.LN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_203LOG10(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_202LOG10[] = " LOG10(real)\n\n    Vector Log10 (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_203LOG10 = {__Pyx_NAMESTR("LOG10"), (PyCFunction)__pyx_pw_5talib_4func_203LOG10, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_202LOG10)};
static PyObject *__pyx_pw_5talib_4func_203LOG10(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("LOG10 (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_202LOG10(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6055
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LOG10( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ LOG10(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_202LOG10(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("LOG10", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6073
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6073; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6074
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6074; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6075
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6076
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6076; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6076; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6077
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6078
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6079
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6080
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6081
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6082
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6083
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6085
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LOG10_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_137), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6085; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6085; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6086
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_LOG10_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6087
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LOG10_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_LOG10_Lookback());

  /* "talib/func.pyx":6088
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LOG10_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6088; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6088; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6089
 *     lookback = begidx + TA_LOG10_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6090
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_LOG10( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6091
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_LOG10( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LOG10", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6092
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_LOG10( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_LOG10", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_LOG10(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6093
 *         outreal_data[i] = NaN
 *     retCode = TA_LOG10( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LOG10", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_LOG10, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6093; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6094
 *     retCode = TA_LOG10( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_LOG10", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.LOG10", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_205MA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_204MA[] = " MA(real[, timeperiod=?, matype=?])\n\n    Moving average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n        matype: 0 (Simple Moving Average)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_205MA = {__Pyx_NAMESTR("MA"), (PyCFunction)__pyx_pw_5talib_4func_205MA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_204MA)};
static PyObject *__pyx_pw_5talib_4func_205MA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  int __pyx_v_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,&__pyx_n_s__matype,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__matype);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_matype = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MA", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_204MA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod, __pyx_v_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6098
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MA( np.ndarray real not None , int timeperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ MA(real[, timeperiod=?, matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_204MA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, int __pyx_v_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6119
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6120
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6121
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6122
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6123
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6124
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6125
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6126
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6127
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6128
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6129
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6131
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MA_Lookback( timeperiod , matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_138), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6132
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MA_Lookback( timeperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6133
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MA_Lookback( timeperiod , matype )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MA_Lookback(__pyx_v_timeperiod, __pyx_v_matype));

  /* "talib/func.pyx":6134
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MA_Lookback( timeperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6135
 *     lookback = begidx + TA_MA_Lookback( timeperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6136
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6137
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6138
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, __pyx_v_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6139
 *         outreal_data[i] = NaN
 *     retCode = TA_MA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6140
 *     retCode = TA_MA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_207MACD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_206MACD[] = " MACD(real[, fastperiod=?, slowperiod=?, signalperiod=?])\n\n    Moving Average Convergence/Divergence (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        fastperiod: 12\n        slowperiod: 26\n        signalperiod: 9\n    Outputs:\n        macd\n        macdsignal\n        macdhist\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_207MACD = {__Pyx_NAMESTR("MACD"), (PyCFunction)__pyx_pw_5talib_4func_207MACD, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_206MACD)};
static PyObject *__pyx_pw_5talib_4func_207MACD(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_fastperiod;
  int __pyx_v_slowperiod;
  int __pyx_v_signalperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MACD (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__fastperiod,&__pyx_n_s__slowperiod,&__pyx_n_s__signalperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowperiod);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__signalperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MACD") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_fastperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_fastperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_slowperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_slowperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowperiod = ((int)-2147483648);
    }
    if (values[3]) {
      __pyx_v_signalperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_signalperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_signalperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MACD", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MACD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_206MACD(__pyx_self, __pyx_v_real, __pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_signalperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6144
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACD( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int signalperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MACD(real[, fastperiod=?, slowperiod=?, signalperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_206MACD(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_slowperiod, int __pyx_v_signalperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outmacd = 0;
  double *__pyx_v_outmacd_data;
  PyArrayObject *__pyx_v_outmacdsignal = 0;
  double *__pyx_v_outmacdsignal_data;
  PyArrayObject *__pyx_v_outmacdhist = 0;
  double *__pyx_v_outmacdhist_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MACD", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6172
 *         np.ndarray outmacdhist
 *         double* outmacdhist_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6173
 *         double* outmacdhist_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6174
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6175
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6176
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6177
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6178
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6179
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6180
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6181
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6182
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6184
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACD_Lookback( fastperiod , slowperiod , signalperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_139), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6185
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MACD_Lookback( fastperiod , slowperiod , signalperiod )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6186
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACD_Lookback( fastperiod , slowperiod , signalperiod )             # <<<<<<<<<<<<<<
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MACD_Lookback(__pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_signalperiod));

  /* "talib/func.pyx":6187
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACD_Lookback( fastperiod , slowperiod , signalperiod )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacd = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6188
 *     lookback = begidx + TA_MACD_Lookback( fastperiod , slowperiod , signalperiod )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN
 */
  __pyx_v_outmacd_data = ((double *)__pyx_v_outmacd->data);

  /* "talib/func.pyx":6189
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6190
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data
 */
    (__pyx_v_outmacd_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6191
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacdsignal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6192
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN
 */
  __pyx_v_outmacdsignal_data = ((double *)__pyx_v_outmacdsignal->data);

  /* "talib/func.pyx":6193
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6194
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data
 */
    (__pyx_v_outmacdsignal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6195
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6195; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6195; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacdhist = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6196
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN
 */
  __pyx_v_outmacdhist_data = ((double *)__pyx_v_outmacdhist->data);

  /* "talib/func.pyx":6197
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACD( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6198
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MACD( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACD", retCode)
 */
    (__pyx_v_outmacdhist_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6199
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACD( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MACD", retCode)
 *     return outmacd , outmacdsignal , outmacdhist
 */
  __pyx_v_retCode = TA_MACD(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_signalperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outmacd_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmacdsignal_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmacdhist_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6200
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACD( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACD", retCode)             # <<<<<<<<<<<<<<
 *     return outmacd , outmacdsignal , outmacdhist
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MACD, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6201
 *     retCode = TA_MACD( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACD", retCode)
 *     return outmacd , outmacdsignal , outmacdhist             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacd));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outmacd));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacd));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacdsignal));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outmacdsignal));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacdsignal));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacdhist));
  PyTuple_SET_ITEM(__pyx_t_2, 2, ((PyObject *)__pyx_v_outmacdhist));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacdhist));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MACD", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacd);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacdsignal);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacdhist);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_209MACDEXT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_208MACDEXT[] = " MACDEXT(real[, fastperiod=?, fastmatype=?, slowperiod=?, slowmatype=?, signalperiod=?, signalmatype=?])\n\n    MACD with controllable MA type (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        fastperiod: 12\n        fastmatype: 0\n        slowperiod: 26\n        slowmatype: 0\n        signalperiod: 9\n        signalmatype: 0\n    Outputs:\n        macd\n        macdsignal\n        macdhist\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_209MACDEXT = {__Pyx_NAMESTR("MACDEXT"), (PyCFunction)__pyx_pw_5talib_4func_209MACDEXT, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_208MACDEXT)};
static PyObject *__pyx_pw_5talib_4func_209MACDEXT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_fastperiod;
  int __pyx_v_fastmatype;
  int __pyx_v_slowperiod;
  int __pyx_v_slowmatype;
  int __pyx_v_signalperiod;
  int __pyx_v_signalmatype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MACDEXT (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__fastperiod,&__pyx_n_s__fastmatype,&__pyx_n_s__slowperiod,&__pyx_n_s__slowmatype,&__pyx_n_s__signalperiod,&__pyx_n_s__signalmatype,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastmatype);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowperiod);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowmatype);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__signalperiod);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__signalmatype);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MACDEXT") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_fastperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_fastperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_fastmatype = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_fastmatype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastmatype = ((int)0);
    }
    if (values[3]) {
      __pyx_v_slowperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_slowperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowperiod = ((int)-2147483648);
    }
    if (values[4]) {
      __pyx_v_slowmatype = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_slowmatype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowmatype = ((int)0);
    }
    if (values[5]) {
      __pyx_v_signalperiod = __Pyx_PyInt_AsInt(values[5]); if (unlikely((__pyx_v_signalperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_signalperiod = ((int)-2147483648);
    }
    if (values[6]) {
      __pyx_v_signalmatype = __Pyx_PyInt_AsInt(values[6]); if (unlikely((__pyx_v_signalmatype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_signalmatype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MACDEXT", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MACDEXT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_208MACDEXT(__pyx_self, __pyx_v_real, __pyx_v_fastperiod, __pyx_v_fastmatype, __pyx_v_slowperiod, __pyx_v_slowmatype, __pyx_v_signalperiod, __pyx_v_signalmatype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6205
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACDEXT( np.ndarray real not None , int fastperiod=-2**31 , int fastmatype=0 , int slowperiod=-2**31 , int slowmatype=0 , int signalperiod=-2**31 , int signalmatype=0 ):             # <<<<<<<<<<<<<<
 *     """ MACDEXT(real[, fastperiod=?, fastmatype=?, slowperiod=?, slowmatype=?, signalperiod=?, signalmatype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_208MACDEXT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_fastmatype, int __pyx_v_slowperiod, int __pyx_v_slowmatype, int __pyx_v_signalperiod, int __pyx_v_signalmatype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outmacd = 0;
  double *__pyx_v_outmacd_data;
  PyArrayObject *__pyx_v_outmacdsignal = 0;
  double *__pyx_v_outmacdsignal_data;
  PyArrayObject *__pyx_v_outmacdhist = 0;
  double *__pyx_v_outmacdhist_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MACDEXT", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6236
 *         np.ndarray outmacdhist
 *         double* outmacdhist_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6236; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6237
 *         double* outmacdhist_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6238
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6239
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6239; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6240
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6241
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6242
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6243
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6244
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6245
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6246
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6248
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDEXT_Lookback( fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_140), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6249
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MACDEXT_Lookback( fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6250
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDEXT_Lookback( fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype )             # <<<<<<<<<<<<<<
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MACDEXT_Lookback(__pyx_v_fastperiod, __pyx_v_fastmatype, __pyx_v_slowperiod, __pyx_v_slowmatype, __pyx_v_signalperiod, __pyx_v_signalmatype));

  /* "talib/func.pyx":6251
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDEXT_Lookback( fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacd = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6252
 *     lookback = begidx + TA_MACDEXT_Lookback( fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN
 */
  __pyx_v_outmacd_data = ((double *)__pyx_v_outmacd->data);

  /* "talib/func.pyx":6253
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6254
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data
 */
    (__pyx_v_outmacd_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6255
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacdsignal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6256
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN
 */
  __pyx_v_outmacdsignal_data = ((double *)__pyx_v_outmacdsignal->data);

  /* "talib/func.pyx":6257
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6258
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data
 */
    (__pyx_v_outmacdsignal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6259
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacdhist = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6260
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN
 */
  __pyx_v_outmacdhist_data = ((double *)__pyx_v_outmacdhist->data);

  /* "talib/func.pyx":6261
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACDEXT( 0 , endidx , <double *>(real_data+begidx) , fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6262
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MACDEXT( 0 , endidx , <double *>(real_data+begidx) , fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACDEXT", retCode)
 */
    (__pyx_v_outmacdhist_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6263
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACDEXT( 0 , endidx , <double *>(real_data+begidx) , fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MACDEXT", retCode)
 *     return outmacd , outmacdsignal , outmacdhist
 */
  __pyx_v_retCode = TA_MACDEXT(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_fastperiod, __pyx_v_fastmatype, __pyx_v_slowperiod, __pyx_v_slowmatype, __pyx_v_signalperiod, __pyx_v_signalmatype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outmacd_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmacdsignal_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmacdhist_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6264
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACDEXT( 0 , endidx , <double *>(real_data+begidx) , fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACDEXT", retCode)             # <<<<<<<<<<<<<<
 *     return outmacd , outmacdsignal , outmacdhist
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MACDEXT, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6265
 *     retCode = TA_MACDEXT( 0 , endidx , <double *>(real_data+begidx) , fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACDEXT", retCode)
 *     return outmacd , outmacdsignal , outmacdhist             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacd));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outmacd));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacd));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacdsignal));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outmacdsignal));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacdsignal));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacdhist));
  PyTuple_SET_ITEM(__pyx_t_2, 2, ((PyObject *)__pyx_v_outmacdhist));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacdhist));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MACDEXT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacd);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacdsignal);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacdhist);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_211MACDFIX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_210MACDFIX[] = " MACDFIX(real[, signalperiod=?])\n\n    Moving Average Convergence/Divergence Fix 12/26 (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        signalperiod: 9\n    Outputs:\n        macd\n        macdsignal\n        macdhist\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_211MACDFIX = {__Pyx_NAMESTR("MACDFIX"), (PyCFunction)__pyx_pw_5talib_4func_211MACDFIX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_210MACDFIX)};
static PyObject *__pyx_pw_5talib_4func_211MACDFIX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_signalperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MACDFIX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__signalperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__signalperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MACDFIX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_signalperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_signalperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_signalperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MACDFIX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MACDFIX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_210MACDFIX(__pyx_self, __pyx_v_real, __pyx_v_signalperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6269
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACDFIX( np.ndarray real not None , int signalperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MACDFIX(real[, signalperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_210MACDFIX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_signalperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outmacd = 0;
  double *__pyx_v_outmacd_data;
  PyArrayObject *__pyx_v_outmacdsignal = 0;
  double *__pyx_v_outmacdsignal_data;
  PyArrayObject *__pyx_v_outmacdhist = 0;
  double *__pyx_v_outmacdhist_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MACDFIX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6295
 *         np.ndarray outmacdhist
 *         double* outmacdhist_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6296
 *         double* outmacdhist_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6297
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6298
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6299
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6300
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6301
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6302
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6303
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6304
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6305
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6307
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDFIX_Lookback( signalperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_141), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6308
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MACDFIX_Lookback( signalperiod )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6309
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDFIX_Lookback( signalperiod )             # <<<<<<<<<<<<<<
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MACDFIX_Lookback(__pyx_v_signalperiod));

  /* "talib/func.pyx":6310
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDFIX_Lookback( signalperiod )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacd = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6311
 *     lookback = begidx + TA_MACDFIX_Lookback( signalperiod )
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN
 */
  __pyx_v_outmacd_data = ((double *)__pyx_v_outmacd->data);

  /* "talib/func.pyx":6312
 *     outmacd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6313
 *     outmacd_data = <double*>outmacd.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data
 */
    (__pyx_v_outmacd_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6314
 *     for i from 0 <= i < min(lookback, length):
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacdsignal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6315
 *         outmacd_data[i] = NaN
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN
 */
  __pyx_v_outmacdsignal_data = ((double *)__pyx_v_outmacdsignal->data);

  /* "talib/func.pyx":6316
 *     outmacdsignal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6317
 *     outmacdsignal_data = <double*>outmacdsignal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data
 */
    (__pyx_v_outmacdsignal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6318
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmacdhist = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6319
 *         outmacdsignal_data[i] = NaN
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN
 */
  __pyx_v_outmacdhist_data = ((double *)__pyx_v_outmacdhist->data);

  /* "talib/func.pyx":6320
 *     outmacdhist = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACDFIX( 0 , endidx , <double *>(real_data+begidx) , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6321
 *     outmacdhist_data = <double*>outmacdhist.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MACDFIX( 0 , endidx , <double *>(real_data+begidx) , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACDFIX", retCode)
 */
    (__pyx_v_outmacdhist_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6322
 *     for i from 0 <= i < min(lookback, length):
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACDFIX( 0 , endidx , <double *>(real_data+begidx) , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MACDFIX", retCode)
 *     return outmacd , outmacdsignal , outmacdhist
 */
  __pyx_v_retCode = TA_MACDFIX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_signalperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outmacd_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmacdsignal_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmacdhist_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6323
 *         outmacdhist_data[i] = NaN
 *     retCode = TA_MACDFIX( 0 , endidx , <double *>(real_data+begidx) , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACDFIX", retCode)             # <<<<<<<<<<<<<<
 *     return outmacd , outmacdsignal , outmacdhist
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MACDFIX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6324
 *     retCode = TA_MACDFIX( 0 , endidx , <double *>(real_data+begidx) , signalperiod , &outbegidx , &outnbelement , <double *>(outmacd_data+lookback) , <double *>(outmacdsignal_data+lookback) , <double *>(outmacdhist_data+lookback) )
 *     _ta_check_success("TA_MACDFIX", retCode)
 *     return outmacd , outmacdsignal , outmacdhist             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacd));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outmacd));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacd));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacdsignal));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outmacdsignal));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacdsignal));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmacdhist));
  PyTuple_SET_ITEM(__pyx_t_2, 2, ((PyObject *)__pyx_v_outmacdhist));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmacdhist));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MACDFIX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacd);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacdsignal);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmacdhist);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_213MAMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_212MAMA[] = " MAMA(real[, fastlimit=?, slowlimit=?])\n\n    MESA Adaptive Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        fastlimit: 0.5\n        slowlimit: 0.05\n    Outputs:\n        mama\n        fama\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_213MAMA = {__Pyx_NAMESTR("MAMA"), (PyCFunction)__pyx_pw_5talib_4func_213MAMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_212MAMA)};
static PyObject *__pyx_pw_5talib_4func_213MAMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  double __pyx_v_fastlimit;
  double __pyx_v_slowlimit;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MAMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__fastlimit,&__pyx_n_s__slowlimit,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastlimit);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowlimit);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MAMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_fastlimit = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_fastlimit == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":6328
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAMA( np.ndarray real not None , double fastlimit=-4e37 , double slowlimit=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ MAMA(real[, fastlimit=?, slowlimit=?])
 * 
 */
      __pyx_v_fastlimit = ((double)-4e37);
    }
    if (values[2]) {
      __pyx_v_slowlimit = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_slowlimit == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowlimit = ((double)-4e37);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MAMA", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MAMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_212MAMA(__pyx_self, __pyx_v_real, __pyx_v_fastlimit, __pyx_v_slowlimit);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_212MAMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, double __pyx_v_fastlimit, double __pyx_v_slowlimit) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outmama = 0;
  double *__pyx_v_outmama_data;
  PyArrayObject *__pyx_v_outfama = 0;
  double *__pyx_v_outfama_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MAMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6352
 *         np.ndarray outfama
 *         double* outfama_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6352; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6353
 *         double* outfama_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6354
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6355
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6355; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6356
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6357
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6358
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6359
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6360
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6361
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6362
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6364
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAMA_Lookback( fastlimit , slowlimit )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_142), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6365
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MAMA_Lookback( fastlimit , slowlimit )
 *     outmama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6366
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAMA_Lookback( fastlimit , slowlimit )             # <<<<<<<<<<<<<<
 *     outmama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmama_data = <double*>outmama.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MAMA_Lookback(__pyx_v_fastlimit, __pyx_v_slowlimit));

  /* "talib/func.pyx":6367
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAMA_Lookback( fastlimit , slowlimit )
 *     outmama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmama_data = <double*>outmama.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmama = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6368
 *     lookback = begidx + TA_MAMA_Lookback( fastlimit , slowlimit )
 *     outmama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmama_data = <double*>outmama.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmama_data[i] = NaN
 */
  __pyx_v_outmama_data = ((double *)__pyx_v_outmama->data);

  /* "talib/func.pyx":6369
 *     outmama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmama_data = <double*>outmama.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmama_data[i] = NaN
 *     outfama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6370
 *     outmama_data = <double*>outmama.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmama_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outfama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfama_data = <double*>outfama.data
 */
    (__pyx_v_outmama_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6371
 *     for i from 0 <= i < min(lookback, length):
 *         outmama_data[i] = NaN
 *     outfama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outfama_data = <double*>outfama.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outfama = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6372
 *         outmama_data[i] = NaN
 *     outfama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfama_data = <double*>outfama.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outfama_data[i] = NaN
 */
  __pyx_v_outfama_data = ((double *)__pyx_v_outfama->data);

  /* "talib/func.pyx":6373
 *     outfama = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfama_data = <double*>outfama.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outfama_data[i] = NaN
 *     retCode = TA_MAMA( 0 , endidx , <double *>(real_data+begidx) , fastlimit , slowlimit , &outbegidx , &outnbelement , <double *>(outmama_data+lookback) , <double *>(outfama_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6374
 *     outfama_data = <double*>outfama.data
 *     for i from 0 <= i < min(lookback, length):
 *         outfama_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MAMA( 0 , endidx , <double *>(real_data+begidx) , fastlimit , slowlimit , &outbegidx , &outnbelement , <double *>(outmama_data+lookback) , <double *>(outfama_data+lookback) )
 *     _ta_check_success("TA_MAMA", retCode)
 */
    (__pyx_v_outfama_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6375
 *     for i from 0 <= i < min(lookback, length):
 *         outfama_data[i] = NaN
 *     retCode = TA_MAMA( 0 , endidx , <double *>(real_data+begidx) , fastlimit , slowlimit , &outbegidx , &outnbelement , <double *>(outmama_data+lookback) , <double *>(outfama_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MAMA", retCode)
 *     return outmama , outfama
 */
  __pyx_v_retCode = TA_MAMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_fastlimit, __pyx_v_slowlimit, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outmama_data + __pyx_v_lookback)), ((double *)(__pyx_v_outfama_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6376
 *         outfama_data[i] = NaN
 *     retCode = TA_MAMA( 0 , endidx , <double *>(real_data+begidx) , fastlimit , slowlimit , &outbegidx , &outnbelement , <double *>(outmama_data+lookback) , <double *>(outfama_data+lookback) )
 *     _ta_check_success("TA_MAMA", retCode)             # <<<<<<<<<<<<<<
 *     return outmama , outfama
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MAMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6376; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6377
 *     retCode = TA_MAMA( 0 , endidx , <double *>(real_data+begidx) , fastlimit , slowlimit , &outbegidx , &outnbelement , <double *>(outmama_data+lookback) , <double *>(outfama_data+lookback) )
 *     _ta_check_success("TA_MAMA", retCode)
 *     return outmama , outfama             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outmama));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outmama));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmama));
  __Pyx_INCREF(((PyObject *)__pyx_v_outfama));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outfama));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outfama));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MAMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outmama);
  __Pyx_XDECREF((PyObject *)__pyx_v_outfama);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_215MAVP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_214MAVP[] = " MAVP(real, periods[, minperiod=?, maxperiod=?, matype=?])\n\n    Moving average with variable period (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n        periods: (any ndarray)\n    Parameters:\n        minperiod: 2\n        maxperiod: 30\n        matype: 0 (Simple Moving Average)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_215MAVP = {__Pyx_NAMESTR("MAVP"), (PyCFunction)__pyx_pw_5talib_4func_215MAVP, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_214MAVP)};
static PyObject *__pyx_pw_5talib_4func_215MAVP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  PyArrayObject *__pyx_v_periods = 0;
  int __pyx_v_minperiod;
  int __pyx_v_maxperiod;
  int __pyx_v_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MAVP (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__periods,&__pyx_n_s__minperiod,&__pyx_n_s__maxperiod,&__pyx_n_s__matype,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__periods)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MAVP", 0, 2, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__minperiod);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__maxperiod);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__matype);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MAVP") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    __pyx_v_periods = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_minperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_minperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_minperiod = ((int)-2147483648);
    }
    if (values[3]) {
      __pyx_v_maxperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_maxperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxperiod = ((int)-2147483648);
    }
    if (values[4]) {
      __pyx_v_matype = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MAVP", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MAVP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_periods), __pyx_ptype_5numpy_ndarray, 0, "periods", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_214MAVP(__pyx_self, __pyx_v_real, __pyx_v_periods, __pyx_v_minperiod, __pyx_v_maxperiod, __pyx_v_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6381
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAVP( np.ndarray real not None , np.ndarray periods not None , int minperiod=-2**31 , int maxperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ MAVP(real, periods[, minperiod=?, maxperiod=?, matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_214MAVP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, PyArrayObject *__pyx_v_periods, int __pyx_v_minperiod, int __pyx_v_maxperiod, int __pyx_v_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  double *__pyx_v_periods_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MAVP", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);
  __Pyx_INCREF((PyObject *)__pyx_v_periods);

  /* "talib/func.pyx":6405
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6406
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6407
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6408
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     assert PyArray_TYPE(periods) == np.NPY_DOUBLE, "periods is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6409
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(periods) == np.NPY_DOUBLE, "periods is not double"
 *     assert periods.ndim == 1, "periods has wrong dimensions"
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6410
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     assert PyArray_TYPE(periods) == np.NPY_DOUBLE, "periods is not double"             # <<<<<<<<<<<<<<
 *     assert periods.ndim == 1, "periods has wrong dimensions"
 *     if not (PyArray_FLAGS(periods) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_periods) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_143));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6410; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6411
 *     real_data = <double*>real.data
 *     assert PyArray_TYPE(periods) == np.NPY_DOUBLE, "periods is not double"
 *     assert periods.ndim == 1, "periods has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(periods) & np.NPY_C_CONTIGUOUS):
 *         periods = PyArray_GETCONTIGUOUS(periods)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_periods->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_144));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6412
 *     assert PyArray_TYPE(periods) == np.NPY_DOUBLE, "periods is not double"
 *     assert periods.ndim == 1, "periods has wrong dimensions"
 *     if not (PyArray_FLAGS(periods) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         periods = PyArray_GETCONTIGUOUS(periods)
 *     periods_data = <double*>periods.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_periods) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6413
 *     assert periods.ndim == 1, "periods has wrong dimensions"
 *     if not (PyArray_FLAGS(periods) & np.NPY_C_CONTIGUOUS):
 *         periods = PyArray_GETCONTIGUOUS(periods)             # <<<<<<<<<<<<<<
 *     periods_data = <double*>periods.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_periods); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_periods));
    __pyx_v_periods = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":6414
 *     if not (PyArray_FLAGS(periods) & np.NPY_C_CONTIGUOUS):
 *         periods = PyArray_GETCONTIGUOUS(periods)
 *     periods_data = <double*>periods.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_periods_data = ((double *)__pyx_v_periods->data);

  /* "talib/func.pyx":6415
 *         periods = PyArray_GETCONTIGUOUS(periods)
 *     periods_data = <double*>periods.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6416
 *     periods_data = <double*>periods.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6417
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6418
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6419
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6420
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":6422
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAVP_Lookback( minperiod , maxperiod , matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_145), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":6423
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MAVP_Lookback( minperiod , maxperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6424
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAVP_Lookback( minperiod , maxperiod , matype )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MAVP_Lookback(__pyx_v_minperiod, __pyx_v_maxperiod, __pyx_v_matype));

  /* "talib/func.pyx":6425
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAVP_Lookback( minperiod , maxperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6425; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6426
 *     lookback = begidx + TA_MAVP_Lookback( minperiod , maxperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6427
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MAVP( 0 , endidx , <double *>(real_data+begidx) , <double *>(periods_data+begidx) , minperiod , maxperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6428
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MAVP( 0 , endidx , <double *>(real_data+begidx) , <double *>(periods_data+begidx) , minperiod , maxperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MAVP", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6429
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MAVP( 0 , endidx , <double *>(real_data+begidx) , <double *>(periods_data+begidx) , minperiod , maxperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MAVP", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MAVP(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), ((double *)(__pyx_v_periods_data + __pyx_v_begidx)), __pyx_v_minperiod, __pyx_v_maxperiod, __pyx_v_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6430
 *         outreal_data[i] = NaN
 *     retCode = TA_MAVP( 0 , endidx , <double *>(real_data+begidx) , <double *>(periods_data+begidx) , minperiod , maxperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MAVP", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MAVP, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6431
 *     retCode = TA_MAVP( 0 , endidx , <double *>(real_data+begidx) , <double *>(periods_data+begidx) , minperiod , maxperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MAVP", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MAVP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XDECREF((PyObject *)__pyx_v_periods);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_217MAX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_216MAX[] = " MAX(real[, timeperiod=?])\n\n    Highest value over a specified period (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_217MAX = {__Pyx_NAMESTR("MAX"), (PyCFunction)__pyx_pw_5talib_4func_217MAX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_216MAX)};
static PyObject *__pyx_pw_5talib_4func_217MAX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MAX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MAX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MAX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MAX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_216MAX(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6435
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MAX(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_216MAX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MAX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6455
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6455; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6456
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6456; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6457
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6458
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6459
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6460
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6461
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6462
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6463
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6464
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6465
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6467
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_146), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6468
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MAX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6469
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MAX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6470
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6470; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6471
 *     lookback = begidx + TA_MAX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6472
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6473
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MAX", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6474
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MAX", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MAX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6475
 *         outreal_data[i] = NaN
 *     retCode = TA_MAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MAX", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MAX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6476
 *     retCode = TA_MAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MAX", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MAX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_219MAXINDEX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_218MAXINDEX[] = " MAXINDEX(real[, timeperiod=?])\n\n    Index of highest value over a specified period (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_219MAXINDEX = {__Pyx_NAMESTR("MAXINDEX"), (PyCFunction)__pyx_pw_5talib_4func_219MAXINDEX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_218MAXINDEX)};
static PyObject *__pyx_pw_5talib_4func_219MAXINDEX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MAXINDEX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MAXINDEX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MAXINDEX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MAXINDEX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_218MAXINDEX(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6480
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAXINDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MAXINDEX(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_218MAXINDEX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MAXINDEX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6500
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6500; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6501
 *         int* outinteger_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6502
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6503
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6504
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6505
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6506
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6507
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6508
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6509
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6510
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6512
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAXINDEX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_147), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6513
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MAXINDEX_Lookback( timeperiod )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6514
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAXINDEX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MAXINDEX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6515
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAXINDEX_Lookback( timeperiod )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6516
 *     lookback = begidx + TA_MAXINDEX_Lookback( timeperiod )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":6517
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_MAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6518
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_MAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_MAXINDEX", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":6519
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_MAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MAXINDEX", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_MAXINDEX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6520
 *         outinteger_data[i] = 0
 *     retCode = TA_MAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_MAXINDEX", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MAXINDEX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6520; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6521
 *     retCode = TA_MAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_MAXINDEX", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MAXINDEX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_221MEDPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_220MEDPRICE[] = " MEDPRICE(high, low)\n\n    Median Price (Price Transform)\n\n    Inputs:\n        prices: ['high', 'low']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_221MEDPRICE = {__Pyx_NAMESTR("MEDPRICE"), (PyCFunction)__pyx_pw_5talib_4func_221MEDPRICE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_220MEDPRICE)};
static PyObject *__pyx_pw_5talib_4func_221MEDPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MEDPRICE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MEDPRICE", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MEDPRICE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MEDPRICE", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MEDPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_220MEDPRICE(__pyx_self, __pyx_v_high, __pyx_v_low);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6525
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MEDPRICE( np.ndarray high not None , np.ndarray low not None ):             # <<<<<<<<<<<<<<
 *     """ MEDPRICE(high, low)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_220MEDPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MEDPRICE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":6544
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6544; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6545
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6546
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6547
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6548
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":6549
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6550
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6551
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6552
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":6553
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":6554
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":6555
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6556
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6557
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6558
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6559
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":6561
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MEDPRICE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_148), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":6562
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MEDPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6563
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MEDPRICE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MEDPRICE_Lookback());

  /* "talib/func.pyx":6564
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MEDPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6564; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6564; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6565
 *     lookback = begidx + TA_MEDPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6566
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MEDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6567
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MEDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MEDPRICE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6568
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MEDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MEDPRICE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MEDPRICE(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6569
 *         outreal_data[i] = NaN
 *     retCode = TA_MEDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MEDPRICE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MEDPRICE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6570
 *     retCode = TA_MEDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MEDPRICE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MEDPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_223MFI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_222MFI[] = " MFI(high, low, close, volume[, timeperiod=?])\n\n    Money Flow Index (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close', 'volume']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_223MFI = {__Pyx_NAMESTR("MFI"), (PyCFunction)__pyx_pw_5talib_4func_223MFI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_222MFI)};
static PyObject *__pyx_pw_5talib_4func_223MFI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyArrayObject *__pyx_v_volume = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MFI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__volume,&__pyx_n_s__timeperiod,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MFI", 0, 4, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MFI", 0, 4, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__volume)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MFI", 0, 4, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MFI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    __pyx_v_volume = ((PyArrayObject *)values[3]);
    if (values[4]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MFI", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MFI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_volume), __pyx_ptype_5numpy_ndarray, 0, "volume", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_222MFI(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_volume, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6574
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MFI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MFI(high, low, close, volume[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_222MFI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, PyArrayObject *__pyx_v_volume, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  double *__pyx_v_volume_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MFI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);
  __Pyx_INCREF((PyObject *)__pyx_v_volume);

  /* "talib/func.pyx":6597
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6598
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6599
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6600
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6601
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":6602
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6602; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6603
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6603; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6604
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6605
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6605; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6605; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":6606
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":6607
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6608
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6609
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6610
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":6611
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":6612
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"             # <<<<<<<<<<<<<<
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_volume) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_11));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6613
 *     close_data = <double*>close.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_volume->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_12));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6614
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_volume) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6615
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)             # <<<<<<<<<<<<<<
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_volume); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6615; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_volume));
    __pyx_v_volume = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "talib/func.pyx":6616
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_volume_data = ((double *)__pyx_v_volume->data);

  /* "talib/func.pyx":6617
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":6618
 *     volume_data = <double*>volume.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6619
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6620
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6621
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6622
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;
  }
  /*else*/ {

    /* "talib/func.pyx":6624
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MFI_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_149), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L8_break:;

  /* "talib/func.pyx":6625
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MFI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6626
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MFI_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MFI_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6627
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MFI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6628
 *     lookback = begidx + TA_MFI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6629
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MFI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6630
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MFI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MFI", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6631
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MFI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MFI", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MFI(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), ((double *)(__pyx_v_volume_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6632
 *         outreal_data[i] = NaN
 *     retCode = TA_MFI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MFI", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MFI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6632; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6633
 *     retCode = TA_MFI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , <double *>(volume_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MFI", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MFI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XDECREF((PyObject *)__pyx_v_volume);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_225MIDPOINT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_224MIDPOINT[] = " MIDPOINT(real[, timeperiod=?])\n\n    MidPoint over period (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_225MIDPOINT = {__Pyx_NAMESTR("MIDPOINT"), (PyCFunction)__pyx_pw_5talib_4func_225MIDPOINT, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_224MIDPOINT)};
static PyObject *__pyx_pw_5talib_4func_225MIDPOINT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MIDPOINT (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MIDPOINT") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MIDPOINT", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MIDPOINT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_224MIDPOINT(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6637
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIDPOINT( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIDPOINT(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_224MIDPOINT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MIDPOINT", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6657
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6657; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6658
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6659
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6660
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6661
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6662
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6663
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6664
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6665
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6666
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6667
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6669
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPOINT_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_150), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6670
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MIDPOINT_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6671
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPOINT_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MIDPOINT_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6672
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPOINT_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6672; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6672; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6673
 *     lookback = begidx + TA_MIDPOINT_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6674
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MIDPOINT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6675
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MIDPOINT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIDPOINT", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6676
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MIDPOINT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MIDPOINT", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MIDPOINT(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6677
 *         outreal_data[i] = NaN
 *     retCode = TA_MIDPOINT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIDPOINT", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MIDPOINT, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6677; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6678
 *     retCode = TA_MIDPOINT( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIDPOINT", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MIDPOINT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_227MIDPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_226MIDPRICE[] = " MIDPRICE(high, low[, timeperiod=?])\n\n    Midpoint Price over period (Overlap Studies)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_227MIDPRICE = {__Pyx_NAMESTR("MIDPRICE"), (PyCFunction)__pyx_pw_5talib_4func_227MIDPRICE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_226MIDPRICE)};
static PyObject *__pyx_pw_5talib_4func_227MIDPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MIDPRICE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MIDPRICE", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MIDPRICE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MIDPRICE", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MIDPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_226MIDPRICE(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6682
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIDPRICE( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIDPRICE(high, low[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_226MIDPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MIDPRICE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":6703
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6703; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6704
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6705
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6706
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6707
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":6708
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6708; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6709
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6709; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6710
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6711
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":6712
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":6713
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":6714
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6715
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6716
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6717
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6718
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":6720
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPRICE_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_151), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6720; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6720; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":6721
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MIDPRICE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6722
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPRICE_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MIDPRICE_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6723
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPRICE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6724
 *     lookback = begidx + TA_MIDPRICE_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6725
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MIDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6726
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MIDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIDPRICE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6727
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MIDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MIDPRICE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MIDPRICE(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6728
 *         outreal_data[i] = NaN
 *     retCode = TA_MIDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIDPRICE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MIDPRICE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6728; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6729
 *     retCode = TA_MIDPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIDPRICE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MIDPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_229MIN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_228MIN[] = " MIN(real[, timeperiod=?])\n\n    Lowest value over a specified period (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_229MIN = {__Pyx_NAMESTR("MIN"), (PyCFunction)__pyx_pw_5talib_4func_229MIN, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_228MIN)};
static PyObject *__pyx_pw_5talib_4func_229MIN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MIN (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MIN") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MIN", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MIN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_228MIN(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6733
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIN( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIN(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_228MIN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MIN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6753
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6754
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6755
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6756
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6756; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6757
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6758
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6759
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6760
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6761
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6762
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6763
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6765
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIN_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_152), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6766
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MIN_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6767
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIN_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MIN_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6768
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIN_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6768; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6768; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6769
 *     lookback = begidx + TA_MIN_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6770
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MIN( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6771
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MIN( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIN", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6772
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MIN( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MIN", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MIN(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6773
 *         outreal_data[i] = NaN
 *     retCode = TA_MIN( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIN", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MIN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6774
 *     retCode = TA_MIN( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MIN", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MIN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_231MININDEX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_230MININDEX[] = " MININDEX(real[, timeperiod=?])\n\n    Index of lowest value over a specified period (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        integer (values are -100, 0 or 100)\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_231MININDEX = {__Pyx_NAMESTR("MININDEX"), (PyCFunction)__pyx_pw_5talib_4func_231MININDEX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_230MININDEX)};
static PyObject *__pyx_pw_5talib_4func_231MININDEX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MININDEX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MININDEX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MININDEX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MININDEX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_230MININDEX(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6778
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MININDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MININDEX(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_230MININDEX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outinteger = 0;
  int *__pyx_v_outinteger_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MININDEX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6798
 *         np.ndarray outinteger
 *         int* outinteger_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6799
 *         int* outinteger_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6800
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6801
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6801; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6802
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6803
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6804
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6805
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6806
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6807
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6808
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6810
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MININDEX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_153), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6811
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MININDEX_Lookback( timeperiod )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6812
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MININDEX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MININDEX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6813
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MININDEX_Lookback( timeperiod )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outinteger = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6814
 *     lookback = begidx + TA_MININDEX_Lookback( timeperiod )
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 */
  __pyx_v_outinteger_data = ((int *)__pyx_v_outinteger->data);

  /* "talib/func.pyx":6815
 *     outinteger = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outinteger_data[i] = 0
 *     retCode = TA_MININDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6816
 *     outinteger_data = <int*>outinteger.data
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_MININDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_MININDEX", retCode)
 */
    (__pyx_v_outinteger_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":6817
 *     for i from 0 <= i < min(lookback, length):
 *         outinteger_data[i] = 0
 *     retCode = TA_MININDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MININDEX", retCode)
 *     return outinteger
 */
  __pyx_v_retCode = TA_MININDEX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outinteger_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6818
 *         outinteger_data[i] = 0
 *     retCode = TA_MININDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_MININDEX", retCode)             # <<<<<<<<<<<<<<
 *     return outinteger
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MININDEX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6818; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6819
 *     retCode = TA_MININDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outinteger_data+lookback) )
 *     _ta_check_success("TA_MININDEX", retCode)
 *     return outinteger             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outinteger));
  __pyx_r = ((PyObject *)__pyx_v_outinteger);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MININDEX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outinteger);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_233MINMAX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_232MINMAX[] = " MINMAX(real[, timeperiod=?])\n\n    Lowest and highest values over a specified period (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        min\n        max\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_233MINMAX = {__Pyx_NAMESTR("MINMAX"), (PyCFunction)__pyx_pw_5talib_4func_233MINMAX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_232MINMAX)};
static PyObject *__pyx_pw_5talib_4func_233MINMAX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MINMAX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MINMAX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MINMAX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MINMAX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_232MINMAX(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6823
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINMAX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINMAX(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_232MINMAX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outmin = 0;
  double *__pyx_v_outmin_data;
  PyArrayObject *__pyx_v_outmax = 0;
  double *__pyx_v_outmax_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MINMAX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6846
 *         np.ndarray outmax
 *         double* outmax_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6846; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6847
 *         double* outmax_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6847; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6848
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6849
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6850
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6851
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6852
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6853
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6854
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6855
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6856
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6858
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_154), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6859
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MINMAX_Lookback( timeperiod )
 *     outmin = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6860
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outmin = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmin_data = <double*>outmin.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MINMAX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6861
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAX_Lookback( timeperiod )
 *     outmin = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmin_data = <double*>outmin.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmin = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6862
 *     lookback = begidx + TA_MINMAX_Lookback( timeperiod )
 *     outmin = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmin_data = <double*>outmin.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmin_data[i] = NaN
 */
  __pyx_v_outmin_data = ((double *)__pyx_v_outmin->data);

  /* "talib/func.pyx":6863
 *     outmin = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmin_data = <double*>outmin.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmin_data[i] = NaN
 *     outmax = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6864
 *     outmin_data = <double*>outmin.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmin_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outmax = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmax_data = <double*>outmax.data
 */
    (__pyx_v_outmin_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6865
 *     for i from 0 <= i < min(lookback, length):
 *         outmin_data[i] = NaN
 *     outmax = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmax_data = <double*>outmax.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmax = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6866
 *         outmin_data[i] = NaN
 *     outmax = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmax_data = <double*>outmax.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmax_data[i] = NaN
 */
  __pyx_v_outmax_data = ((double *)__pyx_v_outmax->data);

  /* "talib/func.pyx":6867
 *     outmax = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outmax_data = <double*>outmax.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmax_data[i] = NaN
 *     retCode = TA_MINMAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outmin_data+lookback) , <double *>(outmax_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6868
 *     outmax_data = <double*>outmax.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmax_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MINMAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outmin_data+lookback) , <double *>(outmax_data+lookback) )
 *     _ta_check_success("TA_MINMAX", retCode)
 */
    (__pyx_v_outmax_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6869
 *     for i from 0 <= i < min(lookback, length):
 *         outmax_data[i] = NaN
 *     retCode = TA_MINMAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outmin_data+lookback) , <double *>(outmax_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MINMAX", retCode)
 *     return outmin , outmax
 */
  __pyx_v_retCode = TA_MINMAX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outmin_data + __pyx_v_lookback)), ((double *)(__pyx_v_outmax_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6870
 *         outmax_data[i] = NaN
 *     retCode = TA_MINMAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outmin_data+lookback) , <double *>(outmax_data+lookback) )
 *     _ta_check_success("TA_MINMAX", retCode)             # <<<<<<<<<<<<<<
 *     return outmin , outmax
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MINMAX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6871
 *     retCode = TA_MINMAX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outmin_data+lookback) , <double *>(outmax_data+lookback) )
 *     _ta_check_success("TA_MINMAX", retCode)
 *     return outmin , outmax             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outmin));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outmin));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmin));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmax));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outmax));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmax));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MINMAX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outmin);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmax);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_235MINMAXINDEX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_234MINMAXINDEX[] = " MINMAXINDEX(real[, timeperiod=?])\n\n    Indexes of lowest and highest values over a specified period (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        minidx\n        maxidx\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_235MINMAXINDEX = {__Pyx_NAMESTR("MINMAXINDEX"), (PyCFunction)__pyx_pw_5talib_4func_235MINMAXINDEX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_234MINMAXINDEX)};
static PyObject *__pyx_pw_5talib_4func_235MINMAXINDEX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MINMAXINDEX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MINMAXINDEX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MINMAXINDEX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MINMAXINDEX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_234MINMAXINDEX(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6875
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINMAXINDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINMAXINDEX(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_234MINMAXINDEX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outminidx = 0;
  int *__pyx_v_outminidx_data;
  PyArrayObject *__pyx_v_outmaxidx = 0;
  int *__pyx_v_outmaxidx_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MINMAXINDEX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":6898
 *         np.ndarray outmaxidx
 *         int* outmaxidx_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6898; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6899
 *         int* outmaxidx_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6899; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6900
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6901
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6902
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":6903
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":6904
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6905
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6906
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6907
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6908
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":6910
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAXINDEX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_155), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":6911
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MINMAXINDEX_Lookback( timeperiod )
 *     outminidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6912
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAXINDEX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outminidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outminidx_data = <int*>outminidx.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MINMAXINDEX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6913
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAXINDEX_Lookback( timeperiod )
 *     outminidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outminidx_data = <int*>outminidx.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outminidx = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6914
 *     lookback = begidx + TA_MINMAXINDEX_Lookback( timeperiod )
 *     outminidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outminidx_data = <int*>outminidx.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outminidx_data[i] = 0
 */
  __pyx_v_outminidx_data = ((int *)__pyx_v_outminidx->data);

  /* "talib/func.pyx":6915
 *     outminidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outminidx_data = <int*>outminidx.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outminidx_data[i] = 0
 *     outmaxidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6916
 *     outminidx_data = <int*>outminidx.data
 *     for i from 0 <= i < min(lookback, length):
 *         outminidx_data[i] = 0             # <<<<<<<<<<<<<<
 *     outmaxidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outmaxidx_data = <int*>outmaxidx.data
 */
    (__pyx_v_outminidx_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":6917
 *     for i from 0 <= i < min(lookback, length):
 *         outminidx_data[i] = 0
 *     outmaxidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outmaxidx_data = <int*>outmaxidx.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_INT32, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6917; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outmaxidx = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6918
 *         outminidx_data[i] = 0
 *     outmaxidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outmaxidx_data = <int*>outmaxidx.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outmaxidx_data[i] = 0
 */
  __pyx_v_outmaxidx_data = ((int *)__pyx_v_outmaxidx->data);

  /* "talib/func.pyx":6919
 *     outmaxidx = PyArray_EMPTY(1, &length, np.NPY_INT32, np.NPY_DEFAULT)
 *     outmaxidx_data = <int*>outmaxidx.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outmaxidx_data[i] = 0
 *     retCode = TA_MINMAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outminidx_data+lookback) , <int *>(outmaxidx_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6920
 *     outmaxidx_data = <int*>outmaxidx.data
 *     for i from 0 <= i < min(lookback, length):
 *         outmaxidx_data[i] = 0             # <<<<<<<<<<<<<<
 *     retCode = TA_MINMAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outminidx_data+lookback) , <int *>(outmaxidx_data+lookback) )
 *     _ta_check_success("TA_MINMAXINDEX", retCode)
 */
    (__pyx_v_outmaxidx_data[__pyx_v_i]) = 0;
  }

  /* "talib/func.pyx":6921
 *     for i from 0 <= i < min(lookback, length):
 *         outmaxidx_data[i] = 0
 *     retCode = TA_MINMAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outminidx_data+lookback) , <int *>(outmaxidx_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MINMAXINDEX", retCode)
 *     return outminidx , outmaxidx
 */
  __pyx_v_retCode = TA_MINMAXINDEX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((int *)(__pyx_v_outminidx_data + __pyx_v_lookback)), ((int *)(__pyx_v_outmaxidx_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6922
 *         outmaxidx_data[i] = 0
 *     retCode = TA_MINMAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outminidx_data+lookback) , <int *>(outmaxidx_data+lookback) )
 *     _ta_check_success("TA_MINMAXINDEX", retCode)             # <<<<<<<<<<<<<<
 *     return outminidx , outmaxidx
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MINMAXINDEX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6923
 *     retCode = TA_MINMAXINDEX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <int *>(outminidx_data+lookback) , <int *>(outmaxidx_data+lookback) )
 *     _ta_check_success("TA_MINMAXINDEX", retCode)
 *     return outminidx , outmaxidx             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6923; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outminidx));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outminidx));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outminidx));
  __Pyx_INCREF(((PyObject *)__pyx_v_outmaxidx));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outmaxidx));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outmaxidx));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MINMAXINDEX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outminidx);
  __Pyx_XDECREF((PyObject *)__pyx_v_outmaxidx);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_237MINUS_DI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_236MINUS_DI[] = " MINUS_DI(high, low, close[, timeperiod=?])\n\n    Minus Directional Indicator (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_237MINUS_DI = {__Pyx_NAMESTR("MINUS_DI"), (PyCFunction)__pyx_pw_5talib_4func_237MINUS_DI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_236MINUS_DI)};
static PyObject *__pyx_pw_5talib_4func_237MINUS_DI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MINUS_DI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MINUS_DI", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MINUS_DI", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MINUS_DI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MINUS_DI", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MINUS_DI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_236MINUS_DI(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6927
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINUS_DI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINUS_DI(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_236MINUS_DI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MINUS_DI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":6949
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6949; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6950
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6950; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6951
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6952
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6952; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":6953
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":6954
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6955
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6956
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6957
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6957; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":6958
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":6959
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6959; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6960
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":6961
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":6962
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6962; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6962; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":6963
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":6964
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":6965
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":6966
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":6967
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":6968
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":6969
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":6971
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DI_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_156), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":6972
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MINUS_DI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":6973
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DI_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MINUS_DI_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":6974
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":6975
 *     lookback = begidx + TA_MINUS_DI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":6976
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MINUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":6977
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MINUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MINUS_DI", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":6978
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MINUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MINUS_DI", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MINUS_DI(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":6979
 *         outreal_data[i] = NaN
 *     retCode = TA_MINUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MINUS_DI", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MINUS_DI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":6980
 *     retCode = TA_MINUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MINUS_DI", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MINUS_DI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_239MINUS_DM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_238MINUS_DM[] = " MINUS_DM(high, low[, timeperiod=?])\n\n    Minus Directional Movement (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_239MINUS_DM = {__Pyx_NAMESTR("MINUS_DM"), (PyCFunction)__pyx_pw_5talib_4func_239MINUS_DM, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_238MINUS_DM)};
static PyObject *__pyx_pw_5talib_4func_239MINUS_DM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MINUS_DM (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MINUS_DM", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MINUS_DM") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MINUS_DM", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MINUS_DM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_238MINUS_DM(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":6984
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINUS_DM( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINUS_DM(high, low[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_238MINUS_DM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MINUS_DM", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":7005
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7006
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7007
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7008
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7008; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7008; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7009
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7010
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7010; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7011
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7012
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7013
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7013; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7013; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7014
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7015
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7016
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7017
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7018
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7019
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7020
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":7022
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DM_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_157), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":7023
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MINUS_DM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7024
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DM_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MINUS_DM_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7025
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7026
 *     lookback = begidx + TA_MINUS_DM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7027
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MINUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7028
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MINUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MINUS_DM", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7029
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MINUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MINUS_DM", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MINUS_DM(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7030
 *         outreal_data[i] = NaN
 *     retCode = TA_MINUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MINUS_DM", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MINUS_DM, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7031
 *     retCode = TA_MINUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MINUS_DM", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MINUS_DM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_241MOM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_240MOM[] = " MOM(real[, timeperiod=?])\n\n    Momentum (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 10\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_241MOM = {__Pyx_NAMESTR("MOM"), (PyCFunction)__pyx_pw_5talib_4func_241MOM, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_240MOM)};
static PyObject *__pyx_pw_5talib_4func_241MOM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MOM (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MOM") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MOM", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MOM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_240MOM(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7035
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MOM( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MOM(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_240MOM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MOM", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7055
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7056
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7056; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7057
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7058
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7058; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7059
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7060
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7061
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7062
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7063
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7064
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7065
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7067
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MOM_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_158), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7068
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MOM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7069
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MOM_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MOM_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7070
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MOM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7070; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7071
 *     lookback = begidx + TA_MOM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7072
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MOM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7073
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MOM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MOM", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7074
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MOM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MOM", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MOM(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7075
 *         outreal_data[i] = NaN
 *     retCode = TA_MOM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MOM", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MOM, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7075; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7076
 *     retCode = TA_MOM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MOM", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MOM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_243MULT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_242MULT[] = " MULT(real0, real1)\n\n    Vector Arithmetic Mult (Math Operators)\n\n    Inputs:\n        real0: (any ndarray)\n        real1: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_243MULT = {__Pyx_NAMESTR("MULT"), (PyCFunction)__pyx_pw_5talib_4func_243MULT, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_242MULT)};
static PyObject *__pyx_pw_5talib_4func_243MULT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real0 = 0;
  PyArrayObject *__pyx_v_real1 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("MULT (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real0,&__pyx_n_s__real1,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real0)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("MULT", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "MULT") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_real0 = ((PyArrayObject *)values[0]);
    __pyx_v_real1 = ((PyArrayObject *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("MULT", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.MULT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real0), __pyx_ptype_5numpy_ndarray, 0, "real0", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real1), __pyx_ptype_5numpy_ndarray, 0, "real1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_242MULT(__pyx_self, __pyx_v_real0, __pyx_v_real1);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7080
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MULT( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ MULT(real0, real1)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_242MULT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real0_data;
  double *__pyx_v_real1_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MULT", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real0);
  __Pyx_INCREF((PyObject *)__pyx_v_real1);

  /* "talib/func.pyx":7100
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"             # <<<<<<<<<<<<<<
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real0) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_14));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7101
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real0->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_15));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7102
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real0) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7103
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)             # <<<<<<<<<<<<<<
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real0));
    __pyx_v_real0 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7104
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 */
  __pyx_v_real0_data = ((double *)__pyx_v_real0->data);

  /* "talib/func.pyx":7105
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"             # <<<<<<<<<<<<<<
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real1) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_16));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7105; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7106
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real1->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_17));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7107
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real1) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7108
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)             # <<<<<<<<<<<<<<
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real1));
    __pyx_v_real1 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7109
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data             # <<<<<<<<<<<<<<
 *     length = real0.shape[0]
 *     begidx = 0
 */
  __pyx_v_real1_data = ((double *)__pyx_v_real1->data);

  /* "talib/func.pyx":7110
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real0->dimensions[0]);

  /* "talib/func.pyx":7111
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7112
 *     length = real0.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real0_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7113
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real0_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7114
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7115
 *         if not isnan(real0_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":7117
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MULT_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_159), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":7118
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_MULT_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7119
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MULT_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_MULT_Lookback());

  /* "talib/func.pyx":7120
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MULT_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7121
 *     lookback = begidx + TA_MULT_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7122
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_MULT( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7123
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_MULT( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MULT", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7124
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_MULT( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_MULT", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_MULT(0, __pyx_v_endidx, ((double *)(__pyx_v_real0_data + __pyx_v_begidx)), ((double *)(__pyx_v_real1_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7125
 *         outreal_data[i] = NaN
 *     retCode = TA_MULT( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MULT", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_MULT, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7126
 *     retCode = TA_MULT( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_MULT", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.MULT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real0);
  __Pyx_XDECREF((PyObject *)__pyx_v_real1);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_245NATR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_244NATR[] = " NATR(high, low, close[, timeperiod=?])\n\n    Normalized Average True Range (Volatility Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_245NATR = {__Pyx_NAMESTR("NATR"), (PyCFunction)__pyx_pw_5talib_4func_245NATR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_244NATR)};
static PyObject *__pyx_pw_5talib_4func_245NATR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("NATR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("NATR", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("NATR", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "NATR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("NATR", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.NATR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_244NATR(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7130
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def NATR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ NATR(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_244NATR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("NATR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":7152
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7153
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7154
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7155
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7156
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7157
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7158
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7159
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7160
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7160; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7161
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7162
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7163
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7163; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7164
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7165
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":7166
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":7167
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7168
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7169
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7170
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7171
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7172
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":7174
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_NATR_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_160), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":7175
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_NATR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7176
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_NATR_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_NATR_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7177
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_NATR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7178
 *     lookback = begidx + TA_NATR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7179
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_NATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7180
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_NATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_NATR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7181
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_NATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_NATR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_NATR(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7182
 *         outreal_data[i] = NaN
 *     retCode = TA_NATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_NATR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_NATR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7183
 *     retCode = TA_NATR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_NATR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.NATR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_247OBV(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_246OBV[] = " OBV(real, volume)\n\n    On Balance Volume (Volume Indicators)\n\n    Inputs:\n        real: (any ndarray)\n        prices: ['volume']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_247OBV = {__Pyx_NAMESTR("OBV"), (PyCFunction)__pyx_pw_5talib_4func_247OBV, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_246OBV)};
static PyObject *__pyx_pw_5talib_4func_247OBV(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  PyArrayObject *__pyx_v_volume = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("OBV (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__volume,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__volume)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("OBV", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "OBV") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    __pyx_v_volume = ((PyArrayObject *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("OBV", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.OBV", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_volume), __pyx_ptype_5numpy_ndarray, 0, "volume", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_246OBV(__pyx_self, __pyx_v_real, __pyx_v_volume);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7187
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def OBV( np.ndarray real not None , np.ndarray volume not None ):             # <<<<<<<<<<<<<<
 *     """ OBV(real, volume)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_246OBV(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, PyArrayObject *__pyx_v_volume) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  double *__pyx_v_volume_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("OBV", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);
  __Pyx_INCREF((PyObject *)__pyx_v_volume);

  /* "talib/func.pyx":7207
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7208
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7209
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7210
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7211
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7212
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"             # <<<<<<<<<<<<<<
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_volume) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_11));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7212; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7213
 *     real_data = <double*>real.data
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_volume->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_12));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7214
 *     assert PyArray_TYPE(volume) == np.NPY_DOUBLE, "volume is not double"
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_volume) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7215
 *     assert volume.ndim == 1, "volume has wrong dimensions"
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)             # <<<<<<<<<<<<<<
 *     volume_data = <double*>volume.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_volume); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_volume));
    __pyx_v_volume = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7216
 *     if not (PyArray_FLAGS(volume) & np.NPY_C_CONTIGUOUS):
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_volume_data = ((double *)__pyx_v_volume->data);

  /* "talib/func.pyx":7217
 *         volume = PyArray_GETCONTIGUOUS(volume)
 *     volume_data = <double*>volume.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7218
 *     volume_data = <double*>volume.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7219
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7220
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7221
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7222
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":7224
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_OBV_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_161), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":7225
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_OBV_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7226
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_OBV_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_OBV_Lookback());

  /* "talib/func.pyx":7227
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_OBV_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7227; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7228
 *     lookback = begidx + TA_OBV_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7229
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_OBV( 0 , endidx , <double *>(real_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7230
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_OBV( 0 , endidx , <double *>(real_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_OBV", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7231
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_OBV( 0 , endidx , <double *>(real_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_OBV", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_OBV(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), ((double *)(__pyx_v_volume_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7232
 *         outreal_data[i] = NaN
 *     retCode = TA_OBV( 0 , endidx , <double *>(real_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_OBV", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_OBV, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7233
 *     retCode = TA_OBV( 0 , endidx , <double *>(real_data+begidx) , <double *>(volume_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_OBV", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.OBV", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XDECREF((PyObject *)__pyx_v_volume);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_249PLUS_DI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_248PLUS_DI[] = " PLUS_DI(high, low, close[, timeperiod=?])\n\n    Plus Directional Indicator (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_249PLUS_DI = {__Pyx_NAMESTR("PLUS_DI"), (PyCFunction)__pyx_pw_5talib_4func_249PLUS_DI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_248PLUS_DI)};
static PyObject *__pyx_pw_5talib_4func_249PLUS_DI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("PLUS_DI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("PLUS_DI", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("PLUS_DI", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "PLUS_DI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("PLUS_DI", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.PLUS_DI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_248PLUS_DI(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7237
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PLUS_DI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ PLUS_DI(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_248PLUS_DI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PLUS_DI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":7259
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7260
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7261
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7262
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7262; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7263
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7264
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7265
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7265; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7266
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7267
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7268
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7269
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7270
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7271
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7272
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":7273
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":7274
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7275
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7276
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7277
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7278
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7279
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":7281
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DI_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_162), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":7282
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_PLUS_DI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7283
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DI_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_PLUS_DI_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7284
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7285
 *     lookback = begidx + TA_PLUS_DI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7286
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_PLUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7287
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_PLUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PLUS_DI", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7288
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_PLUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_PLUS_DI", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_PLUS_DI(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7289
 *         outreal_data[i] = NaN
 *     retCode = TA_PLUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PLUS_DI", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_PLUS_DI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7290
 *     retCode = TA_PLUS_DI( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PLUS_DI", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.PLUS_DI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_251PLUS_DM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_250PLUS_DM[] = " PLUS_DM(high, low[, timeperiod=?])\n\n    Plus Directional Movement (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_251PLUS_DM = {__Pyx_NAMESTR("PLUS_DM"), (PyCFunction)__pyx_pw_5talib_4func_251PLUS_DM, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_250PLUS_DM)};
static PyObject *__pyx_pw_5talib_4func_251PLUS_DM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("PLUS_DM (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__timeperiod,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("PLUS_DM", 0, 2, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "PLUS_DM") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("PLUS_DM", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.PLUS_DM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_250PLUS_DM(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7294
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PLUS_DM( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ PLUS_DM(high, low[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_250PLUS_DM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PLUS_DM", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":7315
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7316
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7317
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7318
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7319
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7320
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7321
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7322
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7323
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7324
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7325
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7326
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7327
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7328
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7329
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7330
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":7332
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DM_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_163), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":7333
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_PLUS_DM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7334
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DM_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_PLUS_DM_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7335
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7336
 *     lookback = begidx + TA_PLUS_DM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7337
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_PLUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7338
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_PLUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PLUS_DM", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7339
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_PLUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_PLUS_DM", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_PLUS_DM(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7340
 *         outreal_data[i] = NaN
 *     retCode = TA_PLUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PLUS_DM", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_PLUS_DM, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7341
 *     retCode = TA_PLUS_DM( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PLUS_DM", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.PLUS_DM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_253PPO(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_252PPO[] = " PPO(real[, fastperiod=?, slowperiod=?, matype=?])\n\n    Percentage Price Oscillator (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        fastperiod: 12\n        slowperiod: 26\n        matype: 0 (Simple Moving Average)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_253PPO = {__Pyx_NAMESTR("PPO"), (PyCFunction)__pyx_pw_5talib_4func_253PPO, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_252PPO)};
static PyObject *__pyx_pw_5talib_4func_253PPO(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_fastperiod;
  int __pyx_v_slowperiod;
  int __pyx_v_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("PPO (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__fastperiod,&__pyx_n_s__slowperiod,&__pyx_n_s__matype,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowperiod);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__matype);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "PPO") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_fastperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_fastperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_slowperiod = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_slowperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowperiod = ((int)-2147483648);
    }
    if (values[3]) {
      __pyx_v_matype = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("PPO", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.PPO", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_252PPO(__pyx_self, __pyx_v_real, __pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7345
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PPO( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ PPO(real[, fastperiod=?, slowperiod=?, matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_252PPO(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_fastperiod, int __pyx_v_slowperiod, int __pyx_v_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PPO", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7367
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7367; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7368
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7368; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7369
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7370
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7371
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7372
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7373
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7374
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7375
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7376
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7377
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7379
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PPO_Lookback( fastperiod , slowperiod , matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_164), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7380
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_PPO_Lookback( fastperiod , slowperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7381
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PPO_Lookback( fastperiod , slowperiod , matype )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_PPO_Lookback(__pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_matype));

  /* "talib/func.pyx":7382
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PPO_Lookback( fastperiod , slowperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7382; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7383
 *     lookback = begidx + TA_PPO_Lookback( fastperiod , slowperiod , matype )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7384
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_PPO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7385
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_PPO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PPO", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7386
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_PPO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_PPO", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_PPO(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_fastperiod, __pyx_v_slowperiod, __pyx_v_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7387
 *         outreal_data[i] = NaN
 *     retCode = TA_PPO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PPO", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_PPO, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7388
 *     retCode = TA_PPO( 0 , endidx , <double *>(real_data+begidx) , fastperiod , slowperiod , matype , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_PPO", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.PPO", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_255ROC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_254ROC[] = " ROC(real[, timeperiod=?])\n\n    Rate of change : ((real/prevPrice)-1)*100 (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 10\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_255ROC = {__Pyx_NAMESTR("ROC"), (PyCFunction)__pyx_pw_5talib_4func_255ROC, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_254ROC)};
static PyObject *__pyx_pw_5talib_4func_255ROC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ROC (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ROC") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ROC", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ROC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_254ROC(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7392
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROC( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROC(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_254ROC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ROC", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7412
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7412; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7413
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7414
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7415
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7416
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7417
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7418
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7419
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7420
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7421
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7422
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7424
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROC_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_165), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7425
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ROC_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7426
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROC_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ROC_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7427
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROC_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7428
 *     lookback = begidx + TA_ROC_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7429
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ROC( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7430
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ROC( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROC", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7431
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ROC( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ROC", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ROC(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7432
 *         outreal_data[i] = NaN
 *     retCode = TA_ROC( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROC", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ROC, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7433
 *     retCode = TA_ROC( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROC", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ROC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_257ROCP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_256ROCP[] = " ROCP(real[, timeperiod=?])\n\n    Rate of change Percentage: (real-prevPrice)/prevPrice (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 10\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_257ROCP = {__Pyx_NAMESTR("ROCP"), (PyCFunction)__pyx_pw_5talib_4func_257ROCP, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_256ROCP)};
static PyObject *__pyx_pw_5talib_4func_257ROCP(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ROCP (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ROCP") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ROCP", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ROCP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_256ROCP(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7437
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCP( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCP(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_256ROCP(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ROCP", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7457
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7458
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7459
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7460
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7460; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7460; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7461
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7462
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7463
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7464
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7465
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7466
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7467
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7469
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCP_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_166), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7470
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ROCP_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7471
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCP_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ROCP_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7472
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCP_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7473
 *     lookback = begidx + TA_ROCP_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7474
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCP( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7475
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ROCP( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCP", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7476
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCP( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ROCP", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ROCP(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7477
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCP( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCP", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ROCP, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7477; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7478
 *     retCode = TA_ROCP( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCP", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ROCP", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_259ROCR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_258ROCR[] = " ROCR(real[, timeperiod=?])\n\n    Rate of change ratio: (real/prevPrice) (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 10\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_259ROCR = {__Pyx_NAMESTR("ROCR"), (PyCFunction)__pyx_pw_5talib_4func_259ROCR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_258ROCR)};
static PyObject *__pyx_pw_5talib_4func_259ROCR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ROCR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ROCR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ROCR", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ROCR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_258ROCR(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7482
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCR( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCR(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_258ROCR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ROCR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7502
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7503
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7504
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7505
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7506
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7507
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7508
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7509
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7510
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7511
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7512
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7514
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_167), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7515
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ROCR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7516
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ROCR_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7517
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7518
 *     lookback = begidx + TA_ROCR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7519
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7520
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ROCR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7521
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ROCR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ROCR(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7522
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ROCR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7522; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7523
 *     retCode = TA_ROCR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ROCR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_261ROCR100(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_260ROCR100[] = " ROCR100(real[, timeperiod=?])\n\n    Rate of change ratio 100 scale: (real/prevPrice)*100 (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 10\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_261ROCR100 = {__Pyx_NAMESTR("ROCR100"), (PyCFunction)__pyx_pw_5talib_4func_261ROCR100, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_260ROCR100)};
static PyObject *__pyx_pw_5talib_4func_261ROCR100(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ROCR100 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ROCR100") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ROCR100", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ROCR100", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_260ROCR100(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7527
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCR100( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCR100(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_260ROCR100(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ROCR100", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7547
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7548
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7549
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7550
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7550; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7551
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7552
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7553
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7554
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7555
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7556
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7557
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7559
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR100_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_168), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7559; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7559; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7560
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ROCR100_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7561
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR100_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ROCR100_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7562
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR100_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7562; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7562; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7563
 *     lookback = begidx + TA_ROCR100_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7564
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCR100( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7565
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ROCR100( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCR100", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7566
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCR100( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ROCR100", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ROCR100(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7567
 *         outreal_data[i] = NaN
 *     retCode = TA_ROCR100( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCR100", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ROCR100, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7567; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7568
 *     retCode = TA_ROCR100( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ROCR100", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ROCR100", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_263RSI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_262RSI[] = " RSI(real[, timeperiod=?])\n\n    Relative Strength Index (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_263RSI = {__Pyx_NAMESTR("RSI"), (PyCFunction)__pyx_pw_5talib_4func_263RSI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_262RSI)};
static PyObject *__pyx_pw_5talib_4func_263RSI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("RSI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "RSI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("RSI", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.RSI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_262RSI(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7572
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def RSI( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ RSI(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_262RSI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("RSI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7592
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7593
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7594
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7595
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7595; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7596
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7597
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7598
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7599
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7600
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7601
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7602
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7604
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_RSI_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_169), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7605
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_RSI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7606
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_RSI_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_RSI_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7607
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_RSI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7608
 *     lookback = begidx + TA_RSI_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7609
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_RSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7610
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_RSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_RSI", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7611
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_RSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_RSI", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_RSI(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7612
 *         outreal_data[i] = NaN
 *     retCode = TA_RSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_RSI", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_RSI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7612; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7613
 *     retCode = TA_RSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_RSI", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.RSI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_265SAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_264SAR[] = " SAR(high, low[, acceleration=?, maximum=?])\n\n    Parabolic SAR (Overlap Studies)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        acceleration: 0.02\n        maximum: 0.2\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_265SAR = {__Pyx_NAMESTR("SAR"), (PyCFunction)__pyx_pw_5talib_4func_265SAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_264SAR)};
static PyObject *__pyx_pw_5talib_4func_265SAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  double __pyx_v_acceleration;
  double __pyx_v_maximum;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__acceleration,&__pyx_n_s__maximum,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SAR", 0, 2, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__acceleration);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__maximum);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_acceleration = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_acceleration == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":7617
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SAR( np.ndarray high not None , np.ndarray low not None , double acceleration=0.02 , double maximum=0.2 ):             # <<<<<<<<<<<<<<
 *     """ SAR(high, low[, acceleration=?, maximum=?])
 * 
 */
      __pyx_v_acceleration = ((double)0.02);
    }
    if (values[3]) {
      __pyx_v_maximum = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_maximum == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maximum = ((double)0.2);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SAR", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.SAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_264SAR(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_acceleration, __pyx_v_maximum);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_264SAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, double __pyx_v_acceleration, double __pyx_v_maximum) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":7639
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7639; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7640
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7641
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7642
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7643
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7644
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7644; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7645
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7646
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7647
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7648
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7649
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7650
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7651
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7652
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7653
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7654
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":7656
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAR_Lookback( acceleration , maximum )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_170), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":7657
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SAR_Lookback( acceleration , maximum )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7658
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAR_Lookback( acceleration , maximum )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SAR_Lookback(__pyx_v_acceleration, __pyx_v_maximum));

  /* "talib/func.pyx":7659
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAR_Lookback( acceleration , maximum )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7660
 *     lookback = begidx + TA_SAR_Lookback( acceleration , maximum )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7661
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SAR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , acceleration , maximum , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7662
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SAR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , acceleration , maximum , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SAR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7663
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SAR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , acceleration , maximum , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SAR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SAR(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_acceleration, __pyx_v_maximum, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7664
 *         outreal_data[i] = NaN
 *     retCode = TA_SAR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , acceleration , maximum , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SAR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7664; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7665
 *     retCode = TA_SAR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , acceleration , maximum , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SAR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_267SAREXT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_266SAREXT[] = " SAREXT(high, low[, startvalue=?, offsetonreverse=?, accelerationinitlong=?, accelerationlong=?, accelerationmaxlong=?, accelerationinitshort=?, accelerationshort=?, accelerationmaxshort=?])\n\n    Parabolic SAR - Extended (Overlap Studies)\n\n    Inputs:\n        prices: ['high', 'low']\n    Parameters:\n        startvalue: 0\n        offsetonreverse: 0\n        accelerationinitlong: 0.02\n        accelerationlong: 0.02\n        accelerationmaxlong: 0.2\n        accelerationinitshort: 0.02\n        accelerationshort: 0.02\n        accelerationmaxshort: 0.2\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_267SAREXT = {__Pyx_NAMESTR("SAREXT"), (PyCFunction)__pyx_pw_5talib_4func_267SAREXT, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_266SAREXT)};
static PyObject *__pyx_pw_5talib_4func_267SAREXT(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  double __pyx_v_startvalue;
  double __pyx_v_offsetonreverse;
  double __pyx_v_accelerationinitlong;
  double __pyx_v_accelerationlong;
  double __pyx_v_accelerationmaxlong;
  double __pyx_v_accelerationinitshort;
  double __pyx_v_accelerationshort;
  double __pyx_v_accelerationmaxshort;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SAREXT (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__startvalue,&__pyx_n_s__offsetonreverse,&__pyx_n_s_171,&__pyx_n_s__accelerationlong,&__pyx_n_s__accelerationmaxlong,&__pyx_n_s_172,&__pyx_n_s__accelerationshort,&__pyx_n_s_173,0};
    PyObject* values[10] = {0,0,0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SAREXT", 0, 2, 10, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__startvalue);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__offsetonreverse);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_171);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__accelerationlong);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__accelerationmaxlong);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_172);
          if (value) { values[7] = value; kw_args--; }
        }
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__accelerationshort);
          if (value) { values[8] = value; kw_args--; }
        }
        case  9:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_173);
          if (value) { values[9] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SAREXT") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    if (values[2]) {
      __pyx_v_startvalue = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_startvalue == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":7669
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SAREXT( np.ndarray high not None , np.ndarray low not None , double startvalue=-4e37 , double offsetonreverse=-4e37 , double accelerationinitlong=-4e37 , double accelerationlong=-4e37 , double accelerationmaxlong=-4e37 , double accelerationinitshort=-4e37 , double accelerationshort=-4e37 , double accelerationmaxshort=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ SAREXT(high, low[, startvalue=?, offsetonreverse=?, accelerationinitlong=?, accelerationlong=?, accelerationmaxlong=?, accelerationinitshort=?, accelerationshort=?, accelerationmaxshort=?])
 * 
 */
      __pyx_v_startvalue = ((double)-4e37);
    }
    if (values[3]) {
      __pyx_v_offsetonreverse = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_offsetonreverse == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_offsetonreverse = ((double)-4e37);
    }
    if (values[4]) {
      __pyx_v_accelerationinitlong = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_accelerationinitlong == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accelerationinitlong = ((double)-4e37);
    }
    if (values[5]) {
      __pyx_v_accelerationlong = __pyx_PyFloat_AsDouble(values[5]); if (unlikely((__pyx_v_accelerationlong == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accelerationlong = ((double)-4e37);
    }
    if (values[6]) {
      __pyx_v_accelerationmaxlong = __pyx_PyFloat_AsDouble(values[6]); if (unlikely((__pyx_v_accelerationmaxlong == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accelerationmaxlong = ((double)-4e37);
    }
    if (values[7]) {
      __pyx_v_accelerationinitshort = __pyx_PyFloat_AsDouble(values[7]); if (unlikely((__pyx_v_accelerationinitshort == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accelerationinitshort = ((double)-4e37);
    }
    if (values[8]) {
      __pyx_v_accelerationshort = __pyx_PyFloat_AsDouble(values[8]); if (unlikely((__pyx_v_accelerationshort == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accelerationshort = ((double)-4e37);
    }
    if (values[9]) {
      __pyx_v_accelerationmaxshort = __pyx_PyFloat_AsDouble(values[9]); if (unlikely((__pyx_v_accelerationmaxshort == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accelerationmaxshort = ((double)-4e37);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SAREXT", 0, 2, 10, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.SAREXT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_266SAREXT(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_startvalue, __pyx_v_offsetonreverse, __pyx_v_accelerationinitlong, __pyx_v_accelerationlong, __pyx_v_accelerationmaxlong, __pyx_v_accelerationinitshort, __pyx_v_accelerationshort, __pyx_v_accelerationmaxshort);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_266SAREXT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, double __pyx_v_startvalue, double __pyx_v_offsetonreverse, double __pyx_v_accelerationinitlong, double __pyx_v_accelerationlong, double __pyx_v_accelerationmaxlong, double __pyx_v_accelerationinitshort, double __pyx_v_accelerationshort, double __pyx_v_accelerationmaxshort) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SAREXT", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);

  /* "talib/func.pyx":7697
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7697; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7698
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7699
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7700
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7701
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7702
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7703
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7703; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7704
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7705
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7706
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7707
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7708
 *     low_data = <double*>low.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7709
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7710
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7711
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7712
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":7714
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAREXT_Lookback( startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_174), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":7715
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SAREXT_Lookback( startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7716
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAREXT_Lookback( startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SAREXT_Lookback(__pyx_v_startvalue, __pyx_v_offsetonreverse, __pyx_v_accelerationinitlong, __pyx_v_accelerationlong, __pyx_v_accelerationmaxlong, __pyx_v_accelerationinitshort, __pyx_v_accelerationshort, __pyx_v_accelerationmaxshort));

  /* "talib/func.pyx":7717
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAREXT_Lookback( startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7717; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7717; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7718
 *     lookback = begidx + TA_SAREXT_Lookback( startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7719
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SAREXT( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7720
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SAREXT( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SAREXT", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7721
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SAREXT( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SAREXT", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SAREXT(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), __pyx_v_startvalue, __pyx_v_offsetonreverse, __pyx_v_accelerationinitlong, __pyx_v_accelerationlong, __pyx_v_accelerationmaxlong, __pyx_v_accelerationinitshort, __pyx_v_accelerationshort, __pyx_v_accelerationmaxshort, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7722
 *         outreal_data[i] = NaN
 *     retCode = TA_SAREXT( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SAREXT", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SAREXT, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7723
 *     retCode = TA_SAREXT( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SAREXT", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SAREXT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_269SIN(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_268SIN[] = " SIN(real)\n\n    Vector Trigonometric Sin (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_269SIN = {__Pyx_NAMESTR("SIN"), (PyCFunction)__pyx_pw_5talib_4func_269SIN, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_268SIN)};
static PyObject *__pyx_pw_5talib_4func_269SIN(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SIN (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_268SIN(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7727
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SIN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SIN(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_268SIN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SIN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7745
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7746
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7746; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7747
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7748
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7749
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7750
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7751
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7752
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7753
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7754
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7755
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7757
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SIN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_175), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7757; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7757; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7758
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SIN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7759
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SIN_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SIN_Lookback());

  /* "talib/func.pyx":7760
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SIN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7760; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7761
 *     lookback = begidx + TA_SIN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7762
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7763
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SIN", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7764
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SIN", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SIN(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7765
 *         outreal_data[i] = NaN
 *     retCode = TA_SIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SIN", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SIN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7766
 *     retCode = TA_SIN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SIN", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SIN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_271SINH(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_270SINH[] = " SINH(real)\n\n    Vector Trigonometric Sinh (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_271SINH = {__Pyx_NAMESTR("SINH"), (PyCFunction)__pyx_pw_5talib_4func_271SINH, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_270SINH)};
static PyObject *__pyx_pw_5talib_4func_271SINH(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SINH (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_270SINH(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7770
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SINH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SINH(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_270SINH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SINH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7788
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7788; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7789
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7789; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7790
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7791
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7792
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7793
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7794
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7795
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7796
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7797
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7798
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7800
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SINH_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_176), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7801
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SINH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7802
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SINH_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SINH_Lookback());

  /* "talib/func.pyx":7803
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SINH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7804
 *     lookback = begidx + TA_SINH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7805
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SINH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7806
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SINH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SINH", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7807
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SINH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SINH", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SINH(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7808
 *         outreal_data[i] = NaN
 *     retCode = TA_SINH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SINH", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SINH, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7809
 *     retCode = TA_SINH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SINH", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SINH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_273SMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_272SMA[] = " SMA(real[, timeperiod=?])\n\n    Simple Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_273SMA = {__Pyx_NAMESTR("SMA"), (PyCFunction)__pyx_pw_5talib_4func_273SMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_272SMA)};
static PyObject *__pyx_pw_5talib_4func_273SMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.SMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_272SMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7813
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ SMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_272SMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7833
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7834
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7835
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7836
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7837
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7838
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7839
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7840
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7841
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7842
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7843
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7845
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_177), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7846
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7847
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":7848
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7849
 *     lookback = begidx + TA_SMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7850
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7851
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7852
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7853
 *         outreal_data[i] = NaN
 *     retCode = TA_SMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7854
 *     retCode = TA_SMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_275SQRT(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_274SQRT[] = " SQRT(real)\n\n    Vector Square Root (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_275SQRT = {__Pyx_NAMESTR("SQRT"), (PyCFunction)__pyx_pw_5talib_4func_275SQRT, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_274SQRT)};
static PyObject *__pyx_pw_5talib_4func_275SQRT(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SQRT (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_274SQRT(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7858
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SQRT( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SQRT(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_274SQRT(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SQRT", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7876
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7877
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7878
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7879
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7879; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7879; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7880
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7881
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7882
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7883
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7884
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7885
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7886
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7888
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SQRT_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_178), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7888; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7888; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7889
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SQRT_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7890
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SQRT_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SQRT_Lookback());

  /* "talib/func.pyx":7891
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SQRT_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7891; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7891; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7892
 *     lookback = begidx + TA_SQRT_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7893
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SQRT( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7894
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SQRT( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SQRT", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7895
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SQRT( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SQRT", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SQRT(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7896
 *         outreal_data[i] = NaN
 *     retCode = TA_SQRT( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SQRT", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SQRT, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7897
 *     retCode = TA_SQRT( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SQRT", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SQRT", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_277STDDEV(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_276STDDEV[] = " STDDEV(real[, timeperiod=?, nbdev=?])\n\n    Standard Deviation (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 5\n        nbdev: 1\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_277STDDEV = {__Pyx_NAMESTR("STDDEV"), (PyCFunction)__pyx_pw_5talib_4func_277STDDEV, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_276STDDEV)};
static PyObject *__pyx_pw_5talib_4func_277STDDEV(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  double __pyx_v_nbdev;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("STDDEV (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,&__pyx_n_s__nbdev,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nbdev);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "STDDEV") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_nbdev = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_nbdev == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":7901
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STDDEV( np.ndarray real not None , int timeperiod=-2**31 , double nbdev=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ STDDEV(real[, timeperiod=?, nbdev=?])
 * 
 */
      __pyx_v_nbdev = ((double)-4e37);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("STDDEV", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.STDDEV", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_276STDDEV(__pyx_self, __pyx_v_real, __pyx_v_timeperiod, __pyx_v_nbdev);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_276STDDEV(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_nbdev) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("STDDEV", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":7922
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7923
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7923; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7924
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7925
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7925; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7925; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7926
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":7927
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":7928
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7929
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7930
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7931
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7932
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":7934
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STDDEV_Lookback( timeperiod , nbdev )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_179), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":7935
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_STDDEV_Lookback( timeperiod , nbdev )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":7936
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STDDEV_Lookback( timeperiod , nbdev )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_STDDEV_Lookback(__pyx_v_timeperiod, __pyx_v_nbdev));

  /* "talib/func.pyx":7937
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STDDEV_Lookback( timeperiod , nbdev )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7937; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7937; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":7938
 *     lookback = begidx + TA_STDDEV_Lookback( timeperiod , nbdev )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":7939
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_STDDEV( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":7940
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_STDDEV( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_STDDEV", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":7941
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_STDDEV( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_STDDEV", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_STDDEV(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, __pyx_v_nbdev, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":7942
 *         outreal_data[i] = NaN
 *     retCode = TA_STDDEV( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_STDDEV", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_STDDEV, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7942; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":7943
 *     retCode = TA_STDDEV( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_STDDEV", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.STDDEV", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_279STOCH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_278STOCH[] = " STOCH(high, low, close[, fastk_period=?, slowk_period=?, slowk_matype=?, slowd_period=?, slowd_matype=?])\n\n    Stochastic (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        fastk_period: 5\n        slowk_period: 3\n        slowk_matype: 0\n        slowd_period: 3\n        slowd_matype: 0\n    Outputs:\n        slowk\n        slowd\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_279STOCH = {__Pyx_NAMESTR("STOCH"), (PyCFunction)__pyx_pw_5talib_4func_279STOCH, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_278STOCH)};
static PyObject *__pyx_pw_5talib_4func_279STOCH(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_fastk_period;
  int __pyx_v_slowk_period;
  int __pyx_v_slowk_matype;
  int __pyx_v_slowd_period;
  int __pyx_v_slowd_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("STOCH (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__fastk_period,&__pyx_n_s__slowk_period,&__pyx_n_s__slowk_matype,&__pyx_n_s__slowd_period,&__pyx_n_s__slowd_matype,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("STOCH", 0, 3, 8, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("STOCH", 0, 3, 8, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastk_period);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowk_period);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowk_matype);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowd_period);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__slowd_matype);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "STOCH") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_fastk_period = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_fastk_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastk_period = ((int)-2147483648);
    }
    if (values[4]) {
      __pyx_v_slowk_period = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_slowk_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowk_period = ((int)-2147483648);
    }
    if (values[5]) {
      __pyx_v_slowk_matype = __Pyx_PyInt_AsInt(values[5]); if (unlikely((__pyx_v_slowk_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowk_matype = ((int)0);
    }
    if (values[6]) {
      __pyx_v_slowd_period = __Pyx_PyInt_AsInt(values[6]); if (unlikely((__pyx_v_slowd_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowd_period = ((int)-2147483648);
    }
    if (values[7]) {
      __pyx_v_slowd_matype = __Pyx_PyInt_AsInt(values[7]); if (unlikely((__pyx_v_slowd_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_slowd_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("STOCH", 0, 3, 8, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.STOCH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_278STOCH(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_fastk_period, __pyx_v_slowk_period, __pyx_v_slowk_matype, __pyx_v_slowd_period, __pyx_v_slowd_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":7947
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCH( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int fastk_period=-2**31 , int slowk_period=-2**31 , int slowk_matype=0 , int slowd_period=-2**31 , int slowd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCH(high, low, close[, fastk_period=?, slowk_period=?, slowk_matype=?, slowd_period=?, slowd_matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_278STOCH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_fastk_period, int __pyx_v_slowk_period, int __pyx_v_slowk_matype, int __pyx_v_slowd_period, int __pyx_v_slowd_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outslowk = 0;
  double *__pyx_v_outslowk_data;
  PyArrayObject *__pyx_v_outslowd = 0;
  double *__pyx_v_outslowd_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("STOCH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":7976
 *         np.ndarray outslowd
 *         double* outslowd_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7976; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7977
 *         double* outslowd_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7978
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7979
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7979; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":7980
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":7981
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7981; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7982
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7982; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7983
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7984
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":7985
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":7986
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7986; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7987
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":7988
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":7989
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7989; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7989; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":7990
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":7991
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":7992
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":7993
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":7994
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":7995
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":7996
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":7998
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCH_Lookback( fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_180), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7998; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7998; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":7999
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_STOCH_Lookback( fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype )
 *     outslowk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8000
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCH_Lookback( fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype )             # <<<<<<<<<<<<<<
 *     outslowk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outslowk_data = <double*>outslowk.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_STOCH_Lookback(__pyx_v_fastk_period, __pyx_v_slowk_period, __pyx_v_slowk_matype, __pyx_v_slowd_period, __pyx_v_slowd_matype));

  /* "talib/func.pyx":8001
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCH_Lookback( fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype )
 *     outslowk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outslowk_data = <double*>outslowk.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8001; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8001; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outslowk = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8002
 *     lookback = begidx + TA_STOCH_Lookback( fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype )
 *     outslowk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outslowk_data = <double*>outslowk.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outslowk_data[i] = NaN
 */
  __pyx_v_outslowk_data = ((double *)__pyx_v_outslowk->data);

  /* "talib/func.pyx":8003
 *     outslowk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outslowk_data = <double*>outslowk.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outslowk_data[i] = NaN
 *     outslowd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8004
 *     outslowk_data = <double*>outslowk.data
 *     for i from 0 <= i < min(lookback, length):
 *         outslowk_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outslowd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outslowd_data = <double*>outslowd.data
 */
    (__pyx_v_outslowk_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8005
 *     for i from 0 <= i < min(lookback, length):
 *         outslowk_data[i] = NaN
 *     outslowd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outslowd_data = <double*>outslowd.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outslowd = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8006
 *         outslowk_data[i] = NaN
 *     outslowd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outslowd_data = <double*>outslowd.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outslowd_data[i] = NaN
 */
  __pyx_v_outslowd_data = ((double *)__pyx_v_outslowd->data);

  /* "talib/func.pyx":8007
 *     outslowd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outslowd_data = <double*>outslowd.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outslowd_data[i] = NaN
 *     retCode = TA_STOCH( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype , &outbegidx , &outnbelement , <double *>(outslowk_data+lookback) , <double *>(outslowd_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8008
 *     outslowd_data = <double*>outslowd.data
 *     for i from 0 <= i < min(lookback, length):
 *         outslowd_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_STOCH( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype , &outbegidx , &outnbelement , <double *>(outslowk_data+lookback) , <double *>(outslowd_data+lookback) )
 *     _ta_check_success("TA_STOCH", retCode)
 */
    (__pyx_v_outslowd_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8009
 *     for i from 0 <= i < min(lookback, length):
 *         outslowd_data[i] = NaN
 *     retCode = TA_STOCH( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype , &outbegidx , &outnbelement , <double *>(outslowk_data+lookback) , <double *>(outslowd_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_STOCH", retCode)
 *     return outslowk , outslowd
 */
  __pyx_v_retCode = TA_STOCH(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_fastk_period, __pyx_v_slowk_period, __pyx_v_slowk_matype, __pyx_v_slowd_period, __pyx_v_slowd_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outslowk_data + __pyx_v_lookback)), ((double *)(__pyx_v_outslowd_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8010
 *         outslowd_data[i] = NaN
 *     retCode = TA_STOCH( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype , &outbegidx , &outnbelement , <double *>(outslowk_data+lookback) , <double *>(outslowd_data+lookback) )
 *     _ta_check_success("TA_STOCH", retCode)             # <<<<<<<<<<<<<<
 *     return outslowk , outslowd
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_STOCH, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8010; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8011
 *     retCode = TA_STOCH( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype , &outbegidx , &outnbelement , <double *>(outslowk_data+lookback) , <double *>(outslowd_data+lookback) )
 *     _ta_check_success("TA_STOCH", retCode)
 *     return outslowk , outslowd             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8011; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outslowk));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outslowk));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outslowk));
  __Pyx_INCREF(((PyObject *)__pyx_v_outslowd));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outslowd));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outslowd));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.STOCH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outslowk);
  __Pyx_XDECREF((PyObject *)__pyx_v_outslowd);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_281STOCHF(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_280STOCHF[] = " STOCHF(high, low, close[, fastk_period=?, fastd_period=?, fastd_matype=?])\n\n    Stochastic Fast (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        fastk_period: 5\n        fastd_period: 3\n        fastd_matype: 0\n    Outputs:\n        fastk\n        fastd\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_281STOCHF = {__Pyx_NAMESTR("STOCHF"), (PyCFunction)__pyx_pw_5talib_4func_281STOCHF, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_280STOCHF)};
static PyObject *__pyx_pw_5talib_4func_281STOCHF(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_fastk_period;
  int __pyx_v_fastd_period;
  int __pyx_v_fastd_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("STOCHF (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__fastk_period,&__pyx_n_s__fastd_period,&__pyx_n_s__fastd_matype,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("STOCHF", 0, 3, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("STOCHF", 0, 3, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastk_period);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastd_period);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastd_matype);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "STOCHF") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_fastk_period = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_fastk_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastk_period = ((int)-2147483648);
    }
    if (values[4]) {
      __pyx_v_fastd_period = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_fastd_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastd_period = ((int)-2147483648);
    }
    if (values[5]) {
      __pyx_v_fastd_matype = __Pyx_PyInt_AsInt(values[5]); if (unlikely((__pyx_v_fastd_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastd_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("STOCHF", 0, 3, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.STOCHF", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_280STOCHF(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_fastk_period, __pyx_v_fastd_period, __pyx_v_fastd_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8015
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCHF( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int fastk_period=-2**31 , int fastd_period=-2**31 , int fastd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCHF(high, low, close[, fastk_period=?, fastd_period=?, fastd_matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_280STOCHF(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_fastk_period, int __pyx_v_fastd_period, int __pyx_v_fastd_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outfastk = 0;
  double *__pyx_v_outfastk_data;
  PyArrayObject *__pyx_v_outfastd = 0;
  double *__pyx_v_outfastd_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("STOCHF", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":8042
 *         np.ndarray outfastd
 *         double* outfastd_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8042; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8043
 *         double* outfastd_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8043; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8044
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8045
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8045; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8046
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":8047
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8047; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8048
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8049
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8050
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8050; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8050; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8051
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":8052
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8052; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8053
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8054
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8055
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":8056
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":8057
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":8058
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8059
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8060
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8061
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8062
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":8064
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHF_Lookback( fastk_period , fastd_period , fastd_matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_181), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":8065
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_STOCHF_Lookback( fastk_period , fastd_period , fastd_matype )
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8066
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHF_Lookback( fastk_period , fastd_period , fastd_matype )             # <<<<<<<<<<<<<<
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastk_data = <double*>outfastk.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_STOCHF_Lookback(__pyx_v_fastk_period, __pyx_v_fastd_period, __pyx_v_fastd_matype));

  /* "talib/func.pyx":8067
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHF_Lookback( fastk_period , fastd_period , fastd_matype )
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outfastk_data = <double*>outfastk.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outfastk = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8068
 *     lookback = begidx + TA_STOCHF_Lookback( fastk_period , fastd_period , fastd_matype )
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastk_data = <double*>outfastk.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outfastk_data[i] = NaN
 */
  __pyx_v_outfastk_data = ((double *)__pyx_v_outfastk->data);

  /* "talib/func.pyx":8069
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastk_data = <double*>outfastk.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outfastk_data[i] = NaN
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8070
 *     outfastk_data = <double*>outfastk.data
 *     for i from 0 <= i < min(lookback, length):
 *         outfastk_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastd_data = <double*>outfastd.data
 */
    (__pyx_v_outfastk_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8071
 *     for i from 0 <= i < min(lookback, length):
 *         outfastk_data[i] = NaN
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outfastd_data = <double*>outfastd.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8071; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outfastd = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8072
 *         outfastk_data[i] = NaN
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastd_data = <double*>outfastd.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outfastd_data[i] = NaN
 */
  __pyx_v_outfastd_data = ((double *)__pyx_v_outfastd->data);

  /* "talib/func.pyx":8073
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastd_data = <double*>outfastd.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outfastd_data[i] = NaN
 *     retCode = TA_STOCHF( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8074
 *     outfastd_data = <double*>outfastd.data
 *     for i from 0 <= i < min(lookback, length):
 *         outfastd_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_STOCHF( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 *     _ta_check_success("TA_STOCHF", retCode)
 */
    (__pyx_v_outfastd_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8075
 *     for i from 0 <= i < min(lookback, length):
 *         outfastd_data[i] = NaN
 *     retCode = TA_STOCHF( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_STOCHF", retCode)
 *     return outfastk , outfastd
 */
  __pyx_v_retCode = TA_STOCHF(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_fastk_period, __pyx_v_fastd_period, __pyx_v_fastd_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outfastk_data + __pyx_v_lookback)), ((double *)(__pyx_v_outfastd_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8076
 *         outfastd_data[i] = NaN
 *     retCode = TA_STOCHF( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 *     _ta_check_success("TA_STOCHF", retCode)             # <<<<<<<<<<<<<<
 *     return outfastk , outfastd
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_STOCHF, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8076; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8077
 *     retCode = TA_STOCHF( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 *     _ta_check_success("TA_STOCHF", retCode)
 *     return outfastk , outfastd             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8077; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outfastk));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outfastk));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outfastk));
  __Pyx_INCREF(((PyObject *)__pyx_v_outfastd));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outfastd));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outfastd));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.STOCHF", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outfastk);
  __Pyx_XDECREF((PyObject *)__pyx_v_outfastd);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_283STOCHRSI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_282STOCHRSI[] = " STOCHRSI(real[, timeperiod=?, fastk_period=?, fastd_period=?, fastd_matype=?])\n\n    Stochastic Relative Strength Index (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n        fastk_period: 5\n        fastd_period: 3\n        fastd_matype: 0\n    Outputs:\n        fastk\n        fastd\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_283STOCHRSI = {__Pyx_NAMESTR("STOCHRSI"), (PyCFunction)__pyx_pw_5talib_4func_283STOCHRSI, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_282STOCHRSI)};
static PyObject *__pyx_pw_5talib_4func_283STOCHRSI(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  int __pyx_v_fastk_period;
  int __pyx_v_fastd_period;
  int __pyx_v_fastd_matype;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("STOCHRSI (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,&__pyx_n_s__fastk_period,&__pyx_n_s__fastd_period,&__pyx_n_s__fastd_matype,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastk_period);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastd_period);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__fastd_matype);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "STOCHRSI") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_fastk_period = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_fastk_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastk_period = ((int)-2147483648);
    }
    if (values[3]) {
      __pyx_v_fastd_period = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_fastd_period == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastd_period = ((int)-2147483648);
    }
    if (values[4]) {
      __pyx_v_fastd_matype = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_fastd_matype == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_fastd_matype = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("STOCHRSI", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.STOCHRSI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_282STOCHRSI(__pyx_self, __pyx_v_real, __pyx_v_timeperiod, __pyx_v_fastk_period, __pyx_v_fastd_period, __pyx_v_fastd_matype);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8081
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCHRSI( np.ndarray real not None , int timeperiod=-2**31 , int fastk_period=-2**31 , int fastd_period=-2**31 , int fastd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCHRSI(real[, timeperiod=?, fastk_period=?, fastd_period=?, fastd_matype=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_282STOCHRSI(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, int __pyx_v_fastk_period, int __pyx_v_fastd_period, int __pyx_v_fastd_matype) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outfastk = 0;
  double *__pyx_v_outfastk_data;
  PyArrayObject *__pyx_v_outfastd = 0;
  double *__pyx_v_outfastd_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("STOCHRSI", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8107
 *         np.ndarray outfastd
 *         double* outfastd_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8108
 *         double* outfastd_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8109
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8110
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8111
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8112
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8113
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8114
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8115
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8116
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8117
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8119
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHRSI_Lookback( timeperiod , fastk_period , fastd_period , fastd_matype )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_182), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8120
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_STOCHRSI_Lookback( timeperiod , fastk_period , fastd_period , fastd_matype )
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8121
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHRSI_Lookback( timeperiod , fastk_period , fastd_period , fastd_matype )             # <<<<<<<<<<<<<<
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastk_data = <double*>outfastk.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_STOCHRSI_Lookback(__pyx_v_timeperiod, __pyx_v_fastk_period, __pyx_v_fastd_period, __pyx_v_fastd_matype));

  /* "talib/func.pyx":8122
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHRSI_Lookback( timeperiod , fastk_period , fastd_period , fastd_matype )
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outfastk_data = <double*>outfastk.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8122; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outfastk = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8123
 *     lookback = begidx + TA_STOCHRSI_Lookback( timeperiod , fastk_period , fastd_period , fastd_matype )
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastk_data = <double*>outfastk.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outfastk_data[i] = NaN
 */
  __pyx_v_outfastk_data = ((double *)__pyx_v_outfastk->data);

  /* "talib/func.pyx":8124
 *     outfastk = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastk_data = <double*>outfastk.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outfastk_data[i] = NaN
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8125
 *     outfastk_data = <double*>outfastk.data
 *     for i from 0 <= i < min(lookback, length):
 *         outfastk_data[i] = NaN             # <<<<<<<<<<<<<<
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastd_data = <double*>outfastd.data
 */
    (__pyx_v_outfastk_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8126
 *     for i from 0 <= i < min(lookback, length):
 *         outfastk_data[i] = NaN
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outfastd_data = <double*>outfastd.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outfastd = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8127
 *         outfastk_data[i] = NaN
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastd_data = <double*>outfastd.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outfastd_data[i] = NaN
 */
  __pyx_v_outfastd_data = ((double *)__pyx_v_outfastd->data);

  /* "talib/func.pyx":8128
 *     outfastd = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outfastd_data = <double*>outfastd.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outfastd_data[i] = NaN
 *     retCode = TA_STOCHRSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8129
 *     outfastd_data = <double*>outfastd.data
 *     for i from 0 <= i < min(lookback, length):
 *         outfastd_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_STOCHRSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 *     _ta_check_success("TA_STOCHRSI", retCode)
 */
    (__pyx_v_outfastd_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8130
 *     for i from 0 <= i < min(lookback, length):
 *         outfastd_data[i] = NaN
 *     retCode = TA_STOCHRSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_STOCHRSI", retCode)
 *     return outfastk , outfastd
 */
  __pyx_v_retCode = TA_STOCHRSI(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, __pyx_v_fastk_period, __pyx_v_fastd_period, __pyx_v_fastd_matype, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outfastk_data + __pyx_v_lookback)), ((double *)(__pyx_v_outfastd_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8131
 *         outfastd_data[i] = NaN
 *     retCode = TA_STOCHRSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 *     _ta_check_success("TA_STOCHRSI", retCode)             # <<<<<<<<<<<<<<
 *     return outfastk , outfastd
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_STOCHRSI, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8132
 *     retCode = TA_STOCHRSI( 0 , endidx , <double *>(real_data+begidx) , timeperiod , fastk_period , fastd_period , fastd_matype , &outbegidx , &outnbelement , <double *>(outfastk_data+lookback) , <double *>(outfastd_data+lookback) )
 *     _ta_check_success("TA_STOCHRSI", retCode)
 *     return outfastk , outfastd             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_outfastk));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_outfastk));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outfastk));
  __Pyx_INCREF(((PyObject *)__pyx_v_outfastd));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_outfastd));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_outfastd));
  __pyx_r = ((PyObject *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.STOCHRSI", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outfastk);
  __Pyx_XDECREF((PyObject *)__pyx_v_outfastd);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_285SUB(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_284SUB[] = " SUB(real0, real1)\n\n    Vector Arithmetic Substraction (Math Operators)\n\n    Inputs:\n        real0: (any ndarray)\n        real1: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_285SUB = {__Pyx_NAMESTR("SUB"), (PyCFunction)__pyx_pw_5talib_4func_285SUB, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_284SUB)};
static PyObject *__pyx_pw_5talib_4func_285SUB(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real0 = 0;
  PyArrayObject *__pyx_v_real1 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SUB (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real0,&__pyx_n_s__real1,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real0)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("SUB", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SUB") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_real0 = ((PyArrayObject *)values[0]);
    __pyx_v_real1 = ((PyArrayObject *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SUB", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.SUB", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real0), __pyx_ptype_5numpy_ndarray, 0, "real0", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real1), __pyx_ptype_5numpy_ndarray, 0, "real1", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_284SUB(__pyx_self, __pyx_v_real0, __pyx_v_real1);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8136
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SUB( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ SUB(real0, real1)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_284SUB(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real0, PyArrayObject *__pyx_v_real1) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real0_data;
  double *__pyx_v_real1_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SUB", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real0);
  __Pyx_INCREF((PyObject *)__pyx_v_real1);

  /* "talib/func.pyx":8156
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"             # <<<<<<<<<<<<<<
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real0) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_14));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8157
 *         double* outreal_data
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real0->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_15));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8158
 *     assert PyArray_TYPE(real0) == np.NPY_DOUBLE, "real0 is not double"
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real0) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8159
 *     assert real0.ndim == 1, "real0 has wrong dimensions"
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)             # <<<<<<<<<<<<<<
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real0));
    __pyx_v_real0 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8160
 *     if not (PyArray_FLAGS(real0) & np.NPY_C_CONTIGUOUS):
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 */
  __pyx_v_real0_data = ((double *)__pyx_v_real0->data);

  /* "talib/func.pyx":8161
 *         real0 = PyArray_GETCONTIGUOUS(real0)
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"             # <<<<<<<<<<<<<<
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real1) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_16));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8162
 *     real0_data = <double*>real0.data
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real1->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_17));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8163
 *     assert PyArray_TYPE(real1) == np.NPY_DOUBLE, "real1 is not double"
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real1) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8164
 *     assert real1.ndim == 1, "real1 has wrong dimensions"
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)             # <<<<<<<<<<<<<<
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real1));
    __pyx_v_real1 = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8165
 *     if not (PyArray_FLAGS(real1) & np.NPY_C_CONTIGUOUS):
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data             # <<<<<<<<<<<<<<
 *     length = real0.shape[0]
 *     begidx = 0
 */
  __pyx_v_real1_data = ((double *)__pyx_v_real1->data);

  /* "talib/func.pyx":8166
 *         real1 = PyArray_GETCONTIGUOUS(real1)
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real0->dimensions[0]);

  /* "talib/func.pyx":8167
 *     real1_data = <double*>real1.data
 *     length = real0.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8168
 *     length = real0.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real0_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8169
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real0_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8170
 *     for i from 0 <= i < length:
 *         if not isnan(real0_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8171
 *         if not isnan(real0_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L6_break;
      goto __pyx_L7;
    }
    __pyx_L7:;
  }
  /*else*/ {

    /* "talib/func.pyx":8173
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUB_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_183), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L6_break:;

  /* "talib/func.pyx":8174
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SUB_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8175
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUB_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SUB_Lookback());

  /* "talib/func.pyx":8176
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUB_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8177
 *     lookback = begidx + TA_SUB_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8178
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SUB( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8179
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SUB( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SUB", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8180
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SUB( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SUB", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SUB(0, __pyx_v_endidx, ((double *)(__pyx_v_real0_data + __pyx_v_begidx)), ((double *)(__pyx_v_real1_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8181
 *         outreal_data[i] = NaN
 *     retCode = TA_SUB( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SUB", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SUB, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8182
 *     retCode = TA_SUB( 0 , endidx , <double *>(real0_data+begidx) , <double *>(real1_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SUB", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SUB", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real0);
  __Pyx_XDECREF((PyObject *)__pyx_v_real1);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_287SUM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_286SUM[] = " SUM(real[, timeperiod=?])\n\n    Summation (Math Operators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_287SUM = {__Pyx_NAMESTR("SUM"), (PyCFunction)__pyx_pw_5talib_4func_287SUM, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_286SUM)};
static PyObject *__pyx_pw_5talib_4func_287SUM(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("SUM (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "SUM") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("SUM", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.SUM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_286SUM(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8186
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SUM( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ SUM(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_286SUM(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("SUM", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8206
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8206; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8207
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8208
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8209
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8210
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8211
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8212
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8213
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8214
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8215
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8216
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8218
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUM_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_184), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8219
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_SUM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8220
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUM_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_SUM_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8221
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8222
 *     lookback = begidx + TA_SUM_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8223
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_SUM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8224
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_SUM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SUM", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8225
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_SUM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_SUM", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_SUM(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8226
 *         outreal_data[i] = NaN
 *     retCode = TA_SUM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SUM", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_SUM, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8226; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8227
 *     retCode = TA_SUM( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_SUM", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.SUM", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_289T3(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_288T3[] = " T3(real[, timeperiod=?, vfactor=?])\n\n    Triple Exponential Moving Average (T3) (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 5\n        vfactor: 0.7\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_289T3 = {__Pyx_NAMESTR("T3"), (PyCFunction)__pyx_pw_5talib_4func_289T3, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_288T3)};
static PyObject *__pyx_pw_5talib_4func_289T3(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  double __pyx_v_vfactor;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("T3 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,&__pyx_n_s__vfactor,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__vfactor);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "T3") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_vfactor = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_vfactor == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":8231
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def T3( np.ndarray real not None , int timeperiod=-2**31 , double vfactor=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ T3(real[, timeperiod=?, vfactor=?])
 * 
 */
      __pyx_v_vfactor = ((double)-4e37);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("T3", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.T3", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_288T3(__pyx_self, __pyx_v_real, __pyx_v_timeperiod, __pyx_v_vfactor);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_288T3(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_vfactor) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("T3", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8252
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8253
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8254
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8255
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8256
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8257
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8258
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8259
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8260
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8261
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8262
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8264
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_T3_Lookback( timeperiod , vfactor )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_185), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8265
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_T3_Lookback( timeperiod , vfactor )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8266
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_T3_Lookback( timeperiod , vfactor )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_T3_Lookback(__pyx_v_timeperiod, __pyx_v_vfactor));

  /* "talib/func.pyx":8267
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_T3_Lookback( timeperiod , vfactor )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8267; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8268
 *     lookback = begidx + TA_T3_Lookback( timeperiod , vfactor )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8269
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_T3( 0 , endidx , <double *>(real_data+begidx) , timeperiod , vfactor , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8270
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_T3( 0 , endidx , <double *>(real_data+begidx) , timeperiod , vfactor , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_T3", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8271
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_T3( 0 , endidx , <double *>(real_data+begidx) , timeperiod , vfactor , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_T3", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_T3(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, __pyx_v_vfactor, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8272
 *         outreal_data[i] = NaN
 *     retCode = TA_T3( 0 , endidx , <double *>(real_data+begidx) , timeperiod , vfactor , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_T3", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_T3, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8272; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8273
 *     retCode = TA_T3( 0 , endidx , <double *>(real_data+begidx) , timeperiod , vfactor , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_T3", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.T3", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_291TAN(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_290TAN[] = " TAN(real)\n\n    Vector Trigonometric Tan (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_291TAN = {__Pyx_NAMESTR("TAN"), (PyCFunction)__pyx_pw_5talib_4func_291TAN, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_290TAN)};
static PyObject *__pyx_pw_5talib_4func_291TAN(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TAN (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_290TAN(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8277
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TAN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ TAN(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_290TAN(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TAN", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8295
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8295; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8296
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8297
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8298
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8298; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8299
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8300
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8301
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8302
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8303
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8304
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8305
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8307
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TAN_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_186), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8308
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TAN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8309
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TAN_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TAN_Lookback());

  /* "talib/func.pyx":8310
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TAN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8311
 *     lookback = begidx + TA_TAN_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8312
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8313
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TAN", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8314
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TAN", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TAN(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8315
 *         outreal_data[i] = NaN
 *     retCode = TA_TAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TAN", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TAN, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8316
 *     retCode = TA_TAN( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TAN", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TAN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_293TANH(PyObject *__pyx_self, PyObject *__pyx_v_real); /*proto*/
static char __pyx_doc_5talib_4func_292TANH[] = " TANH(real)\n\n    Vector Trigonometric Tanh (Math Transform)\n\n    Inputs:\n        real: (any ndarray)\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_293TANH = {__Pyx_NAMESTR("TANH"), (PyCFunction)__pyx_pw_5talib_4func_293TANH, METH_O, __Pyx_DOCSTR(__pyx_doc_5talib_4func_292TANH)};
static PyObject *__pyx_pw_5talib_4func_293TANH(PyObject *__pyx_self, PyObject *__pyx_v_real) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TANH (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_292TANH(__pyx_self, ((PyArrayObject *)__pyx_v_real));
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8320
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TANH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ TANH(real)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_292TANH(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TANH", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8338
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8338; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8339
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8339; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8340
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8341
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8342
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8343
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8344
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8345
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8346
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8347
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8348
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8350
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TANH_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_187), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8351
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TANH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8352
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TANH_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TANH_Lookback());

  /* "talib/func.pyx":8353
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TANH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8354
 *     lookback = begidx + TA_TANH_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8355
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TANH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8356
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TANH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TANH", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8357
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TANH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TANH", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TANH(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8358
 *         outreal_data[i] = NaN
 *     retCode = TA_TANH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TANH", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TANH, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8358; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8359
 *     retCode = TA_TANH( 0 , endidx , <double *>(real_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TANH", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TANH", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_295TEMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_294TEMA[] = " TEMA(real[, timeperiod=?])\n\n    Triple Exponential Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_295TEMA = {__Pyx_NAMESTR("TEMA"), (PyCFunction)__pyx_pw_5talib_4func_295TEMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_294TEMA)};
static PyObject *__pyx_pw_5talib_4func_295TEMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TEMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TEMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TEMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.TEMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_294TEMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8363
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TEMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TEMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_294TEMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TEMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8383
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8384
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8385
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8386
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8386; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8387
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8388
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8389
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8390
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8391
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8392
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8393
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8395
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TEMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_188), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8396
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TEMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8397
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TEMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TEMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8398
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TEMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8399
 *     lookback = begidx + TA_TEMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8400
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8401
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TEMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8402
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TEMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TEMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8403
 *         outreal_data[i] = NaN
 *     retCode = TA_TEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TEMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TEMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8404
 *     retCode = TA_TEMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TEMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TEMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_297TRANGE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_296TRANGE[] = " TRANGE(high, low, close)\n\n    True Range (Volatility Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_297TRANGE = {__Pyx_NAMESTR("TRANGE"), (PyCFunction)__pyx_pw_5talib_4func_297TRANGE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_296TRANGE)};
static PyObject *__pyx_pw_5talib_4func_297TRANGE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TRANGE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TRANGE", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TRANGE", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TRANGE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TRANGE", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.TRANGE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_296TRANGE(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8408
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRANGE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ TRANGE(high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_296TRANGE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TRANGE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":8428
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8429
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8430
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8431
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8432
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":8433
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8434
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8435
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8436
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8437
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":8438
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8439
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8440
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8441
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":8442
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":8443
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":8444
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8445
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8446
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8447
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8448
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":8450
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRANGE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_189), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":8451
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TRANGE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8452
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRANGE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TRANGE_Lookback());

  /* "talib/func.pyx":8453
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRANGE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8454
 *     lookback = begidx + TA_TRANGE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8455
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TRANGE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8456
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TRANGE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRANGE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8457
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TRANGE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TRANGE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TRANGE(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8458
 *         outreal_data[i] = NaN
 *     retCode = TA_TRANGE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRANGE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TRANGE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8458; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8459
 *     retCode = TA_TRANGE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRANGE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TRANGE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_299TRIMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_298TRIMA[] = " TRIMA(real[, timeperiod=?])\n\n    Triangular Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_299TRIMA = {__Pyx_NAMESTR("TRIMA"), (PyCFunction)__pyx_pw_5talib_4func_299TRIMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_298TRIMA)};
static PyObject *__pyx_pw_5talib_4func_299TRIMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TRIMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TRIMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TRIMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.TRIMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_298TRIMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8463
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRIMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TRIMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_298TRIMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TRIMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8483
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8484
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8485
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8486
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8486; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8487
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8488
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8489
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8490
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8491
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8492
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8493
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8495
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_190), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8496
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TRIMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8497
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TRIMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8498
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8498; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8498; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8499
 *     lookback = begidx + TA_TRIMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8500
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TRIMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8501
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TRIMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRIMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8502
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TRIMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TRIMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TRIMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8503
 *         outreal_data[i] = NaN
 *     retCode = TA_TRIMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRIMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TRIMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8504
 *     retCode = TA_TRIMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRIMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TRIMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_301TRIX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_300TRIX[] = " TRIX(real[, timeperiod=?])\n\n    1-day Rate-Of-Change (ROC) of a Triple Smooth EMA (Momentum Indicators)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_301TRIX = {__Pyx_NAMESTR("TRIX"), (PyCFunction)__pyx_pw_5talib_4func_301TRIX, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_300TRIX)};
static PyObject *__pyx_pw_5talib_4func_301TRIX(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TRIX (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TRIX") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TRIX", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.TRIX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_300TRIX(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8508
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRIX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TRIX(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_300TRIX(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TRIX", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8528
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8528; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8529
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8530
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8531
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8532
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8533
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8534
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8535
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8536
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8537
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8538
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8540
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIX_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_191), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8541
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TRIX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8542
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIX_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TRIX_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8543
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8544
 *     lookback = begidx + TA_TRIX_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8545
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TRIX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8546
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TRIX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRIX", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8547
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TRIX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TRIX", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TRIX(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8548
 *         outreal_data[i] = NaN
 *     retCode = TA_TRIX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRIX", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TRIX, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8549
 *     retCode = TA_TRIX( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TRIX", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TRIX", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_303TSF(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_302TSF[] = " TSF(real[, timeperiod=?])\n\n    Time Series Forecast (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_303TSF = {__Pyx_NAMESTR("TSF"), (PyCFunction)__pyx_pw_5talib_4func_303TSF, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_302TSF)};
static PyObject *__pyx_pw_5talib_4func_303TSF(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TSF (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TSF") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TSF", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.TSF", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_302TSF(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8553
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TSF( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TSF(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_302TSF(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TSF", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8573
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8573; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8574
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8575
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8576
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8577
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8578
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8579
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8580
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8581
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8582
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8583
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8585
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TSF_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_192), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8586
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TSF_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8587
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TSF_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TSF_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8588
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TSF_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8589
 *     lookback = begidx + TA_TSF_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8590
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TSF( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8591
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TSF( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TSF", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8592
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TSF( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TSF", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TSF(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8593
 *         outreal_data[i] = NaN
 *     retCode = TA_TSF( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TSF", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TSF, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8593; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8594
 *     retCode = TA_TSF( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TSF", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TSF", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_305TYPPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_304TYPPRICE[] = " TYPPRICE(high, low, close)\n\n    Typical Price (Price Transform)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_305TYPPRICE = {__Pyx_NAMESTR("TYPPRICE"), (PyCFunction)__pyx_pw_5talib_4func_305TYPPRICE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_304TYPPRICE)};
static PyObject *__pyx_pw_5talib_4func_305TYPPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("TYPPRICE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TYPPRICE", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("TYPPRICE", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "TYPPRICE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("TYPPRICE", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.TYPPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_304TYPPRICE(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8598
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TYPPRICE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ TYPPRICE(high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_304TYPPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("TYPPRICE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":8618
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8619
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8619; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8620
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8621
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8622
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":8623
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8624
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8625
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8626
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8626; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8627
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":8628
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8629
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8629; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8630
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8631
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":8632
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":8633
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":8634
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8635
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8636
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8637
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8638
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":8640
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TYPPRICE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_193), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":8641
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_TYPPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8642
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TYPPRICE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_TYPPRICE_Lookback());

  /* "talib/func.pyx":8643
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TYPPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8643; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8644
 *     lookback = begidx + TA_TYPPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8645
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_TYPPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8646
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_TYPPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TYPPRICE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8647
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_TYPPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_TYPPRICE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_TYPPRICE(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8648
 *         outreal_data[i] = NaN
 *     retCode = TA_TYPPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TYPPRICE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_TYPPRICE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8648; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8649
 *     retCode = TA_TYPPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_TYPPRICE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.TYPPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_307ULTOSC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_306ULTOSC[] = " ULTOSC(high, low, close[, timeperiod1=?, timeperiod2=?, timeperiod3=?])\n\n    Ultimate Oscillator (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod1: 7\n        timeperiod2: 14\n        timeperiod3: 28\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_307ULTOSC = {__Pyx_NAMESTR("ULTOSC"), (PyCFunction)__pyx_pw_5talib_4func_307ULTOSC, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_306ULTOSC)};
static PyObject *__pyx_pw_5talib_4func_307ULTOSC(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod1;
  int __pyx_v_timeperiod2;
  int __pyx_v_timeperiod3;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ULTOSC (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod1,&__pyx_n_s__timeperiod2,&__pyx_n_s__timeperiod3,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ULTOSC", 0, 3, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("ULTOSC", 0, 3, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod1);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod2);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod3);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ULTOSC") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod1 = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod1 = ((int)-2147483648);
    }
    if (values[4]) {
      __pyx_v_timeperiod2 = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_timeperiod2 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod2 = ((int)-2147483648);
    }
    if (values[5]) {
      __pyx_v_timeperiod3 = __Pyx_PyInt_AsInt(values[5]); if (unlikely((__pyx_v_timeperiod3 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod3 = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ULTOSC", 0, 3, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.ULTOSC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_306ULTOSC(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod1, __pyx_v_timeperiod2, __pyx_v_timeperiod3);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8653
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ULTOSC( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod1=-2**31 , int timeperiod2=-2**31 , int timeperiod3=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ULTOSC(high, low, close[, timeperiod1=?, timeperiod2=?, timeperiod3=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_306ULTOSC(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod1, int __pyx_v_timeperiod2, int __pyx_v_timeperiod3) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ULTOSC", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":8677
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8677; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8678
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8678; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8679
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8680
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8680; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8680; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8681
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":8682
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8683
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8683; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8684
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8685
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8686
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":8687
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8687; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8688
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8689
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8690
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8690; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8690; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":8691
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":8692
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":8693
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8694
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8695
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8696
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8697
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":8699
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ULTOSC_Lookback( timeperiod1 , timeperiod2 , timeperiod3 )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_194), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":8700
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_ULTOSC_Lookback( timeperiod1 , timeperiod2 , timeperiod3 )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8701
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ULTOSC_Lookback( timeperiod1 , timeperiod2 , timeperiod3 )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_ULTOSC_Lookback(__pyx_v_timeperiod1, __pyx_v_timeperiod2, __pyx_v_timeperiod3));

  /* "talib/func.pyx":8702
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ULTOSC_Lookback( timeperiod1 , timeperiod2 , timeperiod3 )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8702; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8703
 *     lookback = begidx + TA_ULTOSC_Lookback( timeperiod1 , timeperiod2 , timeperiod3 )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8704
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_ULTOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod1 , timeperiod2 , timeperiod3 , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8705
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_ULTOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod1 , timeperiod2 , timeperiod3 , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ULTOSC", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8706
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_ULTOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod1 , timeperiod2 , timeperiod3 , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_ULTOSC", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_ULTOSC(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod1, __pyx_v_timeperiod2, __pyx_v_timeperiod3, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8707
 *         outreal_data[i] = NaN
 *     retCode = TA_ULTOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod1 , timeperiod2 , timeperiod3 , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ULTOSC", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_ULTOSC, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8708
 *     retCode = TA_ULTOSC( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod1 , timeperiod2 , timeperiod3 , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_ULTOSC", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.ULTOSC", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_309VAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_308VAR[] = " VAR(real[, timeperiod=?, nbdev=?])\n\n    Variance (Statistic Functions)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 5\n        nbdev: 1\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_309VAR = {__Pyx_NAMESTR("VAR"), (PyCFunction)__pyx_pw_5talib_4func_309VAR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_308VAR)};
static PyObject *__pyx_pw_5talib_4func_309VAR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  double __pyx_v_nbdev;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("VAR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,&__pyx_n_s__nbdev,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__nbdev);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "VAR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
    if (values[2]) {
      __pyx_v_nbdev = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_nbdev == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "talib/func.pyx":8712
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def VAR( np.ndarray real not None , int timeperiod=-2**31 , double nbdev=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ VAR(real[, timeperiod=?, nbdev=?])
 * 
 */
      __pyx_v_nbdev = ((double)-4e37);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("VAR", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.VAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_308VAR(__pyx_self, __pyx_v_real, __pyx_v_timeperiod, __pyx_v_nbdev);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5talib_4func_308VAR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod, double __pyx_v_nbdev) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("VAR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8733
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8734
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8735
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8736
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8737
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8738
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8739
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8740
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8741
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8742
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8743
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8745
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_VAR_Lookback( timeperiod , nbdev )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_195), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8746
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_VAR_Lookback( timeperiod , nbdev )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8747
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_VAR_Lookback( timeperiod , nbdev )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_VAR_Lookback(__pyx_v_timeperiod, __pyx_v_nbdev));

  /* "talib/func.pyx":8748
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_VAR_Lookback( timeperiod , nbdev )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8749
 *     lookback = begidx + TA_VAR_Lookback( timeperiod , nbdev )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8750
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_VAR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8751
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_VAR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_VAR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8752
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_VAR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_VAR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_VAR(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, __pyx_v_nbdev, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8753
 *         outreal_data[i] = NaN
 *     retCode = TA_VAR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_VAR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_VAR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8753; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8754
 *     retCode = TA_VAR( 0 , endidx , <double *>(real_data+begidx) , timeperiod , nbdev , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_VAR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.VAR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_311WCLPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_310WCLPRICE[] = " WCLPRICE(high, low, close)\n\n    Weighted Close Price (Price Transform)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_311WCLPRICE = {__Pyx_NAMESTR("WCLPRICE"), (PyCFunction)__pyx_pw_5talib_4func_311WCLPRICE, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_310WCLPRICE)};
static PyObject *__pyx_pw_5talib_4func_311WCLPRICE(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WCLPRICE (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("WCLPRICE", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("WCLPRICE", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "WCLPRICE") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("WCLPRICE", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.WCLPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_310WCLPRICE(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8758
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WCLPRICE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ WCLPRICE(high, low, close)
 * 
 */

static PyObject *__pyx_pf_5talib_4func_310WCLPRICE(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WCLPRICE", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":8778
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8779
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8779; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8780
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8781
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8782
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":8783
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8783; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8784
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8785
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8786
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8786; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8787
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":8788
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8788; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8789
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8789; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8790
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8791
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":8792
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":8793
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":8794
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8795
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8796
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8797
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8798
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":8800
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WCLPRICE_Lookback( )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_196), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":8801
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_WCLPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8802
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WCLPRICE_Lookback( )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_WCLPRICE_Lookback());

  /* "talib/func.pyx":8803
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WCLPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8804
 *     lookback = begidx + TA_WCLPRICE_Lookback( )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8805
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_WCLPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8806
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_WCLPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WCLPRICE", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8807
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_WCLPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_WCLPRICE", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_WCLPRICE(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8808
 *         outreal_data[i] = NaN
 *     retCode = TA_WCLPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WCLPRICE", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_WCLPRICE, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8808; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8809
 *     retCode = TA_WCLPRICE( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WCLPRICE", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.WCLPRICE", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_313WILLR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_312WILLR[] = " WILLR(high, low, close[, timeperiod=?])\n\n    Williams' %R (Momentum Indicators)\n\n    Inputs:\n        prices: ['high', 'low', 'close']\n    Parameters:\n        timeperiod: 14\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_313WILLR = {__Pyx_NAMESTR("WILLR"), (PyCFunction)__pyx_pw_5talib_4func_313WILLR, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_312WILLR)};
static PyObject *__pyx_pw_5talib_4func_313WILLR(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_high = 0;
  PyArrayObject *__pyx_v_low = 0;
  PyArrayObject *__pyx_v_close = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WILLR (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__high,&__pyx_n_s__low,&__pyx_n_s__close,&__pyx_n_s__timeperiod,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__high)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__low)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("WILLR", 0, 3, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__close)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("WILLR", 0, 3, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "WILLR") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_high = ((PyArrayObject *)values[0]);
    __pyx_v_low = ((PyArrayObject *)values[1]);
    __pyx_v_close = ((PyArrayObject *)values[2]);
    if (values[3]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[3]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("WILLR", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.WILLR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_high), __pyx_ptype_5numpy_ndarray, 0, "high", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_low), __pyx_ptype_5numpy_ndarray, 0, "low", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_close), __pyx_ptype_5numpy_ndarray, 0, "close", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_312WILLR(__pyx_self, __pyx_v_high, __pyx_v_low, __pyx_v_close, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8813
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WILLR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ WILLR(high, low, close[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_312WILLR(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_high, PyArrayObject *__pyx_v_low, PyArrayObject *__pyx_v_close, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_high_data;
  double *__pyx_v_low_data;
  double *__pyx_v_close_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WILLR", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_high);
  __Pyx_INCREF((PyObject *)__pyx_v_low);
  __Pyx_INCREF((PyObject *)__pyx_v_close);

  /* "talib/func.pyx":8835
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"             # <<<<<<<<<<<<<<
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_high) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_5));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8836
 *         double* outreal_data
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_high->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_6));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8837
 *     assert PyArray_TYPE(high) == np.NPY_DOUBLE, "high is not double"
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_high) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8838
 *     assert high.ndim == 1, "high has wrong dimensions"
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)             # <<<<<<<<<<<<<<
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_high); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_high));
    __pyx_v_high = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8839
 *     if not (PyArray_FLAGS(high) & np.NPY_C_CONTIGUOUS):
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 */
  __pyx_v_high_data = ((double *)__pyx_v_high->data);

  /* "talib/func.pyx":8840
 *         high = PyArray_GETCONTIGUOUS(high)
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"             # <<<<<<<<<<<<<<
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_low) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_7));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8841
 *     high_data = <double*>high.data
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_low->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_8));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8842
 *     assert PyArray_TYPE(low) == np.NPY_DOUBLE, "low is not double"
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_low) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8843
 *     assert low.ndim == 1, "low has wrong dimensions"
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)             # <<<<<<<<<<<<<<
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_low); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_low));
    __pyx_v_low = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "talib/func.pyx":8844
 *     if not (PyArray_FLAGS(low) & np.NPY_C_CONTIGUOUS):
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data             # <<<<<<<<<<<<<<
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 */
  __pyx_v_low_data = ((double *)__pyx_v_low->data);

  /* "talib/func.pyx":8845
 *         low = PyArray_GETCONTIGUOUS(low)
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"             # <<<<<<<<<<<<<<
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_close) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_9));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8846
 *     low_data = <double*>low.data
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_close->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_10));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8846; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8847
 *     assert PyArray_TYPE(close) == np.NPY_DOUBLE, "close is not double"
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_close) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8848
 *     assert close.ndim == 1, "close has wrong dimensions"
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)             # <<<<<<<<<<<<<<
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_close); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_close));
    __pyx_v_close = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "talib/func.pyx":8849
 *     if not (PyArray_FLAGS(close) & np.NPY_C_CONTIGUOUS):
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data             # <<<<<<<<<<<<<<
 *     length = high.shape[0]
 *     begidx = 0
 */
  __pyx_v_close_data = ((double *)__pyx_v_close->data);

  /* "talib/func.pyx":8850
 *         close = PyArray_GETCONTIGUOUS(close)
 *     close_data = <double*>close.data
 *     length = high.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_high->dimensions[0]);

  /* "talib/func.pyx":8851
 *     close_data = <double*>close.data
 *     length = high.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8852
 *     length = high.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(high_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8853
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_high_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8854
 *     for i from 0 <= i < length:
 *         if not isnan(high_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8855
 *         if not isnan(high_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L7_break;
      goto __pyx_L8;
    }
    __pyx_L8:;
  }
  /*else*/ {

    /* "talib/func.pyx":8857
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WILLR_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_197), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7_break:;

  /* "talib/func.pyx":8858
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_WILLR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8859
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WILLR_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_WILLR_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8860
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WILLR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8860; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8860; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8861
 *     lookback = begidx + TA_WILLR_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8862
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_WILLR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8863
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_WILLR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WILLR", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8864
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_WILLR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_WILLR", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_WILLR(0, __pyx_v_endidx, ((double *)(__pyx_v_high_data + __pyx_v_begidx)), ((double *)(__pyx_v_low_data + __pyx_v_begidx)), ((double *)(__pyx_v_close_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8865
 *         outreal_data[i] = NaN
 *     retCode = TA_WILLR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WILLR", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_WILLR, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8866
 *     retCode = TA_WILLR( 0 , endidx , <double *>(high_data+begidx) , <double *>(low_data+begidx) , <double *>(close_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WILLR", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * @wraparound(False)  # turn off relative indexing from end of lists
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.WILLR", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_high);
  __Pyx_XDECREF((PyObject *)__pyx_v_low);
  __Pyx_XDECREF((PyObject *)__pyx_v_close);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5talib_4func_315WMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5talib_4func_314WMA[] = " WMA(real[, timeperiod=?])\n\n    Weighted Moving Average (Overlap Studies)\n\n    Inputs:\n        real: (any ndarray)\n    Parameters:\n        timeperiod: 30\n    Outputs:\n        real\n    ";
static PyMethodDef __pyx_mdef_5talib_4func_315WMA = {__Pyx_NAMESTR("WMA"), (PyCFunction)__pyx_pw_5talib_4func_315WMA, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_5talib_4func_314WMA)};
static PyObject *__pyx_pw_5talib_4func_315WMA(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyArrayObject *__pyx_v_real = 0;
  int __pyx_v_timeperiod;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("WMA (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__real,&__pyx_n_s__timeperiod,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__real)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s__timeperiod);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "WMA") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_real = ((PyArrayObject *)values[0]);
    if (values[1]) {
      __pyx_v_timeperiod = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_timeperiod == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_timeperiod = ((int)-2147483648);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("WMA", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("talib.func.WMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_real), __pyx_ptype_5numpy_ndarray, 0, "real", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_5talib_4func_314WMA(__pyx_self, __pyx_v_real, __pyx_v_timeperiod);
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "talib/func.pyx":8870
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ WMA(real[, timeperiod=?])
 * 
 */

static PyObject *__pyx_pf_5talib_4func_314WMA(CYTHON_UNUSED PyObject *__pyx_self, PyArrayObject *__pyx_v_real, int __pyx_v_timeperiod) {
  npy_intp __pyx_v_length;
  int __pyx_v_begidx;
  int __pyx_v_endidx;
  int __pyx_v_lookback;
  double *__pyx_v_real_data;
  int __pyx_v_outbegidx;
  int __pyx_v_outnbelement;
  PyArrayObject *__pyx_v_outreal = 0;
  double *__pyx_v_outreal_data;
  long __pyx_v_i;
  __pyx_t_5talib_4func_TA_RetCode __pyx_v_retCode;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  npy_intp __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("WMA", 0);
  __Pyx_INCREF((PyObject *)__pyx_v_real);

  /* "talib/func.pyx":8890
 *         np.ndarray outreal
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"             # <<<<<<<<<<<<<<
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(PyArray_TYPE(__pyx_v_real) == NPY_DOUBLE))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_1));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8890; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8891
 *         double* outreal_data
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"             # <<<<<<<<<<<<<<
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_real->nd == 1))) {
    PyErr_SetObject(PyExc_AssertionError, ((PyObject *)__pyx_kp_s_2));
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8891; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "talib/func.pyx":8892
 *     assert PyArray_TYPE(real) == np.NPY_DOUBLE, "real is not double"
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):             # <<<<<<<<<<<<<<
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 */
  __pyx_t_1 = (!(PyArray_FLAGS(__pyx_v_real) & NPY_C_CONTIGUOUS));
  if (__pyx_t_1) {

    /* "talib/func.pyx":8893
 *     assert real.ndim == 1, "real has wrong dimensions"
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)             # <<<<<<<<<<<<<<
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 */
    __pyx_t_2 = PyArray_GETCONTIGUOUS(__pyx_v_real); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8893; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8893; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(((PyObject *)__pyx_v_real));
    __pyx_v_real = ((PyArrayObject *)__pyx_t_2);
    __pyx_t_2 = 0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "talib/func.pyx":8894
 *     if not (PyArray_FLAGS(real) & np.NPY_C_CONTIGUOUS):
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data             # <<<<<<<<<<<<<<
 *     length = real.shape[0]
 *     begidx = 0
 */
  __pyx_v_real_data = ((double *)__pyx_v_real->data);

  /* "talib/func.pyx":8895
 *         real = PyArray_GETCONTIGUOUS(real)
 *     real_data = <double*>real.data
 *     length = real.shape[0]             # <<<<<<<<<<<<<<
 *     begidx = 0
 *     for i from 0 <= i < length:
 */
  __pyx_v_length = (__pyx_v_real->dimensions[0]);

  /* "talib/func.pyx":8896
 *     real_data = <double*>real.data
 *     length = real.shape[0]
 *     begidx = 0             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 */
  __pyx_v_begidx = 0;

  /* "talib/func.pyx":8897
 *     length = real.shape[0]
 *     begidx = 0
 *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
 *         if not isnan(real_data[i]):
 *             begidx = i
 */
  __pyx_t_3 = __pyx_v_length;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {

    /* "talib/func.pyx":8898
 *     begidx = 0
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):             # <<<<<<<<<<<<<<
 *             begidx = i
 *             break
 */
    __pyx_t_1 = (!isnan((__pyx_v_real_data[__pyx_v_i])));
    if (__pyx_t_1) {

      /* "talib/func.pyx":8899
 *     for i from 0 <= i < length:
 *         if not isnan(real_data[i]):
 *             begidx = i             # <<<<<<<<<<<<<<
 *             break
 *     else:
 */
      __pyx_v_begidx = __pyx_v_i;

      /* "talib/func.pyx":8900
 *         if not isnan(real_data[i]):
 *             begidx = i
 *             break             # <<<<<<<<<<<<<<
 *     else:
 *         raise Exception("inputs are all NaN")
 */
      goto __pyx_L5_break;
      goto __pyx_L6;
    }
    __pyx_L6:;
  }
  /*else*/ {

    /* "talib/func.pyx":8902
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WMA_Lookback( timeperiod )
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_k_tuple_198), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8902; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8902; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L5_break:;

  /* "talib/func.pyx":8903
 *     else:
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1             # <<<<<<<<<<<<<<
 *     lookback = begidx + TA_WMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 */
  __pyx_v_endidx = ((__pyx_v_length - __pyx_v_begidx) - 1);

  /* "talib/func.pyx":8904
 *         raise Exception("inputs are all NaN")
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WMA_Lookback( timeperiod )             # <<<<<<<<<<<<<<
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 */
  __pyx_v_lookback = (__pyx_v_begidx + TA_WMA_Lookback(__pyx_v_timeperiod));

  /* "talib/func.pyx":8905
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)             # <<<<<<<<<<<<<<
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 */
  __pyx_t_2 = PyArray_EMPTY(1, (&__pyx_v_length), NPY_DOUBLE, NPY_DEFAULT); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_outreal = ((PyArrayObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "talib/func.pyx":8906
 *     lookback = begidx + TA_WMA_Lookback( timeperiod )
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data             # <<<<<<<<<<<<<<
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 */
  __pyx_v_outreal_data = ((double *)__pyx_v_outreal->data);

  /* "talib/func.pyx":8907
 *     outreal = PyArray_EMPTY(1, &length, np.NPY_DOUBLE, np.NPY_DEFAULT)
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):             # <<<<<<<<<<<<<<
 *         outreal_data[i] = NaN
 *     retCode = TA_WMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 */
  __pyx_t_3 = __pyx_v_length;
  __pyx_t_4 = __pyx_v_lookback;
  if ((__pyx_t_3 < __pyx_t_4)) {
    __pyx_t_5 = __pyx_t_3;
  } else {
    __pyx_t_5 = __pyx_t_4;
  }
  __pyx_t_4 = __pyx_t_5;
  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {

    /* "talib/func.pyx":8908
 *     outreal_data = <double*>outreal.data
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN             # <<<<<<<<<<<<<<
 *     retCode = TA_WMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WMA", retCode)
 */
    (__pyx_v_outreal_data[__pyx_v_i]) = __pyx_v_5talib_4func_NaN;
  }

  /* "talib/func.pyx":8909
 *     for i from 0 <= i < min(lookback, length):
 *         outreal_data[i] = NaN
 *     retCode = TA_WMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )             # <<<<<<<<<<<<<<
 *     _ta_check_success("TA_WMA", retCode)
 *     return outreal
 */
  __pyx_v_retCode = TA_WMA(0, __pyx_v_endidx, ((double *)(__pyx_v_real_data + __pyx_v_begidx)), __pyx_v_timeperiod, (&__pyx_v_outbegidx), (&__pyx_v_outnbelement), ((double *)(__pyx_v_outreal_data + __pyx_v_lookback)));

  /* "talib/func.pyx":8910
 *         outreal_data[i] = NaN
 *     retCode = TA_WMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WMA", retCode)             # <<<<<<<<<<<<<<
 *     return outreal
 * 
 */
  __pyx_t_2 = __pyx_f_5talib_6common__ta_check_success(__pyx_n_s__TA_WMA, __pyx_v_retCode, 0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "talib/func.pyx":8911
 *     retCode = TA_WMA( 0 , endidx , <double *>(real_data+begidx) , timeperiod , &outbegidx , &outnbelement , <double *>(outreal_data+lookback) )
 *     _ta_check_success("TA_WMA", retCode)
 *     return outreal             # <<<<<<<<<<<<<<
 * 
 * __all__ = ["ACOS","AD","ADD","ADOSC","ADX","ADXR","APO","AROON","AROONOSC","ASIN","ATAN","ATR","AVGPRICE","BBANDS","BETA","BOP","CCI","CDL2CROWS","CDL3BLACKCROWS","CDL3INSIDE","CDL3LINESTRIKE","CDL3OUTSIDE","CDL3STARSINSOUTH","CDL3WHITESOLDIERS","CDLABANDONEDBABY","CDLADVANCEBLOCK","CDLBELTHOLD","CDLBREAKAWAY","CDLCLOSINGMARUBOZU","CDLCONCEALBABYSWALL","CDLCOUNTERATTACK","CDLDARKCLOUDCOVER","CDLDOJI","CDLDOJISTAR","CDLDRAGONFLYDOJI","CDLENGULFING","CDLEVENINGDOJISTAR","CDLEVENINGSTAR","CDLGAPSIDESIDEWHITE","CDLGRAVESTONEDOJI","CDLHAMMER","CDLHANGINGMAN","CDLHARAMI","CDLHARAMICROSS","CDLHIGHWAVE","CDLHIKKAKE","CDLHIKKAKEMOD","CDLHOMINGPIGEON","CDLIDENTICAL3CROWS","CDLINNECK","CDLINVERTEDHAMMER","CDLKICKING","CDLKICKINGBYLENGTH","CDLLADDERBOTTOM","CDLLONGLEGGEDDOJI","CDLLONGLINE","CDLMARUBOZU","CDLMATCHINGLOW","CDLMATHOLD","CDLMORNINGDOJISTAR","CDLMORNINGSTAR","CDLONNECK","CDLPIERCING","CDLRICKSHAWMAN","CDLRISEFALL3METHODS","CDLSEPARATINGLINES","CDLSHOOTINGSTAR","CDLSHORTLINE","CDLSPINNINGTOP","CDLSTALLEDPATTERN","CDLSTICKSANDWICH","CDLTAKURI","CDLTASUKIGAP","CDLTHRUSTING","CDLTRISTAR","CDLUNIQUE3RIVER","CDLUPSIDEGAP2CROWS","CDLXSIDEGAP3METHODS","CEIL","CMO","CORREL","COS","COSH","DEMA","DIV","DX","EMA","EXP","FLOOR","HT_DCPERIOD","HT_DCPHASE","HT_PHASOR","HT_SINE","HT_TRENDLINE","HT_TRENDMODE","KAMA","LINEARREG","LINEARREG_ANGLE","LINEARREG_INTERCEPT","LINEARREG_SLOPE","LN","LOG10","MA","MACD","MACDEXT","MACDFIX","MAMA","MAVP","MAX","MAXINDEX","MEDPRICE","MFI","MIDPOINT","MIDPRICE","MIN","MININDEX","MINMAX","MINMAXINDEX","MINUS_DI","MINUS_DM","MOM","MULT","NATR","OBV","PLUS_DI","PLUS_DM","PPO","ROC","ROCP","ROCR","ROCR100","RSI","SAR","SAREXT","SIN","SINH","SMA","SQRT","STDDEV","STOCH","STOCHF","STOCHRSI","SUB","SUM","T3","TAN","TANH","TEMA","TRANGE","TRIMA","TRIX","TSF","TYPPRICE","ULTOSC","VAR","WCLPRICE","WILLR","WMA"]
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_outreal));
  __pyx_r = ((PyObject *)__pyx_v_outreal);
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("talib.func.WMA", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_outreal);
  __Pyx_XDECREF((PyObject *)__pyx_v_real);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5numpy_7ndarray___getbuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":194
 *         # experimental exception made for __getbuffer__ and __releasebuffer__
 *         # -- the details of this may change.
 *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_v_copy_shape;
  int __pyx_v_i;
  int __pyx_v_ndim;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  int __pyx_v_t;
  char *__pyx_v_f;
  PyArray_Descr *__pyx_v_descr = 0;
  int __pyx_v_offset;
  int __pyx_v_hasfields;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  char *__pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__getbuffer__", 0);
  if (__pyx_v_info != NULL) {
    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(__pyx_v_info->obj);
  }

  /* "numpy.pxd":200
 *             # of flags
 * 
 *             if info == NULL: return             # <<<<<<<<<<<<<<
 * 
 *             cdef int copy_shape, i, ndim
 */
  __pyx_t_1 = (__pyx_v_info == NULL);
  if (__pyx_t_1) {
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "numpy.pxd":203
 * 
 *             cdef int copy_shape, i, ndim
 *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 */
  __pyx_v_endian_detector = 1;

  /* "numpy.pxd":204
 *             cdef int copy_shape, i, ndim
 *             cdef int endian_detector = 1
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 * 
 *             ndim = PyArray_NDIM(self)
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "numpy.pxd":206
 *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 * 
 *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_v_ndim = PyArray_NDIM(__pyx_v_self);

  /* "numpy.pxd":208
 *             ndim = PyArray_NDIM(self)
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 copy_shape = 1
 *             else:
 */
  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
  if (__pyx_t_1) {

    /* "numpy.pxd":209
 * 
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 copy_shape = 1             # <<<<<<<<<<<<<<
 *             else:
 *                 copy_shape = 0
 */
    __pyx_v_copy_shape = 1;
    goto __pyx_L4;
  }
  /*else*/ {

    /* "numpy.pxd":211
 *                 copy_shape = 1
 *             else:
 *                 copy_shape = 0             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 */
    __pyx_v_copy_shape = 0;
  }
  __pyx_L4:;

  /* "numpy.pxd":213
 *                 copy_shape = 0
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")
 */
  __pyx_t_1 = ((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS);
  if (__pyx_t_1) {

    /* "numpy.pxd":214
 * 
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 */
    __pyx_t_2 = (!PyArray_CHKFLAGS(__pyx_v_self, NPY_C_CONTIGUOUS));
    __pyx_t_3 = __pyx_t_2;
  } else {
    __pyx_t_3 = __pyx_t_1;
  }
  if (__pyx_t_3) {

    /* "numpy.pxd":215
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_200), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "numpy.pxd":217
 *                 raise ValueError(u"ndarray is not C contiguous")
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 */
  __pyx_t_3 = ((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS);
  if (__pyx_t_3) {

    /* "numpy.pxd":218
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 */
    __pyx_t_1 = (!PyArray_CHKFLAGS(__pyx_v_self, NPY_F_CONTIGUOUS));
    __pyx_t_2 = __pyx_t_1;
  } else {
    __pyx_t_2 = __pyx_t_3;
  }
  if (__pyx_t_2) {

    /* "numpy.pxd":219
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
    __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_202), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "numpy.pxd":221
 *                 raise ValueError(u"ndarray is not Fortran contiguous")
 * 
 *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
 *             info.ndim = ndim
 *             if copy_shape:
 */
  __pyx_v_info->buf = PyArray_DATA(__pyx_v_self);

  /* "numpy.pxd":222
 * 
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim             # <<<<<<<<<<<<<<
 *             if copy_shape:
 *                 # Allocate new buffer for strides and shape info.
 */
  __pyx_v_info->ndim = __pyx_v_ndim;

  /* "numpy.pxd":223
 *             info.buf = PyArray_DATA(self)
 *             info.ndim = ndim
 *             if copy_shape:             # <<<<<<<<<<<<<<
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 */
  if (__pyx_v_copy_shape) {

    /* "numpy.pxd":226
 *                 # Allocate new buffer for strides and shape info.
 *                 # This is allocated as one block, strides first.
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)             # <<<<<<<<<<<<<<
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 */
    __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * ((size_t)__pyx_v_ndim)) * 2)));

    /* "numpy.pxd":227
 *                 # This is allocated as one block, strides first.
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
 *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 */
    __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);

    /* "numpy.pxd":228
 *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * <size_t>ndim * 2)
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):             # <<<<<<<<<<<<<<
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 */
    __pyx_t_5 = __pyx_v_ndim;
    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
      __pyx_v_i = __pyx_t_6;

      /* "numpy.pxd":229
 *                 info.shape = info.strides + ndim
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 */
      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(__pyx_v_self)[__pyx_v_i]);

      /* "numpy.pxd":230
 *                 for i in range(ndim):
 *                     info.strides[i] = PyArray_STRIDES(self)[i]
 *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 */
      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(__pyx_v_self)[__pyx_v_i]);
    }
    goto __pyx_L7;
  }
  /*else*/ {

    /* "numpy.pxd":232
 *                     info.shape[i] = PyArray_DIMS(self)[i]
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 */
    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(__pyx_v_self));

    /* "numpy.pxd":233
 *             else:
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 */
    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(__pyx_v_self));
  }
  __pyx_L7:;

  /* "numpy.pxd":234
 *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 */
  __pyx_v_info->suboffsets = NULL;

  /* "numpy.pxd":235
 *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
 *             info.readonly = not PyArray_ISWRITEABLE(self)
 * 
 */
  __pyx_v_info->itemsize = PyArray_ITEMSIZE(__pyx_v_self);

  /* "numpy.pxd":236
 *             info.suboffsets = NULL
 *             info.itemsize = PyArray_ITEMSIZE(self)
 *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
 * 
 *             cdef int t
 */
  __pyx_v_info->readonly = (!PyArray_ISWRITEABLE(__pyx_v_self));

  /* "numpy.pxd":239
 * 
 *             cdef int t
 *             cdef char* f = NULL             # <<<<<<<<<<<<<<
 *             cdef dtype descr = self.descr
 *             cdef list stack
 */
  __pyx_v_f = NULL;

  /* "numpy.pxd":240
 *             cdef int t
 *             cdef char* f = NULL
 *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
 *             cdef list stack
 *             cdef int offset
 */
  __pyx_t_4 = ((PyObject *)__pyx_v_self->descr);
  __Pyx_INCREF(__pyx_t_4);
  __pyx_v_descr = ((PyArray_Descr *)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "numpy.pxd":244
 *             cdef int offset
 * 
 *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
 * 
 *             if not hasfields and not copy_shape:
 */
  __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);

  /* "numpy.pxd":246
 *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
 * 
 *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
 *                 # do not call releasebuffer
 *                 info.obj = None
 */
  __pyx_t_2 = (!__pyx_v_hasfields);
  if (__pyx_t_2) {
    __pyx_t_3 = (!__pyx_v_copy_shape);
    __pyx_t_1 = __pyx_t_3;
  } else {
    __pyx_t_1 = __pyx_t_2;
  }
  if (__pyx_t_1) {

    /* "numpy.pxd":248
 *             if not hasfields and not copy_shape:
 *                 # do not call releasebuffer
 *                 info.obj = None             # <<<<<<<<<<<<<<
 *             else:
 *                 # need to call releasebuffer
 */
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj);
    __pyx_v_info->obj = Py_None;
    goto __pyx_L10;
  }
  /*else*/ {

    /* "numpy.pxd":251
 *             else:
 *                 # need to call releasebuffer
 *                 info.obj = self             # <<<<<<<<<<<<<<
 * 
 *             if not hasfields:
 */
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj);
    __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
  }
  __pyx_L10:;

  /* "numpy.pxd":253
 *                 info.obj = self
 * 
 *             if not hasfields:             # <<<<<<<<<<<<<<
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 */
  __pyx_t_1 = (!__pyx_v_hasfields);
  if (__pyx_t_1) {

    /* "numpy.pxd":254
 * 
 *             if not hasfields:
 *                 t = descr.type_num             # <<<<<<<<<<<<<<
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 */
    __pyx_t_5 = __pyx_v_descr->type_num;
    __pyx_v_t = __pyx_t_5;

    /* "numpy.pxd":255
 *             if not hasfields:
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_1 = (__pyx_v_descr->byteorder == '>');
    if (__pyx_t_1) {
      __pyx_t_2 = __pyx_v_little_endian;
    } else {
      __pyx_t_2 = __pyx_t_1;
    }
    if (!__pyx_t_2) {

      /* "numpy.pxd":256
 *                 t = descr.type_num
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 */
      __pyx_t_1 = (__pyx_v_descr->byteorder == '<');
      if (__pyx_t_1) {
        __pyx_t_3 = (!__pyx_v_little_endian);
        __pyx_t_7 = __pyx_t_3;
      } else {
        __pyx_t_7 = __pyx_t_1;
      }
      __pyx_t_1 = __pyx_t_7;
    } else {
      __pyx_t_1 = __pyx_t_2;
    }
    if (__pyx_t_1) {

      /* "numpy.pxd":257
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
      __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_204), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L12;
    }
    __pyx_L12:;

    /* "numpy.pxd":258
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_BYTE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__b;
      goto __pyx_L13;
    }

    /* "numpy.pxd":259
 *                     raise ValueError(u"Non-native byte order not supported")
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_UBYTE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__B;
      goto __pyx_L13;
    }

    /* "numpy.pxd":260
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_SHORT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__h;
      goto __pyx_L13;
    }

    /* "numpy.pxd":261
 *                 elif t == NPY_UBYTE:       f = "B"
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_USHORT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__H;
      goto __pyx_L13;
    }

    /* "numpy.pxd":262
 *                 elif t == NPY_SHORT:       f = "h"
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_INT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__i;
      goto __pyx_L13;
    }

    /* "numpy.pxd":263
 *                 elif t == NPY_USHORT:      f = "H"
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_UINT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__I;
      goto __pyx_L13;
    }

    /* "numpy.pxd":264
 *                 elif t == NPY_INT:         f = "i"
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_LONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__l;
      goto __pyx_L13;
    }

    /* "numpy.pxd":265
 *                 elif t == NPY_UINT:        f = "I"
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_ULONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__L;
      goto __pyx_L13;
    }

    /* "numpy.pxd":266
 *                 elif t == NPY_LONG:        f = "l"
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_LONGLONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__q;
      goto __pyx_L13;
    }

    /* "numpy.pxd":267
 *                 elif t == NPY_ULONG:       f = "L"
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_ULONGLONG);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Q;
      goto __pyx_L13;
    }

    /* "numpy.pxd":268
 *                 elif t == NPY_LONGLONG:    f = "q"
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_FLOAT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__f;
      goto __pyx_L13;
    }

    /* "numpy.pxd":269
 *                 elif t == NPY_ULONGLONG:   f = "Q"
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_DOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__d;
      goto __pyx_L13;
    }

    /* "numpy.pxd":270
 *                 elif t == NPY_FLOAT:       f = "f"
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_LONGDOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__g;
      goto __pyx_L13;
    }

    /* "numpy.pxd":271
 *                 elif t == NPY_DOUBLE:      f = "d"
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_CFLOAT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Zf;
      goto __pyx_L13;
    }

    /* "numpy.pxd":272
 *                 elif t == NPY_LONGDOUBLE:  f = "g"
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"
 */
    __pyx_t_1 = (__pyx_v_t == NPY_CDOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Zd;
      goto __pyx_L13;
    }

    /* "numpy.pxd":273
 *                 elif t == NPY_CFLOAT:      f = "Zf"
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 */
    __pyx_t_1 = (__pyx_v_t == NPY_CLONGDOUBLE);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__Zg;
      goto __pyx_L13;
    }

    /* "numpy.pxd":274
 *                 elif t == NPY_CDOUBLE:     f = "Zd"
 *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
 *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
    __pyx_t_1 = (__pyx_v_t == NPY_OBJECT);
    if (__pyx_t_1) {
      __pyx_v_f = __pyx_k__O;
      goto __pyx_L13;
    }
    /*else*/ {

      /* "numpy.pxd":276
 *                 elif t == NPY_OBJECT:      f = "O"
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *                 info.format = f
 *                 return
 */
      __pyx_t_4 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_8 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_205), __pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_8));
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_8));
      __Pyx_GIVEREF(((PyObject *)__pyx_t_8));
      __pyx_t_8 = 0;
      __pyx_t_8 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_L13:;

    /* "numpy.pxd":277
 *                 else:
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f             # <<<<<<<<<<<<<<
 *                 return
 *             else:
 */
    __pyx_v_info->format = __pyx_v_f;

    /* "numpy.pxd":278
 *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *                 info.format = f
 *                 return             # <<<<<<<<<<<<<<
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L11;
  }
  /*else*/ {

    /* "numpy.pxd":280
 *                 return
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0
 */
    __pyx_v_info->format = ((char *)malloc(255));

    /* "numpy.pxd":281
 *             else:
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 *                 info.format[0] = c'^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
 *                 offset = 0
 *                 f = _util_dtypestring(descr, info.format + 1,
 */
    (__pyx_v_info->format[0]) = '^';

    /* "numpy.pxd":282
 *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
 *                 info.format[0] = c'^' # Native data types, manual alignment
 *                 offset = 0             # <<<<<<<<<<<<<<
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 */
    __pyx_v_offset = 0;

    /* "numpy.pxd":285
 *                 f = _util_dtypestring(descr, info.format + 1,
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)             # <<<<<<<<<<<<<<
 *                 f[0] = c'\0' # Terminate format string
 * 
 */
    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 283; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_v_f = __pyx_t_9;

    /* "numpy.pxd":286
 *                                       info.format + _buffer_format_string_len,
 *                                       &offset)
 *                 f[0] = c'\0' # Terminate format string             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 */
    (__pyx_v_f[0]) = '\x00';
  }
  __pyx_L11:;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("numpy.ndarray.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  if (__pyx_v_info != NULL && __pyx_v_info->obj != NULL) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
  }
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(Py_None);
    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
  }
  __pyx_L2:;
  __Pyx_XDECREF((PyObject *)__pyx_v_descr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static CYTHON_UNUSED void __pyx_pw_5numpy_7ndarray_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
  __pyx_pf_5numpy_7ndarray_2__releasebuffer__(((PyArrayObject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));
  __Pyx_RefNannyFinishContext();
}

/* "numpy.pxd":288
 *                 f[0] = c'\0' # Terminate format string
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)
 */

static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__releasebuffer__", 0);

  /* "numpy.pxd":289
 * 
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 */
  __pyx_t_1 = PyArray_HASFIELDS(__pyx_v_self);
  if (__pyx_t_1) {

    /* "numpy.pxd":290
 *         def __releasebuffer__(ndarray self, Py_buffer* info):
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 stdlib.free(info.strides)
 */
    free(__pyx_v_info->format);
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "numpy.pxd":291
 *             if PyArray_HASFIELDS(self):
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
 *                 stdlib.free(info.strides)
 *                 # info.shape was stored after info.strides in the same block
 */
  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
  if (__pyx_t_1) {

    /* "numpy.pxd":292
 *                 stdlib.free(info.format)
 *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
 *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<
 *                 # info.shape was stored after info.strides in the same block
 * 
 */
    free(__pyx_v_info->strides);
    goto __pyx_L4;
  }
  __pyx_L4:;

  __Pyx_RefNannyFinishContext();
}

/* "numpy.pxd":768
 * ctypedef npy_cdouble     complex_t
 * 
 * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);

  /* "numpy.pxd":769
 * 
 * cdef inline object PyArray_MultiIterNew1(a):
 *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew1", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":771
 *     return PyArray_MultiIterNew(1, <void*>a)
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);

  /* "numpy.pxd":772
 * 
 * cdef inline object PyArray_MultiIterNew2(a, b):
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 772; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":774
 *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);

  /* "numpy.pxd":775
 * 
 * cdef inline object PyArray_MultiIterNew3(a, b, c):
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew3", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":777
 *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);

  /* "numpy.pxd":778
 * 
 * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew4", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":780
 *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);

  /* "numpy.pxd":781
 * 
 * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 781; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("numpy.PyArray_MultiIterNew5", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":783
 *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
 * 
 * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
 *     # Recursive utility function used in __getbuffer__ to get format
 *     # string. The new location in the format string is returned.
 */

static CYTHON_INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *__pyx_v_descr, char *__pyx_v_f, char *__pyx_v_end, int *__pyx_v_offset) {
  PyArray_Descr *__pyx_v_child = 0;
  int __pyx_v_endian_detector;
  int __pyx_v_little_endian;
  PyObject *__pyx_v_fields = 0;
  PyObject *__pyx_v_childname = NULL;
  PyObject *__pyx_v_new_offset = NULL;
  PyObject *__pyx_v_t = NULL;
  char *__pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *(*__pyx_t_6)(PyObject *);
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  long __pyx_t_11;
  char *__pyx_t_12;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_util_dtypestring", 0);

  /* "numpy.pxd":790
 *     cdef int delta_offset
 *     cdef tuple i
 *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
 *     cdef tuple fields
 */
  __pyx_v_endian_detector = 1;

  /* "numpy.pxd":791
 *     cdef tuple i
 *     cdef int endian_detector = 1
 *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
 *     cdef tuple fields
 * 
 */
  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);

  /* "numpy.pxd":794
 *     cdef tuple fields
 * 
 *     for childname in descr.names:             # <<<<<<<<<<<<<<
 *         fields = descr.fields[childname]
 *         child, new_offset = fields
 */
  if (unlikely(((PyObject *)__pyx_v_descr->names) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_1 = ((PyObject *)__pyx_v_descr->names); __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_COMPILING_IN_CPYTHON
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 794; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    #endif
    __Pyx_XDECREF(__pyx_v_childname);
    __pyx_v_childname = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "numpy.pxd":795
 * 
 *     for childname in descr.names:
 *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
 *         child, new_offset = fields
 * 
 */
    __pyx_t_3 = PyObject_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (!__pyx_t_3) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected tuple, got %.200s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 795; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_XDECREF(((PyObject *)__pyx_v_fields));
    __pyx_v_fields = ((PyObject*)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "numpy.pxd":796
 *     for childname in descr.names:
 *         fields = descr.fields[childname]
 *         child, new_offset = fields             # <<<<<<<<<<<<<<
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 */
    if (likely(PyTuple_CheckExact(((PyObject *)__pyx_v_fields)))) {
      PyObject* sequence = ((PyObject *)__pyx_v_fields);
      #if CYTHON_COMPILING_IN_CPYTHON
      Py_ssize_t size = Py_SIZE(sequence);
      #else
      Py_ssize_t size = PySequence_Size(sequence);
      #endif
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      #if CYTHON_COMPILING_IN_CPYTHON
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      #else
      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      #endif
    } else if (1) {
      __Pyx_RaiseNoneNotIterableError(); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    } else
    {
      Py_ssize_t index = -1;
      __pyx_t_5 = PyObject_GetIter(((PyObject *)__pyx_v_fields)); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = Py_TYPE(__pyx_t_5)->tp_iternext;
      index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_3);
      index = 1; __pyx_t_4 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_4)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_4);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 2) < 0) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_t_6 = NULL;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      goto __pyx_L6_unpacking_done;
      __pyx_L5_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_6 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_L6_unpacking_done:;
    }
    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 796; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_XDECREF(((PyObject *)__pyx_v_child));
    __pyx_v_child = ((PyArray_Descr *)__pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_XDECREF(__pyx_v_new_offset);
    __pyx_v_new_offset = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "numpy.pxd":798
 *         child, new_offset = fields
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 */
    __pyx_t_4 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_3); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyNumber_Subtract(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_int_15, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 798; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_7) {

      /* "numpy.pxd":799
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 */
      __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_207), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L7;
    }
    __pyx_L7:;

    /* "numpy.pxd":801
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
 * 
 *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")
 */
    __pyx_t_7 = (__pyx_v_child->byteorder == '>');
    if (__pyx_t_7) {
      __pyx_t_8 = __pyx_v_little_endian;
    } else {
      __pyx_t_8 = __pyx_t_7;
    }
    if (!__pyx_t_8) {

      /* "numpy.pxd":802
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
 *             raise ValueError(u"Non-native byte order not supported")
 *             # One could encode it in the format string and have Cython
 */
      __pyx_t_7 = (__pyx_v_child->byteorder == '<');
      if (__pyx_t_7) {
        __pyx_t_9 = (!__pyx_v_little_endian);
        __pyx_t_10 = __pyx_t_9;
      } else {
        __pyx_t_10 = __pyx_t_7;
      }
      __pyx_t_7 = __pyx_t_10;
    } else {
      __pyx_t_7 = __pyx_t_8;
    }
    if (__pyx_t_7) {

      /* "numpy.pxd":803
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *             # One could encode it in the format string and have Cython
 *             # complain instead, BUT: < and > in format strings also imply
 */
      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_k_tuple_208), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "numpy.pxd":813
 * 
 *         # Output padding bytes
 *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 */
    while (1) {
      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (!__pyx_t_7) break;

      /* "numpy.pxd":814
 *         # Output padding bytes
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
 *             f += 1
 *             offset[0] += 1
 */
      (__pyx_v_f[0]) = 120;

      /* "numpy.pxd":815
 *         while offset[0] < new_offset:
 *             f[0] = 120 # "x"; pad byte
 *             f += 1             # <<<<<<<<<<<<<<
 *             offset[0] += 1
 * 
 */
      __pyx_v_f = (__pyx_v_f + 1);

      /* "numpy.pxd":816
 *             f[0] = 120 # "x"; pad byte
 *             f += 1
 *             offset[0] += 1             # <<<<<<<<<<<<<<
 * 
 *         offset[0] += child.itemsize
 */
      __pyx_t_11 = 0;
      (__pyx_v_offset[__pyx_t_11]) = ((__pyx_v_offset[__pyx_t_11]) + 1);
    }

    /* "numpy.pxd":818
 *             offset[0] += 1
 * 
 *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
 * 
 *         if not PyDataType_HASFIELDS(child):
 */
    __pyx_t_11 = 0;
    (__pyx_v_offset[__pyx_t_11]) = ((__pyx_v_offset[__pyx_t_11]) + __pyx_v_child->elsize);

    /* "numpy.pxd":820
 *         offset[0] += child.itemsize
 * 
 *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
 *             t = child.type_num
 *             if end - f < 5:
 */
    __pyx_t_7 = (!PyDataType_HASFIELDS(__pyx_v_child));
    if (__pyx_t_7) {

      /* "numpy.pxd":821
 * 
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num             # <<<<<<<<<<<<<<
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")
 */
      __pyx_t_3 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_XDECREF(__pyx_v_t);
      __pyx_v_t = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "numpy.pxd":822
 *         if not PyDataType_HASFIELDS(child):
 *             t = child.type_num
 *             if end - f < 5:             # <<<<<<<<<<<<<<
 *                 raise RuntimeError(u"Format string allocated too short.")
 * 
 */
      __pyx_t_7 = ((__pyx_v_end - __pyx_v_f) < 5);
      if (__pyx_t_7) {

        /* "numpy.pxd":823
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
        __pyx_t_3 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_210), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L12;
      }
      __pyx_L12:;

      /* "numpy.pxd":826
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 826; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 98;
        goto __pyx_L13;
      }

      /* "numpy.pxd":827
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 827; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 66;
        goto __pyx_L13;
      }

      /* "numpy.pxd":828
 *             if   t == NPY_BYTE:        f[0] =  98 #"b"
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 828; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 104;
        goto __pyx_L13;
      }

      /* "numpy.pxd":829
 *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 829; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 72;
        goto __pyx_L13;
      }

      /* "numpy.pxd":830
 *             elif t == NPY_SHORT:       f[0] = 104 #"h"
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 105;
        goto __pyx_L13;
      }

      /* "numpy.pxd":831
 *             elif t == NPY_USHORT:      f[0] =  72 #"H"
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 831; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 73;
        goto __pyx_L13;
      }

      /* "numpy.pxd":832
 *             elif t == NPY_INT:         f[0] = 105 #"i"
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 108;
        goto __pyx_L13;
      }

      /* "numpy.pxd":833
 *             elif t == NPY_UINT:        f[0] =  73 #"I"
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 833; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 76;
        goto __pyx_L13;
      }

      /* "numpy.pxd":834
 *             elif t == NPY_LONG:        f[0] = 108 #"l"
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 834; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 113;
        goto __pyx_L13;
      }

      /* "numpy.pxd":835
 *             elif t == NPY_ULONG:       f[0] = 76  #"L"
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 */
      __pyx_t_5 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 81;
        goto __pyx_L13;
      }

      /* "numpy.pxd":836
 *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 836; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 102;
        goto __pyx_L13;
      }

      /* "numpy.pxd":837
 *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 */
      __pyx_t_5 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 837; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 100;
        goto __pyx_L13;
      }

      /* "numpy.pxd":838
 *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 */
      __pyx_t_3 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 838; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 103;
        goto __pyx_L13;
      }

      /* "numpy.pxd":839
 *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 */
      __pyx_t_5 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 102;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L13;
      }

      /* "numpy.pxd":840
 *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 */
      __pyx_t_3 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 840; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 100;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L13;
      }

      /* "numpy.pxd":841
 *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 */
      __pyx_t_5 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 841; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 90;
        (__pyx_v_f[1]) = 103;
        __pyx_v_f = (__pyx_v_f + 1);
        goto __pyx_L13;
      }

      /* "numpy.pxd":842
 *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
 *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 */
      __pyx_t_3 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_7) {
        (__pyx_v_f[0]) = 79;
        goto __pyx_L13;
      }
      /*else*/ {

        /* "numpy.pxd":844
 *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
 *             f += 1
 *         else:
 */
        __pyx_t_5 = PyNumber_Remainder(((PyObject *)__pyx_kp_u_205), __pyx_v_t); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_5));
        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_t_5));
        __Pyx_GIVEREF(((PyObject *)__pyx_t_5));
        __pyx_t_5 = 0;
        __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
        __Pyx_Raise(__pyx_t_5, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __pyx_L13:;

      /* "numpy.pxd":845
 *             else:
 *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
 *             f += 1             # <<<<<<<<<<<<<<
 *         else:
 *             # Cython ignores struct boundary information ("T{...}"),
 */
      __pyx_v_f = (__pyx_v_f + 1);
      goto __pyx_L11;
    }
    /*else*/ {

      /* "numpy.pxd":849
 *             # Cython ignores struct boundary information ("T{...}"),
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
 *     return f
 * 
 */
      __pyx_t_12 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_12 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 849; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_v_f = __pyx_t_12;
    }
    __pyx_L11:;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "numpy.pxd":850
 *             # so don't output it
 *             f = _util_dtypestring(child, f, end, offset)
 *     return f             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_f;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("numpy._util_dtypestring", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_child);
  __Pyx_XDECREF(__pyx_v_fields);
  __Pyx_XDECREF(__pyx_v_childname);
  __Pyx_XDECREF(__pyx_v_new_offset);
  __Pyx_XDECREF(__pyx_v_t);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "numpy.pxd":965
 * 
 * 
 * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
 *      cdef PyObject* baseptr
 *      if base is None:
 */

static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
  PyObject *__pyx_v_baseptr;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("set_array_base", 0);

  /* "numpy.pxd":967
 * cdef inline void set_array_base(ndarray arr, object base):
 *      cdef PyObject* baseptr
 *      if base is None:             # <<<<<<<<<<<<<<
 *          baseptr = NULL
 *      else:
 */
  __pyx_t_1 = (__pyx_v_base == Py_None);
  if (__pyx_t_1) {

    /* "numpy.pxd":968
 *      cdef PyObject* baseptr
 *      if base is None:
 *          baseptr = NULL             # <<<<<<<<<<<<<<
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!
 */
    __pyx_v_baseptr = NULL;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "numpy.pxd":970
 *          baseptr = NULL
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)
 */
    Py_INCREF(__pyx_v_base);

    /* "numpy.pxd":971
 *      else:
 *          Py_INCREF(base) # important to do this before decref below!
 *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<
 *      Py_XDECREF(arr.base)
 *      arr.base = baseptr
 */
    __pyx_v_baseptr = ((PyObject *)__pyx_v_base);
  }
  __pyx_L3:;

  /* "numpy.pxd":972
 *          Py_INCREF(base) # important to do this before decref below!
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<
 *      arr.base = baseptr
 * 
 */
  Py_XDECREF(__pyx_v_arr->base);

  /* "numpy.pxd":973
 *          baseptr = <PyObject*>base
 *      Py_XDECREF(arr.base)
 *      arr.base = baseptr             # <<<<<<<<<<<<<<
 * 
 * cdef inline object get_array_base(ndarray arr):
 */
  __pyx_v_arr->base = __pyx_v_baseptr;

  __Pyx_RefNannyFinishContext();
}

/* "numpy.pxd":975
 *      arr.base = baseptr
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     if arr.base is NULL:
 *         return None
 */

static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("get_array_base", 0);

  /* "numpy.pxd":976
 * 
 * cdef inline object get_array_base(ndarray arr):
 *     if arr.base is NULL:             # <<<<<<<<<<<<<<
 *         return None
 *     else:
 */
  __pyx_t_1 = (__pyx_v_arr->base == NULL);
  if (__pyx_t_1) {

    /* "numpy.pxd":977
 * cdef inline object get_array_base(ndarray arr):
 *     if arr.base is NULL:
 *         return None             # <<<<<<<<<<<<<<
 *     else:
 *         return <object>arr.base
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  /*else*/ {

    /* "numpy.pxd":979
 *         return None
 *     else:
 *         return <object>arr.base             # <<<<<<<<<<<<<<
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));
    __pyx_r = ((PyObject *)__pyx_v_arr->base);
    goto __pyx_L0;
  }
  __pyx_L3:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    __Pyx_NAMESTR("func"),
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
  {&__pyx_kp_s_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 1, 0},
  {&__pyx_n_s_102, __pyx_k_102, sizeof(__pyx_k_102), 0, 0, 1, 1},
  {&__pyx_kp_s_11, __pyx_k_11, sizeof(__pyx_k_11), 0, 0, 1, 0},
  {&__pyx_n_s_110, __pyx_k_110, sizeof(__pyx_k_110), 0, 0, 1, 1},
  {&__pyx_n_s_112, __pyx_k_112, sizeof(__pyx_k_112), 0, 0, 1, 1},
  {&__pyx_kp_s_12, __pyx_k_12, sizeof(__pyx_k_12), 0, 0, 1, 0},
  {&__pyx_n_s_134, __pyx_k_134, sizeof(__pyx_k_134), 0, 0, 1, 1},
  {&__pyx_kp_s_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 0, 1, 0},
  {&__pyx_kp_s_143, __pyx_k_143, sizeof(__pyx_k_143), 0, 0, 1, 0},
  {&__pyx_kp_s_144, __pyx_k_144, sizeof(__pyx_k_144), 0, 0, 1, 0},
  {&__pyx_kp_s_15, __pyx_k_15, sizeof(__pyx_k_15), 0, 0, 1, 0},
  {&__pyx_kp_s_16, __pyx_k_16, sizeof(__pyx_k_16), 0, 0, 1, 0},
  {&__pyx_kp_s_17, __pyx_k_17, sizeof(__pyx_k_17), 0, 0, 1, 0},
  {&__pyx_n_s_171, __pyx_k_171, sizeof(__pyx_k_171), 0, 0, 1, 1},
  {&__pyx_n_s_172, __pyx_k_172, sizeof(__pyx_k_172), 0, 0, 1, 1},
  {&__pyx_n_s_173, __pyx_k_173, sizeof(__pyx_k_173), 0, 0, 1, 1},
  {&__pyx_kp_u_199, __pyx_k_199, sizeof(__pyx_k_199), 0, 1, 0, 0},
  {&__pyx_kp_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 0},
  {&__pyx_kp_u_201, __pyx_k_201, sizeof(__pyx_k_201), 0, 1, 0, 0},
  {&__pyx_kp_u_203, __pyx_k_203, sizeof(__pyx_k_203), 0, 1, 0, 0},
  {&__pyx_kp_u_205, __pyx_k_205, sizeof(__pyx_k_205), 0, 1, 0, 0},
  {&__pyx_kp_u_206, __pyx_k_206, sizeof(__pyx_k_206), 0, 1, 0, 0},
  {&__pyx_kp_u_209, __pyx_k_209, sizeof(__pyx_k_209), 0, 1, 0, 0},
  {&__pyx_kp_s_213, __pyx_k_213, sizeof(__pyx_k_213), 0, 0, 1, 0},
  {&__pyx_n_s_214, __pyx_k_214, sizeof(__pyx_k_214), 0, 0, 1, 1},
  {&__pyx_n_s_239, __pyx_k_239, sizeof(__pyx_k_239), 0, 0, 1, 1},
  {&__pyx_n_s_240, __pyx_k_240, sizeof(__pyx_k_240), 0, 0, 1, 1},
  {&__pyx_n_s_241, __pyx_k_241, sizeof(__pyx_k_241), 0, 0, 1, 1},
  {&__pyx_kp_s_28, __pyx_k_28, sizeof(__pyx_k_28), 0, 0, 1, 0},
  {&__pyx_kp_s_29, __pyx_k_29, sizeof(__pyx_k_29), 0, 0, 1, 0},
  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
  {&__pyx_n_s_42, __pyx_k_42, sizeof(__pyx_k_42), 0, 0, 1, 1},
  {&__pyx_n_s_48, __pyx_k_48, sizeof(__pyx_k_48), 0, 0, 1, 1},
  {&__pyx_kp_s_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 1, 0},
  {&__pyx_n_s_50, __pyx_k_50, sizeof(__pyx_k_50), 0, 0, 1, 1},
  {&__pyx_n_s_53, __pyx_k_53, sizeof(__pyx_k_53), 0, 0, 1, 1},
  {&__pyx_n_s_59, __pyx_k_59, sizeof(__pyx_k_59), 0, 0, 1, 1},
  {&__pyx_kp_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 0},
  {&__pyx_n_s_62, __pyx_k_62, sizeof(__pyx_k_62), 0, 0, 1, 1},
  {&__pyx_n_s_64, __pyx_k_64, sizeof(__pyx_k_64), 0, 0, 1, 1},
  {&__pyx_kp_s_7, __pyx_k_7, sizeof(__pyx_k_7), 0, 0, 1, 0},
  {&__pyx_n_s_74, __pyx_k_74, sizeof(__pyx_k_74), 0, 0, 1, 1},
  {&__pyx_n_s_77, __pyx_k_77, sizeof(__pyx_k_77), 0, 0, 1, 1},
  {&__pyx_kp_s_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 0, 1, 0},
  {&__pyx_n_s_80, __pyx_k_80, sizeof(__pyx_k_80), 0, 0, 1, 1},
  {&__pyx_n_s_83, __pyx_k_83, sizeof(__pyx_k_83), 0, 0, 1, 1},
  {&__pyx_n_s_89, __pyx_k_89, sizeof(__pyx_k_89), 0, 0, 1, 1},
  {&__pyx_kp_s_9, __pyx_k_9, sizeof(__pyx_k_9), 0, 0, 1, 0},
  {&__pyx_n_s_95, __pyx_k_95, sizeof(__pyx_k_95), 0, 0, 1, 1},
  {&__pyx_n_s_97, __pyx_k_97, sizeof(__pyx_k_97), 0, 0, 1, 1},
  {&__pyx_n_s__ACOS, __pyx_k__ACOS, sizeof(__pyx_k__ACOS), 0, 0, 1, 1},
  {&__pyx_n_s__AD, __pyx_k__AD, sizeof(__pyx_k__AD), 0, 0, 1, 1},
  {&__pyx_n_s__ADD, __pyx_k__ADD, sizeof(__pyx_k__ADD), 0, 0, 1, 1},
  {&__pyx_n_s__ADOSC, __pyx_k__ADOSC, sizeof(__pyx_k__ADOSC), 0, 0, 1, 1},
  {&__pyx_n_s__ADX, __pyx_k__ADX, sizeof(__pyx_k__ADX), 0, 0, 1, 1},
  {&__pyx_n_s__ADXR, __pyx_k__ADXR, sizeof(__pyx_k__ADXR), 0, 0, 1, 1},
  {&__pyx_n_s__APO, __pyx_k__APO, sizeof(__pyx_k__APO), 0, 0, 1, 1},
  {&__pyx_n_s__AROON, __pyx_k__AROON, sizeof(__pyx_k__AROON), 0, 0, 1, 1},
  {&__pyx_n_s__AROONOSC, __pyx_k__AROONOSC, sizeof(__pyx_k__AROONOSC), 0, 0, 1, 1},
  {&__pyx_n_s__ASIN, __pyx_k__ASIN, sizeof(__pyx_k__ASIN), 0, 0, 1, 1},
  {&__pyx_n_s__ATAN, __pyx_k__ATAN, sizeof(__pyx_k__ATAN), 0, 0, 1, 1},
  {&__pyx_n_s__ATR, __pyx_k__ATR, sizeof(__pyx_k__ATR), 0, 0, 1, 1},
  {&__pyx_n_s__AVGPRICE, __pyx_k__AVGPRICE, sizeof(__pyx_k__AVGPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__BBANDS, __pyx_k__BBANDS, sizeof(__pyx_k__BBANDS), 0, 0, 1, 1},
  {&__pyx_n_s__BETA, __pyx_k__BETA, sizeof(__pyx_k__BETA), 0, 0, 1, 1},
  {&__pyx_n_s__BOP, __pyx_k__BOP, sizeof(__pyx_k__BOP), 0, 0, 1, 1},
  {&__pyx_n_s__CCI, __pyx_k__CCI, sizeof(__pyx_k__CCI), 0, 0, 1, 1},
  {&__pyx_n_s__CDL2CROWS, __pyx_k__CDL2CROWS, sizeof(__pyx_k__CDL2CROWS), 0, 0, 1, 1},
  {&__pyx_n_s__CDL3BLACKCROWS, __pyx_k__CDL3BLACKCROWS, sizeof(__pyx_k__CDL3BLACKCROWS), 0, 0, 1, 1},
  {&__pyx_n_s__CDL3INSIDE, __pyx_k__CDL3INSIDE, sizeof(__pyx_k__CDL3INSIDE), 0, 0, 1, 1},
  {&__pyx_n_s__CDL3LINESTRIKE, __pyx_k__CDL3LINESTRIKE, sizeof(__pyx_k__CDL3LINESTRIKE), 0, 0, 1, 1},
  {&__pyx_n_s__CDL3OUTSIDE, __pyx_k__CDL3OUTSIDE, sizeof(__pyx_k__CDL3OUTSIDE), 0, 0, 1, 1},
  {&__pyx_n_s__CDL3STARSINSOUTH, __pyx_k__CDL3STARSINSOUTH, sizeof(__pyx_k__CDL3STARSINSOUTH), 0, 0, 1, 1},
  {&__pyx_n_s__CDL3WHITESOLDIERS, __pyx_k__CDL3WHITESOLDIERS, sizeof(__pyx_k__CDL3WHITESOLDIERS), 0, 0, 1, 1},
  {&__pyx_n_s__CDLABANDONEDBABY, __pyx_k__CDLABANDONEDBABY, sizeof(__pyx_k__CDLABANDONEDBABY), 0, 0, 1, 1},
  {&__pyx_n_s__CDLADVANCEBLOCK, __pyx_k__CDLADVANCEBLOCK, sizeof(__pyx_k__CDLADVANCEBLOCK), 0, 0, 1, 1},
  {&__pyx_n_s__CDLBELTHOLD, __pyx_k__CDLBELTHOLD, sizeof(__pyx_k__CDLBELTHOLD), 0, 0, 1, 1},
  {&__pyx_n_s__CDLBREAKAWAY, __pyx_k__CDLBREAKAWAY, sizeof(__pyx_k__CDLBREAKAWAY), 0, 0, 1, 1},
  {&__pyx_n_s__CDLCLOSINGMARUBOZU, __pyx_k__CDLCLOSINGMARUBOZU, sizeof(__pyx_k__CDLCLOSINGMARUBOZU), 0, 0, 1, 1},
  {&__pyx_n_s__CDLCONCEALBABYSWALL, __pyx_k__CDLCONCEALBABYSWALL, sizeof(__pyx_k__CDLCONCEALBABYSWALL), 0, 0, 1, 1},
  {&__pyx_n_s__CDLCOUNTERATTACK, __pyx_k__CDLCOUNTERATTACK, sizeof(__pyx_k__CDLCOUNTERATTACK), 0, 0, 1, 1},
  {&__pyx_n_s__CDLDARKCLOUDCOVER, __pyx_k__CDLDARKCLOUDCOVER, sizeof(__pyx_k__CDLDARKCLOUDCOVER), 0, 0, 1, 1},
  {&__pyx_n_s__CDLDOJI, __pyx_k__CDLDOJI, sizeof(__pyx_k__CDLDOJI), 0, 0, 1, 1},
  {&__pyx_n_s__CDLDOJISTAR, __pyx_k__CDLDOJISTAR, sizeof(__pyx_k__CDLDOJISTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLDRAGONFLYDOJI, __pyx_k__CDLDRAGONFLYDOJI, sizeof(__pyx_k__CDLDRAGONFLYDOJI), 0, 0, 1, 1},
  {&__pyx_n_s__CDLENGULFING, __pyx_k__CDLENGULFING, sizeof(__pyx_k__CDLENGULFING), 0, 0, 1, 1},
  {&__pyx_n_s__CDLEVENINGDOJISTAR, __pyx_k__CDLEVENINGDOJISTAR, sizeof(__pyx_k__CDLEVENINGDOJISTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLEVENINGSTAR, __pyx_k__CDLEVENINGSTAR, sizeof(__pyx_k__CDLEVENINGSTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLGAPSIDESIDEWHITE, __pyx_k__CDLGAPSIDESIDEWHITE, sizeof(__pyx_k__CDLGAPSIDESIDEWHITE), 0, 0, 1, 1},
  {&__pyx_n_s__CDLGRAVESTONEDOJI, __pyx_k__CDLGRAVESTONEDOJI, sizeof(__pyx_k__CDLGRAVESTONEDOJI), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHAMMER, __pyx_k__CDLHAMMER, sizeof(__pyx_k__CDLHAMMER), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHANGINGMAN, __pyx_k__CDLHANGINGMAN, sizeof(__pyx_k__CDLHANGINGMAN), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHARAMI, __pyx_k__CDLHARAMI, sizeof(__pyx_k__CDLHARAMI), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHARAMICROSS, __pyx_k__CDLHARAMICROSS, sizeof(__pyx_k__CDLHARAMICROSS), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHIGHWAVE, __pyx_k__CDLHIGHWAVE, sizeof(__pyx_k__CDLHIGHWAVE), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHIKKAKE, __pyx_k__CDLHIKKAKE, sizeof(__pyx_k__CDLHIKKAKE), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHIKKAKEMOD, __pyx_k__CDLHIKKAKEMOD, sizeof(__pyx_k__CDLHIKKAKEMOD), 0, 0, 1, 1},
  {&__pyx_n_s__CDLHOMINGPIGEON, __pyx_k__CDLHOMINGPIGEON, sizeof(__pyx_k__CDLHOMINGPIGEON), 0, 0, 1, 1},
  {&__pyx_n_s__CDLIDENTICAL3CROWS, __pyx_k__CDLIDENTICAL3CROWS, sizeof(__pyx_k__CDLIDENTICAL3CROWS), 0, 0, 1, 1},
  {&__pyx_n_s__CDLINNECK, __pyx_k__CDLINNECK, sizeof(__pyx_k__CDLINNECK), 0, 0, 1, 1},
  {&__pyx_n_s__CDLINVERTEDHAMMER, __pyx_k__CDLINVERTEDHAMMER, sizeof(__pyx_k__CDLINVERTEDHAMMER), 0, 0, 1, 1},
  {&__pyx_n_s__CDLKICKING, __pyx_k__CDLKICKING, sizeof(__pyx_k__CDLKICKING), 0, 0, 1, 1},
  {&__pyx_n_s__CDLKICKINGBYLENGTH, __pyx_k__CDLKICKINGBYLENGTH, sizeof(__pyx_k__CDLKICKINGBYLENGTH), 0, 0, 1, 1},
  {&__pyx_n_s__CDLLADDERBOTTOM, __pyx_k__CDLLADDERBOTTOM, sizeof(__pyx_k__CDLLADDERBOTTOM), 0, 0, 1, 1},
  {&__pyx_n_s__CDLLONGLEGGEDDOJI, __pyx_k__CDLLONGLEGGEDDOJI, sizeof(__pyx_k__CDLLONGLEGGEDDOJI), 0, 0, 1, 1},
  {&__pyx_n_s__CDLLONGLINE, __pyx_k__CDLLONGLINE, sizeof(__pyx_k__CDLLONGLINE), 0, 0, 1, 1},
  {&__pyx_n_s__CDLMARUBOZU, __pyx_k__CDLMARUBOZU, sizeof(__pyx_k__CDLMARUBOZU), 0, 0, 1, 1},
  {&__pyx_n_s__CDLMATCHINGLOW, __pyx_k__CDLMATCHINGLOW, sizeof(__pyx_k__CDLMATCHINGLOW), 0, 0, 1, 1},
  {&__pyx_n_s__CDLMATHOLD, __pyx_k__CDLMATHOLD, sizeof(__pyx_k__CDLMATHOLD), 0, 0, 1, 1},
  {&__pyx_n_s__CDLMORNINGDOJISTAR, __pyx_k__CDLMORNINGDOJISTAR, sizeof(__pyx_k__CDLMORNINGDOJISTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLMORNINGSTAR, __pyx_k__CDLMORNINGSTAR, sizeof(__pyx_k__CDLMORNINGSTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLONNECK, __pyx_k__CDLONNECK, sizeof(__pyx_k__CDLONNECK), 0, 0, 1, 1},
  {&__pyx_n_s__CDLPIERCING, __pyx_k__CDLPIERCING, sizeof(__pyx_k__CDLPIERCING), 0, 0, 1, 1},
  {&__pyx_n_s__CDLRICKSHAWMAN, __pyx_k__CDLRICKSHAWMAN, sizeof(__pyx_k__CDLRICKSHAWMAN), 0, 0, 1, 1},
  {&__pyx_n_s__CDLRISEFALL3METHODS, __pyx_k__CDLRISEFALL3METHODS, sizeof(__pyx_k__CDLRISEFALL3METHODS), 0, 0, 1, 1},
  {&__pyx_n_s__CDLSEPARATINGLINES, __pyx_k__CDLSEPARATINGLINES, sizeof(__pyx_k__CDLSEPARATINGLINES), 0, 0, 1, 1},
  {&__pyx_n_s__CDLSHOOTINGSTAR, __pyx_k__CDLSHOOTINGSTAR, sizeof(__pyx_k__CDLSHOOTINGSTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLSHORTLINE, __pyx_k__CDLSHORTLINE, sizeof(__pyx_k__CDLSHORTLINE), 0, 0, 1, 1},
  {&__pyx_n_s__CDLSPINNINGTOP, __pyx_k__CDLSPINNINGTOP, sizeof(__pyx_k__CDLSPINNINGTOP), 0, 0, 1, 1},
  {&__pyx_n_s__CDLSTALLEDPATTERN, __pyx_k__CDLSTALLEDPATTERN, sizeof(__pyx_k__CDLSTALLEDPATTERN), 0, 0, 1, 1},
  {&__pyx_n_s__CDLSTICKSANDWICH, __pyx_k__CDLSTICKSANDWICH, sizeof(__pyx_k__CDLSTICKSANDWICH), 0, 0, 1, 1},
  {&__pyx_n_s__CDLTAKURI, __pyx_k__CDLTAKURI, sizeof(__pyx_k__CDLTAKURI), 0, 0, 1, 1},
  {&__pyx_n_s__CDLTASUKIGAP, __pyx_k__CDLTASUKIGAP, sizeof(__pyx_k__CDLTASUKIGAP), 0, 0, 1, 1},
  {&__pyx_n_s__CDLTHRUSTING, __pyx_k__CDLTHRUSTING, sizeof(__pyx_k__CDLTHRUSTING), 0, 0, 1, 1},
  {&__pyx_n_s__CDLTRISTAR, __pyx_k__CDLTRISTAR, sizeof(__pyx_k__CDLTRISTAR), 0, 0, 1, 1},
  {&__pyx_n_s__CDLUNIQUE3RIVER, __pyx_k__CDLUNIQUE3RIVER, sizeof(__pyx_k__CDLUNIQUE3RIVER), 0, 0, 1, 1},
  {&__pyx_n_s__CDLUPSIDEGAP2CROWS, __pyx_k__CDLUPSIDEGAP2CROWS, sizeof(__pyx_k__CDLUPSIDEGAP2CROWS), 0, 0, 1, 1},
  {&__pyx_n_s__CDLXSIDEGAP3METHODS, __pyx_k__CDLXSIDEGAP3METHODS, sizeof(__pyx_k__CDLXSIDEGAP3METHODS), 0, 0, 1, 1},
  {&__pyx_n_s__CEIL, __pyx_k__CEIL, sizeof(__pyx_k__CEIL), 0, 0, 1, 1},
  {&__pyx_n_s__CMO, __pyx_k__CMO, sizeof(__pyx_k__CMO), 0, 0, 1, 1},
  {&__pyx_n_s__CORREL, __pyx_k__CORREL, sizeof(__pyx_k__CORREL), 0, 0, 1, 1},
  {&__pyx_n_s__COS, __pyx_k__COS, sizeof(__pyx_k__COS), 0, 0, 1, 1},
  {&__pyx_n_s__COSH, __pyx_k__COSH, sizeof(__pyx_k__COSH), 0, 0, 1, 1},
  {&__pyx_n_s__DEMA, __pyx_k__DEMA, sizeof(__pyx_k__DEMA), 0, 0, 1, 1},
  {&__pyx_n_s__DIV, __pyx_k__DIV, sizeof(__pyx_k__DIV), 0, 0, 1, 1},
  {&__pyx_n_s__DX, __pyx_k__DX, sizeof(__pyx_k__DX), 0, 0, 1, 1},
  {&__pyx_n_s__EMA, __pyx_k__EMA, sizeof(__pyx_k__EMA), 0, 0, 1, 1},
  {&__pyx_n_s__EXP, __pyx_k__EXP, sizeof(__pyx_k__EXP), 0, 0, 1, 1},
  {&__pyx_n_s__Exception, __pyx_k__Exception, sizeof(__pyx_k__Exception), 0, 0, 1, 1},
  {&__pyx_n_s__FLOOR, __pyx_k__FLOOR, sizeof(__pyx_k__FLOOR), 0, 0, 1, 1},
  {&__pyx_n_s__HT_DCPERIOD, __pyx_k__HT_DCPERIOD, sizeof(__pyx_k__HT_DCPERIOD), 0, 0, 1, 1},
  {&__pyx_n_s__HT_DCPHASE, __pyx_k__HT_DCPHASE, sizeof(__pyx_k__HT_DCPHASE), 0, 0, 1, 1},
  {&__pyx_n_s__HT_PHASOR, __pyx_k__HT_PHASOR, sizeof(__pyx_k__HT_PHASOR), 0, 0, 1, 1},
  {&__pyx_n_s__HT_SINE, __pyx_k__HT_SINE, sizeof(__pyx_k__HT_SINE), 0, 0, 1, 1},
  {&__pyx_n_s__HT_TRENDLINE, __pyx_k__HT_TRENDLINE, sizeof(__pyx_k__HT_TRENDLINE), 0, 0, 1, 1},
  {&__pyx_n_s__HT_TRENDMODE, __pyx_k__HT_TRENDMODE, sizeof(__pyx_k__HT_TRENDMODE), 0, 0, 1, 1},
  {&__pyx_n_s__KAMA, __pyx_k__KAMA, sizeof(__pyx_k__KAMA), 0, 0, 1, 1},
  {&__pyx_n_s__LINEARREG, __pyx_k__LINEARREG, sizeof(__pyx_k__LINEARREG), 0, 0, 1, 1},
  {&__pyx_n_s__LINEARREG_ANGLE, __pyx_k__LINEARREG_ANGLE, sizeof(__pyx_k__LINEARREG_ANGLE), 0, 0, 1, 1},
  {&__pyx_n_s__LINEARREG_INTERCEPT, __pyx_k__LINEARREG_INTERCEPT, sizeof(__pyx_k__LINEARREG_INTERCEPT), 0, 0, 1, 1},
  {&__pyx_n_s__LINEARREG_SLOPE, __pyx_k__LINEARREG_SLOPE, sizeof(__pyx_k__LINEARREG_SLOPE), 0, 0, 1, 1},
  {&__pyx_n_s__LN, __pyx_k__LN, sizeof(__pyx_k__LN), 0, 0, 1, 1},
  {&__pyx_n_s__LOG10, __pyx_k__LOG10, sizeof(__pyx_k__LOG10), 0, 0, 1, 1},
  {&__pyx_n_s__MA, __pyx_k__MA, sizeof(__pyx_k__MA), 0, 0, 1, 1},
  {&__pyx_n_s__MACD, __pyx_k__MACD, sizeof(__pyx_k__MACD), 0, 0, 1, 1},
  {&__pyx_n_s__MACDEXT, __pyx_k__MACDEXT, sizeof(__pyx_k__MACDEXT), 0, 0, 1, 1},
  {&__pyx_n_s__MACDFIX, __pyx_k__MACDFIX, sizeof(__pyx_k__MACDFIX), 0, 0, 1, 1},
  {&__pyx_n_s__MAMA, __pyx_k__MAMA, sizeof(__pyx_k__MAMA), 0, 0, 1, 1},
  {&__pyx_n_s__MAVP, __pyx_k__MAVP, sizeof(__pyx_k__MAVP), 0, 0, 1, 1},
  {&__pyx_n_s__MAX, __pyx_k__MAX, sizeof(__pyx_k__MAX), 0, 0, 1, 1},
  {&__pyx_n_s__MAXINDEX, __pyx_k__MAXINDEX, sizeof(__pyx_k__MAXINDEX), 0, 0, 1, 1},
  {&__pyx_n_s__MEDPRICE, __pyx_k__MEDPRICE, sizeof(__pyx_k__MEDPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__MFI, __pyx_k__MFI, sizeof(__pyx_k__MFI), 0, 0, 1, 1},
  {&__pyx_n_s__MIDPOINT, __pyx_k__MIDPOINT, sizeof(__pyx_k__MIDPOINT), 0, 0, 1, 1},
  {&__pyx_n_s__MIDPRICE, __pyx_k__MIDPRICE, sizeof(__pyx_k__MIDPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__MIN, __pyx_k__MIN, sizeof(__pyx_k__MIN), 0, 0, 1, 1},
  {&__pyx_n_s__MININDEX, __pyx_k__MININDEX, sizeof(__pyx_k__MININDEX), 0, 0, 1, 1},
  {&__pyx_n_s__MINMAX, __pyx_k__MINMAX, sizeof(__pyx_k__MINMAX), 0, 0, 1, 1},
  {&__pyx_n_s__MINMAXINDEX, __pyx_k__MINMAXINDEX, sizeof(__pyx_k__MINMAXINDEX), 0, 0, 1, 1},
  {&__pyx_n_s__MINUS_DI, __pyx_k__MINUS_DI, sizeof(__pyx_k__MINUS_DI), 0, 0, 1, 1},
  {&__pyx_n_s__MINUS_DM, __pyx_k__MINUS_DM, sizeof(__pyx_k__MINUS_DM), 0, 0, 1, 1},
  {&__pyx_n_s__MOM, __pyx_k__MOM, sizeof(__pyx_k__MOM), 0, 0, 1, 1},
  {&__pyx_n_s__MULT, __pyx_k__MULT, sizeof(__pyx_k__MULT), 0, 0, 1, 1},
  {&__pyx_n_s__NATR, __pyx_k__NATR, sizeof(__pyx_k__NATR), 0, 0, 1, 1},
  {&__pyx_n_s__OBV, __pyx_k__OBV, sizeof(__pyx_k__OBV), 0, 0, 1, 1},
  {&__pyx_n_s__PLUS_DI, __pyx_k__PLUS_DI, sizeof(__pyx_k__PLUS_DI), 0, 0, 1, 1},
  {&__pyx_n_s__PLUS_DM, __pyx_k__PLUS_DM, sizeof(__pyx_k__PLUS_DM), 0, 0, 1, 1},
  {&__pyx_n_s__PPO, __pyx_k__PPO, sizeof(__pyx_k__PPO), 0, 0, 1, 1},
  {&__pyx_n_s__ROC, __pyx_k__ROC, sizeof(__pyx_k__ROC), 0, 0, 1, 1},
  {&__pyx_n_s__ROCP, __pyx_k__ROCP, sizeof(__pyx_k__ROCP), 0, 0, 1, 1},
  {&__pyx_n_s__ROCR, __pyx_k__ROCR, sizeof(__pyx_k__ROCR), 0, 0, 1, 1},
  {&__pyx_n_s__ROCR100, __pyx_k__ROCR100, sizeof(__pyx_k__ROCR100), 0, 0, 1, 1},
  {&__pyx_n_s__RSI, __pyx_k__RSI, sizeof(__pyx_k__RSI), 0, 0, 1, 1},
  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s__SAR, __pyx_k__SAR, sizeof(__pyx_k__SAR), 0, 0, 1, 1},
  {&__pyx_n_s__SAREXT, __pyx_k__SAREXT, sizeof(__pyx_k__SAREXT), 0, 0, 1, 1},
  {&__pyx_n_s__SIN, __pyx_k__SIN, sizeof(__pyx_k__SIN), 0, 0, 1, 1},
  {&__pyx_n_s__SINH, __pyx_k__SINH, sizeof(__pyx_k__SINH), 0, 0, 1, 1},
  {&__pyx_n_s__SMA, __pyx_k__SMA, sizeof(__pyx_k__SMA), 0, 0, 1, 1},
  {&__pyx_n_s__SQRT, __pyx_k__SQRT, sizeof(__pyx_k__SQRT), 0, 0, 1, 1},
  {&__pyx_n_s__STDDEV, __pyx_k__STDDEV, sizeof(__pyx_k__STDDEV), 0, 0, 1, 1},
  {&__pyx_n_s__STOCH, __pyx_k__STOCH, sizeof(__pyx_k__STOCH), 0, 0, 1, 1},
  {&__pyx_n_s__STOCHF, __pyx_k__STOCHF, sizeof(__pyx_k__STOCHF), 0, 0, 1, 1},
  {&__pyx_n_s__STOCHRSI, __pyx_k__STOCHRSI, sizeof(__pyx_k__STOCHRSI), 0, 0, 1, 1},
  {&__pyx_n_s__SUB, __pyx_k__SUB, sizeof(__pyx_k__SUB), 0, 0, 1, 1},
  {&__pyx_n_s__SUM, __pyx_k__SUM, sizeof(__pyx_k__SUM), 0, 0, 1, 1},
  {&__pyx_n_s__T3, __pyx_k__T3, sizeof(__pyx_k__T3), 0, 0, 1, 1},
  {&__pyx_n_s__TAN, __pyx_k__TAN, sizeof(__pyx_k__TAN), 0, 0, 1, 1},
  {&__pyx_n_s__TANH, __pyx_k__TANH, sizeof(__pyx_k__TANH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ACOS, __pyx_k__TA_ACOS, sizeof(__pyx_k__TA_ACOS), 0, 0, 1, 1},
  {&__pyx_n_s__TA_AD, __pyx_k__TA_AD, sizeof(__pyx_k__TA_AD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ADD, __pyx_k__TA_ADD, sizeof(__pyx_k__TA_ADD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ADOSC, __pyx_k__TA_ADOSC, sizeof(__pyx_k__TA_ADOSC), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ADX, __pyx_k__TA_ADX, sizeof(__pyx_k__TA_ADX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ADXR, __pyx_k__TA_ADXR, sizeof(__pyx_k__TA_ADXR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_APO, __pyx_k__TA_APO, sizeof(__pyx_k__TA_APO), 0, 0, 1, 1},
  {&__pyx_n_s__TA_AROON, __pyx_k__TA_AROON, sizeof(__pyx_k__TA_AROON), 0, 0, 1, 1},
  {&__pyx_n_s__TA_AROONOSC, __pyx_k__TA_AROONOSC, sizeof(__pyx_k__TA_AROONOSC), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ASIN, __pyx_k__TA_ASIN, sizeof(__pyx_k__TA_ASIN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ATAN, __pyx_k__TA_ATAN, sizeof(__pyx_k__TA_ATAN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ATR, __pyx_k__TA_ATR, sizeof(__pyx_k__TA_ATR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_AVGPRICE, __pyx_k__TA_AVGPRICE, sizeof(__pyx_k__TA_AVGPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_BBANDS, __pyx_k__TA_BBANDS, sizeof(__pyx_k__TA_BBANDS), 0, 0, 1, 1},
  {&__pyx_n_s__TA_BETA, __pyx_k__TA_BETA, sizeof(__pyx_k__TA_BETA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_BOP, __pyx_k__TA_BOP, sizeof(__pyx_k__TA_BOP), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CCI, __pyx_k__TA_CCI, sizeof(__pyx_k__TA_CCI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDL2CROWS, __pyx_k__TA_CDL2CROWS, sizeof(__pyx_k__TA_CDL2CROWS), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDL3BLACKCROWS, __pyx_k__TA_CDL3BLACKCROWS, sizeof(__pyx_k__TA_CDL3BLACKCROWS), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDL3INSIDE, __pyx_k__TA_CDL3INSIDE, sizeof(__pyx_k__TA_CDL3INSIDE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDL3LINESTRIKE, __pyx_k__TA_CDL3LINESTRIKE, sizeof(__pyx_k__TA_CDL3LINESTRIKE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDL3OUTSIDE, __pyx_k__TA_CDL3OUTSIDE, sizeof(__pyx_k__TA_CDL3OUTSIDE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDL3STARSINSOUTH, __pyx_k__TA_CDL3STARSINSOUTH, sizeof(__pyx_k__TA_CDL3STARSINSOUTH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLABANDONEDBABY, __pyx_k__TA_CDLABANDONEDBABY, sizeof(__pyx_k__TA_CDLABANDONEDBABY), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLADVANCEBLOCK, __pyx_k__TA_CDLADVANCEBLOCK, sizeof(__pyx_k__TA_CDLADVANCEBLOCK), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLBELTHOLD, __pyx_k__TA_CDLBELTHOLD, sizeof(__pyx_k__TA_CDLBELTHOLD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLBREAKAWAY, __pyx_k__TA_CDLBREAKAWAY, sizeof(__pyx_k__TA_CDLBREAKAWAY), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLCOUNTERATTACK, __pyx_k__TA_CDLCOUNTERATTACK, sizeof(__pyx_k__TA_CDLCOUNTERATTACK), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLDOJI, __pyx_k__TA_CDLDOJI, sizeof(__pyx_k__TA_CDLDOJI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLDOJISTAR, __pyx_k__TA_CDLDOJISTAR, sizeof(__pyx_k__TA_CDLDOJISTAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLDRAGONFLYDOJI, __pyx_k__TA_CDLDRAGONFLYDOJI, sizeof(__pyx_k__TA_CDLDRAGONFLYDOJI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLENGULFING, __pyx_k__TA_CDLENGULFING, sizeof(__pyx_k__TA_CDLENGULFING), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLEVENINGSTAR, __pyx_k__TA_CDLEVENINGSTAR, sizeof(__pyx_k__TA_CDLEVENINGSTAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHAMMER, __pyx_k__TA_CDLHAMMER, sizeof(__pyx_k__TA_CDLHAMMER), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHANGINGMAN, __pyx_k__TA_CDLHANGINGMAN, sizeof(__pyx_k__TA_CDLHANGINGMAN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHARAMI, __pyx_k__TA_CDLHARAMI, sizeof(__pyx_k__TA_CDLHARAMI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHARAMICROSS, __pyx_k__TA_CDLHARAMICROSS, sizeof(__pyx_k__TA_CDLHARAMICROSS), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHIGHWAVE, __pyx_k__TA_CDLHIGHWAVE, sizeof(__pyx_k__TA_CDLHIGHWAVE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHIKKAKE, __pyx_k__TA_CDLHIKKAKE, sizeof(__pyx_k__TA_CDLHIKKAKE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHIKKAKEMOD, __pyx_k__TA_CDLHIKKAKEMOD, sizeof(__pyx_k__TA_CDLHIKKAKEMOD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLHOMINGPIGEON, __pyx_k__TA_CDLHOMINGPIGEON, sizeof(__pyx_k__TA_CDLHOMINGPIGEON), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLINNECK, __pyx_k__TA_CDLINNECK, sizeof(__pyx_k__TA_CDLINNECK), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLKICKING, __pyx_k__TA_CDLKICKING, sizeof(__pyx_k__TA_CDLKICKING), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLLADDERBOTTOM, __pyx_k__TA_CDLLADDERBOTTOM, sizeof(__pyx_k__TA_CDLLADDERBOTTOM), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLLONGLINE, __pyx_k__TA_CDLLONGLINE, sizeof(__pyx_k__TA_CDLLONGLINE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLMARUBOZU, __pyx_k__TA_CDLMARUBOZU, sizeof(__pyx_k__TA_CDLMARUBOZU), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLMATCHINGLOW, __pyx_k__TA_CDLMATCHINGLOW, sizeof(__pyx_k__TA_CDLMATCHINGLOW), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLMATHOLD, __pyx_k__TA_CDLMATHOLD, sizeof(__pyx_k__TA_CDLMATHOLD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLMORNINGSTAR, __pyx_k__TA_CDLMORNINGSTAR, sizeof(__pyx_k__TA_CDLMORNINGSTAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLONNECK, __pyx_k__TA_CDLONNECK, sizeof(__pyx_k__TA_CDLONNECK), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLPIERCING, __pyx_k__TA_CDLPIERCING, sizeof(__pyx_k__TA_CDLPIERCING), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLRICKSHAWMAN, __pyx_k__TA_CDLRICKSHAWMAN, sizeof(__pyx_k__TA_CDLRICKSHAWMAN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLSHOOTINGSTAR, __pyx_k__TA_CDLSHOOTINGSTAR, sizeof(__pyx_k__TA_CDLSHOOTINGSTAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLSHORTLINE, __pyx_k__TA_CDLSHORTLINE, sizeof(__pyx_k__TA_CDLSHORTLINE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLSPINNINGTOP, __pyx_k__TA_CDLSPINNINGTOP, sizeof(__pyx_k__TA_CDLSPINNINGTOP), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLSTICKSANDWICH, __pyx_k__TA_CDLSTICKSANDWICH, sizeof(__pyx_k__TA_CDLSTICKSANDWICH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLTAKURI, __pyx_k__TA_CDLTAKURI, sizeof(__pyx_k__TA_CDLTAKURI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLTASUKIGAP, __pyx_k__TA_CDLTASUKIGAP, sizeof(__pyx_k__TA_CDLTASUKIGAP), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLTHRUSTING, __pyx_k__TA_CDLTHRUSTING, sizeof(__pyx_k__TA_CDLTHRUSTING), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLTRISTAR, __pyx_k__TA_CDLTRISTAR, sizeof(__pyx_k__TA_CDLTRISTAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CDLUNIQUE3RIVER, __pyx_k__TA_CDLUNIQUE3RIVER, sizeof(__pyx_k__TA_CDLUNIQUE3RIVER), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CEIL, __pyx_k__TA_CEIL, sizeof(__pyx_k__TA_CEIL), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CMO, __pyx_k__TA_CMO, sizeof(__pyx_k__TA_CMO), 0, 0, 1, 1},
  {&__pyx_n_s__TA_CORREL, __pyx_k__TA_CORREL, sizeof(__pyx_k__TA_CORREL), 0, 0, 1, 1},
  {&__pyx_n_s__TA_COS, __pyx_k__TA_COS, sizeof(__pyx_k__TA_COS), 0, 0, 1, 1},
  {&__pyx_n_s__TA_COSH, __pyx_k__TA_COSH, sizeof(__pyx_k__TA_COSH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_DEMA, __pyx_k__TA_DEMA, sizeof(__pyx_k__TA_DEMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_DIV, __pyx_k__TA_DIV, sizeof(__pyx_k__TA_DIV), 0, 0, 1, 1},
  {&__pyx_n_s__TA_DX, __pyx_k__TA_DX, sizeof(__pyx_k__TA_DX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_EMA, __pyx_k__TA_EMA, sizeof(__pyx_k__TA_EMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_EXP, __pyx_k__TA_EXP, sizeof(__pyx_k__TA_EXP), 0, 0, 1, 1},
  {&__pyx_n_s__TA_FLOOR, __pyx_k__TA_FLOOR, sizeof(__pyx_k__TA_FLOOR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_HT_DCPERIOD, __pyx_k__TA_HT_DCPERIOD, sizeof(__pyx_k__TA_HT_DCPERIOD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_HT_DCPHASE, __pyx_k__TA_HT_DCPHASE, sizeof(__pyx_k__TA_HT_DCPHASE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_HT_PHASOR, __pyx_k__TA_HT_PHASOR, sizeof(__pyx_k__TA_HT_PHASOR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_HT_SINE, __pyx_k__TA_HT_SINE, sizeof(__pyx_k__TA_HT_SINE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_HT_TRENDLINE, __pyx_k__TA_HT_TRENDLINE, sizeof(__pyx_k__TA_HT_TRENDLINE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_HT_TRENDMODE, __pyx_k__TA_HT_TRENDMODE, sizeof(__pyx_k__TA_HT_TRENDMODE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_KAMA, __pyx_k__TA_KAMA, sizeof(__pyx_k__TA_KAMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_LINEARREG, __pyx_k__TA_LINEARREG, sizeof(__pyx_k__TA_LINEARREG), 0, 0, 1, 1},
  {&__pyx_n_s__TA_LINEARREG_ANGLE, __pyx_k__TA_LINEARREG_ANGLE, sizeof(__pyx_k__TA_LINEARREG_ANGLE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_LINEARREG_SLOPE, __pyx_k__TA_LINEARREG_SLOPE, sizeof(__pyx_k__TA_LINEARREG_SLOPE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_LN, __pyx_k__TA_LN, sizeof(__pyx_k__TA_LN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_LOG10, __pyx_k__TA_LOG10, sizeof(__pyx_k__TA_LOG10), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MA, __pyx_k__TA_MA, sizeof(__pyx_k__TA_MA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MACD, __pyx_k__TA_MACD, sizeof(__pyx_k__TA_MACD), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MACDEXT, __pyx_k__TA_MACDEXT, sizeof(__pyx_k__TA_MACDEXT), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MACDFIX, __pyx_k__TA_MACDFIX, sizeof(__pyx_k__TA_MACDFIX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MAMA, __pyx_k__TA_MAMA, sizeof(__pyx_k__TA_MAMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MAVP, __pyx_k__TA_MAVP, sizeof(__pyx_k__TA_MAVP), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MAX, __pyx_k__TA_MAX, sizeof(__pyx_k__TA_MAX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MAXINDEX, __pyx_k__TA_MAXINDEX, sizeof(__pyx_k__TA_MAXINDEX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MEDPRICE, __pyx_k__TA_MEDPRICE, sizeof(__pyx_k__TA_MEDPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MFI, __pyx_k__TA_MFI, sizeof(__pyx_k__TA_MFI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MIDPOINT, __pyx_k__TA_MIDPOINT, sizeof(__pyx_k__TA_MIDPOINT), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MIDPRICE, __pyx_k__TA_MIDPRICE, sizeof(__pyx_k__TA_MIDPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MIN, __pyx_k__TA_MIN, sizeof(__pyx_k__TA_MIN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MININDEX, __pyx_k__TA_MININDEX, sizeof(__pyx_k__TA_MININDEX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MINMAX, __pyx_k__TA_MINMAX, sizeof(__pyx_k__TA_MINMAX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MINMAXINDEX, __pyx_k__TA_MINMAXINDEX, sizeof(__pyx_k__TA_MINMAXINDEX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MINUS_DI, __pyx_k__TA_MINUS_DI, sizeof(__pyx_k__TA_MINUS_DI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MINUS_DM, __pyx_k__TA_MINUS_DM, sizeof(__pyx_k__TA_MINUS_DM), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MOM, __pyx_k__TA_MOM, sizeof(__pyx_k__TA_MOM), 0, 0, 1, 1},
  {&__pyx_n_s__TA_MULT, __pyx_k__TA_MULT, sizeof(__pyx_k__TA_MULT), 0, 0, 1, 1},
  {&__pyx_n_s__TA_NATR, __pyx_k__TA_NATR, sizeof(__pyx_k__TA_NATR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_OBV, __pyx_k__TA_OBV, sizeof(__pyx_k__TA_OBV), 0, 0, 1, 1},
  {&__pyx_n_s__TA_PLUS_DI, __pyx_k__TA_PLUS_DI, sizeof(__pyx_k__TA_PLUS_DI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_PLUS_DM, __pyx_k__TA_PLUS_DM, sizeof(__pyx_k__TA_PLUS_DM), 0, 0, 1, 1},
  {&__pyx_n_s__TA_PPO, __pyx_k__TA_PPO, sizeof(__pyx_k__TA_PPO), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ROC, __pyx_k__TA_ROC, sizeof(__pyx_k__TA_ROC), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ROCP, __pyx_k__TA_ROCP, sizeof(__pyx_k__TA_ROCP), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ROCR, __pyx_k__TA_ROCR, sizeof(__pyx_k__TA_ROCR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ROCR100, __pyx_k__TA_ROCR100, sizeof(__pyx_k__TA_ROCR100), 0, 0, 1, 1},
  {&__pyx_n_s__TA_RSI, __pyx_k__TA_RSI, sizeof(__pyx_k__TA_RSI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SAR, __pyx_k__TA_SAR, sizeof(__pyx_k__TA_SAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SAREXT, __pyx_k__TA_SAREXT, sizeof(__pyx_k__TA_SAREXT), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SIN, __pyx_k__TA_SIN, sizeof(__pyx_k__TA_SIN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SINH, __pyx_k__TA_SINH, sizeof(__pyx_k__TA_SINH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SMA, __pyx_k__TA_SMA, sizeof(__pyx_k__TA_SMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SQRT, __pyx_k__TA_SQRT, sizeof(__pyx_k__TA_SQRT), 0, 0, 1, 1},
  {&__pyx_n_s__TA_STDDEV, __pyx_k__TA_STDDEV, sizeof(__pyx_k__TA_STDDEV), 0, 0, 1, 1},
  {&__pyx_n_s__TA_STOCH, __pyx_k__TA_STOCH, sizeof(__pyx_k__TA_STOCH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_STOCHF, __pyx_k__TA_STOCHF, sizeof(__pyx_k__TA_STOCHF), 0, 0, 1, 1},
  {&__pyx_n_s__TA_STOCHRSI, __pyx_k__TA_STOCHRSI, sizeof(__pyx_k__TA_STOCHRSI), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SUB, __pyx_k__TA_SUB, sizeof(__pyx_k__TA_SUB), 0, 0, 1, 1},
  {&__pyx_n_s__TA_SUM, __pyx_k__TA_SUM, sizeof(__pyx_k__TA_SUM), 0, 0, 1, 1},
  {&__pyx_n_s__TA_T3, __pyx_k__TA_T3, sizeof(__pyx_k__TA_T3), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TAN, __pyx_k__TA_TAN, sizeof(__pyx_k__TA_TAN), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TANH, __pyx_k__TA_TANH, sizeof(__pyx_k__TA_TANH), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TEMA, __pyx_k__TA_TEMA, sizeof(__pyx_k__TA_TEMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TRANGE, __pyx_k__TA_TRANGE, sizeof(__pyx_k__TA_TRANGE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TRIMA, __pyx_k__TA_TRIMA, sizeof(__pyx_k__TA_TRIMA), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TRIX, __pyx_k__TA_TRIX, sizeof(__pyx_k__TA_TRIX), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TSF, __pyx_k__TA_TSF, sizeof(__pyx_k__TA_TSF), 0, 0, 1, 1},
  {&__pyx_n_s__TA_TYPPRICE, __pyx_k__TA_TYPPRICE, sizeof(__pyx_k__TA_TYPPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_ULTOSC, __pyx_k__TA_ULTOSC, sizeof(__pyx_k__TA_ULTOSC), 0, 0, 1, 1},
  {&__pyx_n_s__TA_VAR, __pyx_k__TA_VAR, sizeof(__pyx_k__TA_VAR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_WCLPRICE, __pyx_k__TA_WCLPRICE, sizeof(__pyx_k__TA_WCLPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__TA_WILLR, __pyx_k__TA_WILLR, sizeof(__pyx_k__TA_WILLR), 0, 0, 1, 1},
  {&__pyx_n_s__TA_WMA, __pyx_k__TA_WMA, sizeof(__pyx_k__TA_WMA), 0, 0, 1, 1},
  {&__pyx_n_s__TEMA, __pyx_k__TEMA, sizeof(__pyx_k__TEMA), 0, 0, 1, 1},
  {&__pyx_n_s__TRANGE, __pyx_k__TRANGE, sizeof(__pyx_k__TRANGE), 0, 0, 1, 1},
  {&__pyx_n_s__TRIMA, __pyx_k__TRIMA, sizeof(__pyx_k__TRIMA), 0, 0, 1, 1},
  {&__pyx_n_s__TRIX, __pyx_k__TRIX, sizeof(__pyx_k__TRIX), 0, 0, 1, 1},
  {&__pyx_n_s__TSF, __pyx_k__TSF, sizeof(__pyx_k__TSF), 0, 0, 1, 1},
  {&__pyx_n_s__TYPPRICE, __pyx_k__TYPPRICE, sizeof(__pyx_k__TYPPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__ULTOSC, __pyx_k__ULTOSC, sizeof(__pyx_k__ULTOSC), 0, 0, 1, 1},
  {&__pyx_n_s__VAR, __pyx_k__VAR, sizeof(__pyx_k__VAR), 0, 0, 1, 1},
  {&__pyx_n_s__ValueError, __pyx_k__ValueError, sizeof(__pyx_k__ValueError), 0, 0, 1, 1},
  {&__pyx_n_s__WCLPRICE, __pyx_k__WCLPRICE, sizeof(__pyx_k__WCLPRICE), 0, 0, 1, 1},
  {&__pyx_n_s__WILLR, __pyx_k__WILLR, sizeof(__pyx_k__WILLR), 0, 0, 1, 1},
  {&__pyx_n_s__WMA, __pyx_k__WMA, sizeof(__pyx_k__WMA), 0, 0, 1, 1},
  {&__pyx_n_s____all__, __pyx_k____all__, sizeof(__pyx_k____all__), 0, 0, 1, 1},
  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
  {&__pyx_n_s__acceleration, __pyx_k__acceleration, sizeof(__pyx_k__acceleration), 0, 0, 1, 1},
  {&__pyx_n_s__accelerationlong, __pyx_k__accelerationlong, sizeof(__pyx_k__accelerationlong), 0, 0, 1, 1},
  {&__pyx_n_s__accelerationmaxlong, __pyx_k__accelerationmaxlong, sizeof(__pyx_k__accelerationmaxlong), 0, 0, 1, 1},
  {&__pyx_n_s__accelerationshort, __pyx_k__accelerationshort, sizeof(__pyx_k__accelerationshort), 0, 0, 1, 1},
  {&__pyx_n_s__begidx, __pyx_k__begidx, sizeof(__pyx_k__begidx), 0, 0, 1, 1},
  {&__pyx_n_s__close, __pyx_k__close, sizeof(__pyx_k__close), 0, 0, 1, 1},
  {&__pyx_n_s__close_data, __pyx_k__close_data, sizeof(__pyx_k__close_data), 0, 0, 1, 1},
  {&__pyx_n_s__endidx, __pyx_k__endidx, sizeof(__pyx_k__endidx), 0, 0, 1, 1},
  {&__pyx_n_s__fastd_matype, __pyx_k__fastd_matype, sizeof(__pyx_k__fastd_matype), 0, 0, 1, 1},
  {&__pyx_n_s__fastd_period, __pyx_k__fastd_period, sizeof(__pyx_k__fastd_period), 0, 0, 1, 1},
  {&__pyx_n_s__fastk_period, __pyx_k__fastk_period, sizeof(__pyx_k__fastk_period), 0, 0, 1, 1},
  {&__pyx_n_s__fastlimit, __pyx_k__fastlimit, sizeof(__pyx_k__fastlimit), 0, 0, 1, 1},
  {&__pyx_n_s__fastmatype, __pyx_k__fastmatype, sizeof(__pyx_k__fastmatype), 0, 0, 1, 1},
  {&__pyx_n_s__fastperiod, __pyx_k__fastperiod, sizeof(__pyx_k__fastperiod), 0, 0, 1, 1},
  {&__pyx_n_s__high, __pyx_k__high, sizeof(__pyx_k__high), 0, 0, 1, 1},
  {&__pyx_n_s__high_data, __pyx_k__high_data, sizeof(__pyx_k__high_data), 0, 0, 1, 1},
  {&__pyx_n_s__i, __pyx_k__i, sizeof(__pyx_k__i), 0, 0, 1, 1},
  {&__pyx_n_s__length, __pyx_k__length, sizeof(__pyx_k__length), 0, 0, 1, 1},
  {&__pyx_n_s__lookback, __pyx_k__lookback, sizeof(__pyx_k__lookback), 0, 0, 1, 1},
  {&__pyx_n_s__low, __pyx_k__low, sizeof(__pyx_k__low), 0, 0, 1, 1},
  {&__pyx_n_s__low_data, __pyx_k__low_data, sizeof(__pyx_k__low_data), 0, 0, 1, 1},
  {&__pyx_n_s__matype, __pyx_k__matype, sizeof(__pyx_k__matype), 0, 0, 1, 1},
  {&__pyx_n_s__maximum, __pyx_k__maximum, sizeof(__pyx_k__maximum), 0, 0, 1, 1},
  {&__pyx_n_s__maxperiod, __pyx_k__maxperiod, sizeof(__pyx_k__maxperiod), 0, 0, 1, 1},
  {&__pyx_n_s__minperiod, __pyx_k__minperiod, sizeof(__pyx_k__minperiod), 0, 0, 1, 1},
  {&__pyx_n_s__nan, __pyx_k__nan, sizeof(__pyx_k__nan), 0, 0, 1, 1},
  {&__pyx_n_s__nbdev, __pyx_k__nbdev, sizeof(__pyx_k__nbdev), 0, 0, 1, 1},
  {&__pyx_n_s__nbdevdn, __pyx_k__nbdevdn, sizeof(__pyx_k__nbdevdn), 0, 0, 1, 1},
  {&__pyx_n_s__nbdevup, __pyx_k__nbdevup, sizeof(__pyx_k__nbdevup), 0, 0, 1, 1},
  {&__pyx_n_s__numpy, __pyx_k__numpy, sizeof(__pyx_k__numpy), 0, 0, 1, 1},
  {&__pyx_n_s__offsetonreverse, __pyx_k__offsetonreverse, sizeof(__pyx_k__offsetonreverse), 0, 0, 1, 1},
  {&__pyx_n_s__open, __pyx_k__open, sizeof(__pyx_k__open), 0, 0, 1, 1},
  {&__pyx_n_s__open_data, __pyx_k__open_data, sizeof(__pyx_k__open_data), 0, 0, 1, 1},
  {&__pyx_n_s__outaroondown, __pyx_k__outaroondown, sizeof(__pyx_k__outaroondown), 0, 0, 1, 1},
  {&__pyx_n_s__outaroondown_data, __pyx_k__outaroondown_data, sizeof(__pyx_k__outaroondown_data), 0, 0, 1, 1},
  {&__pyx_n_s__outaroonup, __pyx_k__outaroonup, sizeof(__pyx_k__outaroonup), 0, 0, 1, 1},
  {&__pyx_n_s__outaroonup_data, __pyx_k__outaroonup_data, sizeof(__pyx_k__outaroonup_data), 0, 0, 1, 1},
  {&__pyx_n_s__outbegidx, __pyx_k__outbegidx, sizeof(__pyx_k__outbegidx), 0, 0, 1, 1},
  {&__pyx_n_s__outfama, __pyx_k__outfama, sizeof(__pyx_k__outfama), 0, 0, 1, 1},
  {&__pyx_n_s__outfama_data, __pyx_k__outfama_data, sizeof(__pyx_k__outfama_data), 0, 0, 1, 1},
  {&__pyx_n_s__outfastd, __pyx_k__outfastd, sizeof(__pyx_k__outfastd), 0, 0, 1, 1},
  {&__pyx_n_s__outfastd_data, __pyx_k__outfastd_data, sizeof(__pyx_k__outfastd_data), 0, 0, 1, 1},
  {&__pyx_n_s__outfastk, __pyx_k__outfastk, sizeof(__pyx_k__outfastk), 0, 0, 1, 1},
  {&__pyx_n_s__outfastk_data, __pyx_k__outfastk_data, sizeof(__pyx_k__outfastk_data), 0, 0, 1, 1},
  {&__pyx_n_s__outinphase, __pyx_k__outinphase, sizeof(__pyx_k__outinphase), 0, 0, 1, 1},
  {&__pyx_n_s__outinphase_data, __pyx_k__outinphase_data, sizeof(__pyx_k__outinphase_data), 0, 0, 1, 1},
  {&__pyx_n_s__outinteger, __pyx_k__outinteger, sizeof(__pyx_k__outinteger), 0, 0, 1, 1},
  {&__pyx_n_s__outinteger_data, __pyx_k__outinteger_data, sizeof(__pyx_k__outinteger_data), 0, 0, 1, 1},
  {&__pyx_n_s__outleadsine, __pyx_k__outleadsine, sizeof(__pyx_k__outleadsine), 0, 0, 1, 1},
  {&__pyx_n_s__outleadsine_data, __pyx_k__outleadsine_data, sizeof(__pyx_k__outleadsine_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmacd, __pyx_k__outmacd, sizeof(__pyx_k__outmacd), 0, 0, 1, 1},
  {&__pyx_n_s__outmacd_data, __pyx_k__outmacd_data, sizeof(__pyx_k__outmacd_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmacdhist, __pyx_k__outmacdhist, sizeof(__pyx_k__outmacdhist), 0, 0, 1, 1},
  {&__pyx_n_s__outmacdhist_data, __pyx_k__outmacdhist_data, sizeof(__pyx_k__outmacdhist_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmacdsignal, __pyx_k__outmacdsignal, sizeof(__pyx_k__outmacdsignal), 0, 0, 1, 1},
  {&__pyx_n_s__outmacdsignal_data, __pyx_k__outmacdsignal_data, sizeof(__pyx_k__outmacdsignal_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmama, __pyx_k__outmama, sizeof(__pyx_k__outmama), 0, 0, 1, 1},
  {&__pyx_n_s__outmama_data, __pyx_k__outmama_data, sizeof(__pyx_k__outmama_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmax, __pyx_k__outmax, sizeof(__pyx_k__outmax), 0, 0, 1, 1},
  {&__pyx_n_s__outmax_data, __pyx_k__outmax_data, sizeof(__pyx_k__outmax_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmaxidx, __pyx_k__outmaxidx, sizeof(__pyx_k__outmaxidx), 0, 0, 1, 1},
  {&__pyx_n_s__outmaxidx_data, __pyx_k__outmaxidx_data, sizeof(__pyx_k__outmaxidx_data), 0, 0, 1, 1},
  {&__pyx_n_s__outmin, __pyx_k__outmin, sizeof(__pyx_k__outmin), 0, 0, 1, 1},
  {&__pyx_n_s__outmin_data, __pyx_k__outmin_data, sizeof(__pyx_k__outmin_data), 0, 0, 1, 1},
  {&__pyx_n_s__outminidx, __pyx_k__outminidx, sizeof(__pyx_k__outminidx), 0, 0, 1, 1},
  {&__pyx_n_s__outminidx_data, __pyx_k__outminidx_data, sizeof(__pyx_k__outminidx_data), 0, 0, 1, 1},
  {&__pyx_n_s__outnbelement, __pyx_k__outnbelement, sizeof(__pyx_k__outnbelement), 0, 0, 1, 1},
  {&__pyx_n_s__outquadrature, __pyx_k__outquadrature, sizeof(__pyx_k__outquadrature), 0, 0, 1, 1},
  {&__pyx_n_s__outquadrature_data, __pyx_k__outquadrature_data, sizeof(__pyx_k__outquadrature_data), 0, 0, 1, 1},
  {&__pyx_n_s__outreal, __pyx_k__outreal, sizeof(__pyx_k__outreal), 0, 0, 1, 1},
  {&__pyx_n_s__outreal_data, __pyx_k__outreal_data, sizeof(__pyx_k__outreal_data), 0, 0, 1, 1},
  {&__pyx_n_s__outreallowerband, __pyx_k__outreallowerband, sizeof(__pyx_k__outreallowerband), 0, 0, 1, 1},
  {&__pyx_n_s__outrealmiddleband, __pyx_k__outrealmiddleband, sizeof(__pyx_k__outrealmiddleband), 0, 0, 1, 1},
  {&__pyx_n_s__outrealupperband, __pyx_k__outrealupperband, sizeof(__pyx_k__outrealupperband), 0, 0, 1, 1},
  {&__pyx_n_s__outsine, __pyx_k__outsine, sizeof(__pyx_k__outsine), 0, 0, 1, 1},
  {&__pyx_n_s__outsine_data, __pyx_k__outsine_data, sizeof(__pyx_k__outsine_data), 0, 0, 1, 1},
  {&__pyx_n_s__outslowd, __pyx_k__outslowd, sizeof(__pyx_k__outslowd), 0, 0, 1, 1},
  {&__pyx_n_s__outslowd_data, __pyx_k__outslowd_data, sizeof(__pyx_k__outslowd_data), 0, 0, 1, 1},
  {&__pyx_n_s__outslowk, __pyx_k__outslowk, sizeof(__pyx_k__outslowk), 0, 0, 1, 1},
  {&__pyx_n_s__outslowk_data, __pyx_k__outslowk_data, sizeof(__pyx_k__outslowk_data), 0, 0, 1, 1},
  {&__pyx_n_s__penetration, __pyx_k__penetration, sizeof(__pyx_k__penetration), 0, 0, 1, 1},
  {&__pyx_n_s__periods, __pyx_k__periods, sizeof(__pyx_k__periods), 0, 0, 1, 1},
  {&__pyx_n_s__periods_data, __pyx_k__periods_data, sizeof(__pyx_k__periods_data), 0, 0, 1, 1},
  {&__pyx_n_s__range, __pyx_k__range, sizeof(__pyx_k__range), 0, 0, 1, 1},
  {&__pyx_n_s__real, __pyx_k__real, sizeof(__pyx_k__real), 0, 0, 1, 1},
  {&__pyx_n_s__real0, __pyx_k__real0, sizeof(__pyx_k__real0), 0, 0, 1, 1},
  {&__pyx_n_s__real0_data, __pyx_k__real0_data, sizeof(__pyx_k__real0_data), 0, 0, 1, 1},
  {&__pyx_n_s__real1, __pyx_k__real1, sizeof(__pyx_k__real1), 0, 0, 1, 1},
  {&__pyx_n_s__real1_data, __pyx_k__real1_data, sizeof(__pyx_k__real1_data), 0, 0, 1, 1},
  {&__pyx_n_s__real_data, __pyx_k__real_data, sizeof(__pyx_k__real_data), 0, 0, 1, 1},
  {&__pyx_n_s__retCode, __pyx_k__retCode, sizeof(__pyx_k__retCode), 0, 0, 1, 1},
  {&__pyx_n_s__signalmatype, __pyx_k__signalmatype, sizeof(__pyx_k__signalmatype), 0, 0, 1, 1},
  {&__pyx_n_s__signalperiod, __pyx_k__signalperiod, sizeof(__pyx_k__signalperiod), 0, 0, 1, 1},
  {&__pyx_n_s__slowd_matype, __pyx_k__slowd_matype, sizeof(__pyx_k__slowd_matype), 0, 0, 1, 1},
  {&__pyx_n_s__slowd_period, __pyx_k__slowd_period, sizeof(__pyx_k__slowd_period), 0, 0, 1, 1},
  {&__pyx_n_s__slowk_matype, __pyx_k__slowk_matype, sizeof(__pyx_k__slowk_matype), 0, 0, 1, 1},
  {&__pyx_n_s__slowk_period, __pyx_k__slowk_period, sizeof(__pyx_k__slowk_period), 0, 0, 1, 1},
  {&__pyx_n_s__slowlimit, __pyx_k__slowlimit, sizeof(__pyx_k__slowlimit), 0, 0, 1, 1},
  {&__pyx_n_s__slowmatype, __pyx_k__slowmatype, sizeof(__pyx_k__slowmatype), 0, 0, 1, 1},
  {&__pyx_n_s__slowperiod, __pyx_k__slowperiod, sizeof(__pyx_k__slowperiod), 0, 0, 1, 1},
  {&__pyx_n_s__startvalue, __pyx_k__startvalue, sizeof(__pyx_k__startvalue), 0, 0, 1, 1},
  {&__pyx_n_s__timeperiod, __pyx_k__timeperiod, sizeof(__pyx_k__timeperiod), 0, 0, 1, 1},
  {&__pyx_n_s__timeperiod1, __pyx_k__timeperiod1, sizeof(__pyx_k__timeperiod1), 0, 0, 1, 1},
  {&__pyx_n_s__timeperiod2, __pyx_k__timeperiod2, sizeof(__pyx_k__timeperiod2), 0, 0, 1, 1},
  {&__pyx_n_s__timeperiod3, __pyx_k__timeperiod3, sizeof(__pyx_k__timeperiod3), 0, 0, 1, 1},
  {&__pyx_n_s__vfactor, __pyx_k__vfactor, sizeof(__pyx_k__vfactor), 0, 0, 1, 1},
  {&__pyx_n_s__volume, __pyx_k__volume, sizeof(__pyx_k__volume), 0, 0, 1, 1},
  {&__pyx_n_s__volume_data, __pyx_k__volume_data, sizeof(__pyx_k__volume_data), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_n_s__Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_n_s__ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_range = __Pyx_GetName(__pyx_b, __pyx_n_s__range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "talib/func.pyx":377
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ACOS_Lookback( )
 */
  __pyx_k_tuple_4 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 377; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_4);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_4));

  /* "talib/func.pyx":438
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AD_Lookback( )
 */
  __pyx_k_tuple_13 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_13);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_13));

  /* "talib/func.pyx":488
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADD_Lookback( )
 */
  __pyx_k_tuple_18 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_18)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_18);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_18));

  /* "talib/func.pyx":552
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADOSC_Lookback( fastperiod , slowperiod )
 */
  __pyx_k_tuple_19 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_19)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 552; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_19);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_19));

  /* "talib/func.pyx":609
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADX_Lookback( timeperiod )
 */
  __pyx_k_tuple_20 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_20)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 609; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_20);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_20));

  /* "talib/func.pyx":666
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ADXR_Lookback( timeperiod )
 */
  __pyx_k_tuple_21 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 666; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_21);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_21));

  /* "talib/func.pyx":713
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_APO_Lookback( fastperiod , slowperiod , matype )
 */
  __pyx_k_tuple_22 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_22)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_22);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_22));

  /* "talib/func.pyx":767
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROON_Lookback( timeperiod )
 */
  __pyx_k_tuple_23 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_23)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_23);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_23));

  /* "talib/func.pyx":822
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AROONOSC_Lookback( timeperiod )
 */
  __pyx_k_tuple_24 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_24)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_24);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_24));

  /* "talib/func.pyx":865
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ASIN_Lookback( )
 */
  __pyx_k_tuple_25 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_25)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_25);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_25));

  /* "talib/func.pyx":908
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATAN_Lookback( )
 */
  __pyx_k_tuple_26 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_26)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 908; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_26);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_26));

  /* "talib/func.pyx":965
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ATR_Lookback( timeperiod )
 */
  __pyx_k_tuple_27 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_27)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 965; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_27);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_27));

  /* "talib/func.pyx":1026
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_AVGPRICE_Lookback( )
 */
  __pyx_k_tuple_30 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_30)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1026; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_30);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_30));

  /* "talib/func.pyx":1080
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BBANDS_Lookback( timeperiod , nbdevup , nbdevdn , matype )
 */
  __pyx_k_tuple_31 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_31)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_31);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_31));

  /* "talib/func.pyx":1140
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BETA_Lookback( timeperiod )
 */
  __pyx_k_tuple_32 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_32)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_32);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_32));

  /* "talib/func.pyx":1201
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_BOP_Lookback( )
 */
  __pyx_k_tuple_33 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_33)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_33);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_33));

  /* "talib/func.pyx":1258
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CCI_Lookback( timeperiod )
 */
  __pyx_k_tuple_34 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_34)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1258; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_34);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_34));

  /* "talib/func.pyx":1319
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL2CROWS_Lookback( )
 */
  __pyx_k_tuple_35 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_35)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_35);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_35));

  /* "talib/func.pyx":1380
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3BLACKCROWS_Lookback( )
 */
  __pyx_k_tuple_36 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_36)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_36);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_36));

  /* "talib/func.pyx":1441
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3INSIDE_Lookback( )
 */
  __pyx_k_tuple_37 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_37)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_37);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_37));

  /* "talib/func.pyx":1502
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3LINESTRIKE_Lookback( )
 */
  __pyx_k_tuple_38 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_38)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_38);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_38));

  /* "talib/func.pyx":1563
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3OUTSIDE_Lookback( )
 */
  __pyx_k_tuple_39 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_39)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_39);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_39));

  /* "talib/func.pyx":1624
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3STARSINSOUTH_Lookback( )
 */
  __pyx_k_tuple_40 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_40)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_40);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_40));

  /* "talib/func.pyx":1685
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDL3WHITESOLDIERS_Lookback( )
 */
  __pyx_k_tuple_41 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_41)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_41);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_41));

  /* "talib/func.pyx":1748
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLABANDONEDBABY_Lookback( penetration )
 */
  __pyx_k_tuple_43 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_43)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1748; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_43);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_43));

  /* "talib/func.pyx":1809
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLADVANCEBLOCK_Lookback( )
 */
  __pyx_k_tuple_44 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_44)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1809; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_44);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_44));

  /* "talib/func.pyx":1870
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBELTHOLD_Lookback( )
 */
  __pyx_k_tuple_45 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_45)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_45);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_45));

  /* "talib/func.pyx":1931
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLBREAKAWAY_Lookback( )
 */
  __pyx_k_tuple_46 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_46)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1931; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_46);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_46));

  /* "talib/func.pyx":1992
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCLOSINGMARUBOZU_Lookback( )
 */
  __pyx_k_tuple_47 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_47)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1992; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_47);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_47));

  /* "talib/func.pyx":2053
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCONCEALBABYSWALL_Lookback( )
 */
  __pyx_k_tuple_49 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_49)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2053; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_49);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_49));

  /* "talib/func.pyx":2114
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLCOUNTERATTACK_Lookback( )
 */
  __pyx_k_tuple_51 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_51)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_51);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_51));

  /* "talib/func.pyx":2177
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDARKCLOUDCOVER_Lookback( penetration )
 */
  __pyx_k_tuple_52 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_52)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2177; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_52);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_52));

  /* "talib/func.pyx":2238
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJI_Lookback( )
 */
  __pyx_k_tuple_54 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_54)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2238; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_54);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_54));

  /* "talib/func.pyx":2299
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDOJISTAR_Lookback( )
 */
  __pyx_k_tuple_55 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_55)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_55);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_55));

  /* "talib/func.pyx":2360
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLDRAGONFLYDOJI_Lookback( )
 */
  __pyx_k_tuple_56 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_56)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2360; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_56);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_56));

  /* "talib/func.pyx":2421
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLENGULFING_Lookback( )
 */
  __pyx_k_tuple_57 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_57)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2421; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_57);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_57));

  /* "talib/func.pyx":2484
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGDOJISTAR_Lookback( penetration )
 */
  __pyx_k_tuple_58 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_58)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_58);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_58));

  /* "talib/func.pyx":2547
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLEVENINGSTAR_Lookback( penetration )
 */
  __pyx_k_tuple_60 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_60)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_60);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_60));

  /* "talib/func.pyx":2608
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGAPSIDESIDEWHITE_Lookback( )
 */
  __pyx_k_tuple_61 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_61)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2608; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_61);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_61));

  /* "talib/func.pyx":2669
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLGRAVESTONEDOJI_Lookback( )
 */
  __pyx_k_tuple_63 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_63)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_63);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_63));

  /* "talib/func.pyx":2730
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHAMMER_Lookback( )
 */
  __pyx_k_tuple_65 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_65)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_65);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_65));

  /* "talib/func.pyx":2791
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHANGINGMAN_Lookback( )
 */
  __pyx_k_tuple_66 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_66)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2791; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_66);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_66));

  /* "talib/func.pyx":2852
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMI_Lookback( )
 */
  __pyx_k_tuple_67 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_67)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_67);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_67));

  /* "talib/func.pyx":2913
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHARAMICROSS_Lookback( )
 */
  __pyx_k_tuple_68 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_68)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_68);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_68));

  /* "talib/func.pyx":2974
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIGHWAVE_Lookback( )
 */
  __pyx_k_tuple_69 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_69)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2974; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_69);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_69));

  /* "talib/func.pyx":3035
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKE_Lookback( )
 */
  __pyx_k_tuple_70 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_70)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_70);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_70));

  /* "talib/func.pyx":3096
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHIKKAKEMOD_Lookback( )
 */
  __pyx_k_tuple_71 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_71)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3096; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_71);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_71));

  /* "talib/func.pyx":3157
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLHOMINGPIGEON_Lookback( )
 */
  __pyx_k_tuple_72 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_72)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_72);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_72));

  /* "talib/func.pyx":3218
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLIDENTICAL3CROWS_Lookback( )
 */
  __pyx_k_tuple_73 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_73)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_73);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_73));

  /* "talib/func.pyx":3279
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINNECK_Lookback( )
 */
  __pyx_k_tuple_75 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_75)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3279; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_75);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_75));

  /* "talib/func.pyx":3340
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLINVERTEDHAMMER_Lookback( )
 */
  __pyx_k_tuple_76 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_76)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_76);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_76));

  /* "talib/func.pyx":3401
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKING_Lookback( )
 */
  __pyx_k_tuple_78 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_78)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_78);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_78));

  /* "talib/func.pyx":3462
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLKICKINGBYLENGTH_Lookback( )
 */
  __pyx_k_tuple_79 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_79)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_79);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_79));

  /* "talib/func.pyx":3523
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLADDERBOTTOM_Lookback( )
 */
  __pyx_k_tuple_81 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_81)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_81);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_81));

  /* "talib/func.pyx":3584
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLEGGEDDOJI_Lookback( )
 */
  __pyx_k_tuple_82 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_82)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3584; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_82);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_82));

  /* "talib/func.pyx":3645
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLLONGLINE_Lookback( )
 */
  __pyx_k_tuple_84 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_84)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_84);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_84));

  /* "talib/func.pyx":3706
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMARUBOZU_Lookback( )
 */
  __pyx_k_tuple_85 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_85)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3706; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_85);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_85));

  /* "talib/func.pyx":3767
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATCHINGLOW_Lookback( )
 */
  __pyx_k_tuple_86 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_86)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3767; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_86);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_86));

  /* "talib/func.pyx":3830
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMATHOLD_Lookback( penetration )
 */
  __pyx_k_tuple_87 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_87)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3830; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_87);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_87));

  /* "talib/func.pyx":3893
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGDOJISTAR_Lookback( penetration )
 */
  __pyx_k_tuple_88 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_88)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3893; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_88);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_88));

  /* "talib/func.pyx":3956
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLMORNINGSTAR_Lookback( penetration )
 */
  __pyx_k_tuple_90 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_90)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_90);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_90));

  /* "talib/func.pyx":4017
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLONNECK_Lookback( )
 */
  __pyx_k_tuple_91 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_91)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4017; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_91);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_91));

  /* "talib/func.pyx":4078
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLPIERCING_Lookback( )
 */
  __pyx_k_tuple_92 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_92)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4078; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_92);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_92));

  /* "talib/func.pyx":4139
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRICKSHAWMAN_Lookback( )
 */
  __pyx_k_tuple_93 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_93)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_93);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_93));

  /* "talib/func.pyx":4200
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLRISEFALL3METHODS_Lookback( )
 */
  __pyx_k_tuple_94 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_94)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_94);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_94));

  /* "talib/func.pyx":4261
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSEPARATINGLINES_Lookback( )
 */
  __pyx_k_tuple_96 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_96)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4261; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_96);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_96));

  /* "talib/func.pyx":4322
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHOOTINGSTAR_Lookback( )
 */
  __pyx_k_tuple_98 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_98)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_98);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_98));

  /* "talib/func.pyx":4383
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSHORTLINE_Lookback( )
 */
  __pyx_k_tuple_99 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_99)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_99);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_99));

  /* "talib/func.pyx":4444
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSPINNINGTOP_Lookback( )
 */
  __pyx_k_tuple_100 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_100)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_100);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_100));

  /* "talib/func.pyx":4505
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTALLEDPATTERN_Lookback( )
 */
  __pyx_k_tuple_101 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_101)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_101);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_101));

  /* "talib/func.pyx":4566
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLSTICKSANDWICH_Lookback( )
 */
  __pyx_k_tuple_103 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_103)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_103);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_103));

  /* "talib/func.pyx":4627
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTAKURI_Lookback( )
 */
  __pyx_k_tuple_104 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_104)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4627; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_104);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_104));

  /* "talib/func.pyx":4688
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTASUKIGAP_Lookback( )
 */
  __pyx_k_tuple_105 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_105)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4688; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_105);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_105));

  /* "talib/func.pyx":4749
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTHRUSTING_Lookback( )
 */
  __pyx_k_tuple_106 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_106)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4749; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_106);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_106));

  /* "talib/func.pyx":4810
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLTRISTAR_Lookback( )
 */
  __pyx_k_tuple_107 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_107)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_107);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_107));

  /* "talib/func.pyx":4871
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUNIQUE3RIVER_Lookback( )
 */
  __pyx_k_tuple_108 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_108)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4871; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_108);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_108));

  /* "talib/func.pyx":4932
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLUPSIDEGAP2CROWS_Lookback( )
 */
  __pyx_k_tuple_109 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_109)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_109);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_109));

  /* "talib/func.pyx":4993
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CDLXSIDEGAP3METHODS_Lookback( )
 */
  __pyx_k_tuple_111 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_111)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4993; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_111);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_111));

  /* "talib/func.pyx":5036
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CEIL_Lookback( )
 */
  __pyx_k_tuple_113 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_113)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5036; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_113);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_113));

  /* "talib/func.pyx":5081
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CMO_Lookback( timeperiod )
 */
  __pyx_k_tuple_114 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_114)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_114);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_114));

  /* "talib/func.pyx":5133
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_CORREL_Lookback( timeperiod )
 */
  __pyx_k_tuple_115 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_115)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_115);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_115));

  /* "talib/func.pyx":5176
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COS_Lookback( )
 */
  __pyx_k_tuple_116 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_116)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5176; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_116);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_116));

  /* "talib/func.pyx":5219
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_COSH_Lookback( )
 */
  __pyx_k_tuple_117 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_117)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_117);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_117));

  /* "talib/func.pyx":5264
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DEMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_118 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_118)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_118);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_118));

  /* "talib/func.pyx":5314
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DIV_Lookback( )
 */
  __pyx_k_tuple_119 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_119)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_119);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_119));

  /* "talib/func.pyx":5371
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_DX_Lookback( timeperiod )
 */
  __pyx_k_tuple_120 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_120)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5371; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_120);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_120));

  /* "talib/func.pyx":5416
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_121 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_121)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_121);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_121));

  /* "talib/func.pyx":5459
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_EXP_Lookback( )
 */
  __pyx_k_tuple_122 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_122)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5459; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_122);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_122));

  /* "talib/func.pyx":5502
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_FLOOR_Lookback( )
 */
  __pyx_k_tuple_123 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_123)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_123);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_123));

  /* "talib/func.pyx":5545
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPERIOD_Lookback( )
 */
  __pyx_k_tuple_124 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_124)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_124);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_124));

  /* "talib/func.pyx":5588
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_DCPHASE_Lookback( )
 */
  __pyx_k_tuple_125 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_125)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_125);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_125));

  /* "talib/func.pyx":5634
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_PHASOR_Lookback( )
 */
  __pyx_k_tuple_126 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_126)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_126);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_126));

  /* "talib/func.pyx":5684
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_SINE_Lookback( )
 */
  __pyx_k_tuple_127 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_127)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5684; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_127);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_127));

  /* "talib/func.pyx":5731
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDLINE_Lookback( )
 */
  __pyx_k_tuple_128 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_128)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_128);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_128));

  /* "talib/func.pyx":5774
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_HT_TRENDMODE_Lookback( )
 */
  __pyx_k_tuple_129 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_129)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5774; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_129);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_129));

  /* "talib/func.pyx":5819
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_KAMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_130 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_130)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5819; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_130);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_130));

  /* "talib/func.pyx":5864
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_Lookback( timeperiod )
 */
  __pyx_k_tuple_131 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_131)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_131);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_131));

  /* "talib/func.pyx":5909
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_ANGLE_Lookback( timeperiod )
 */
  __pyx_k_tuple_132 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_132)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5909; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_132);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_132));

  /* "talib/func.pyx":5954
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_INTERCEPT_Lookback( timeperiod )
 */
  __pyx_k_tuple_133 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_133)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_133);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_133));

  /* "talib/func.pyx":5999
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LINEARREG_SLOPE_Lookback( timeperiod )
 */
  __pyx_k_tuple_135 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_135)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5999; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_135);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_135));

  /* "talib/func.pyx":6042
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LN_Lookback( )
 */
  __pyx_k_tuple_136 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_136)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6042; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_136);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_136));

  /* "talib/func.pyx":6085
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_LOG10_Lookback( )
 */
  __pyx_k_tuple_137 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_137)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6085; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_137);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_137));

  /* "talib/func.pyx":6131
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MA_Lookback( timeperiod , matype )
 */
  __pyx_k_tuple_138 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_138)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6131; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_138);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_138));

  /* "talib/func.pyx":6184
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACD_Lookback( fastperiod , slowperiod , signalperiod )
 */
  __pyx_k_tuple_139 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_139)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_139);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_139));

  /* "talib/func.pyx":6248
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDEXT_Lookback( fastperiod , fastmatype , slowperiod , slowmatype , signalperiod , signalmatype )
 */
  __pyx_k_tuple_140 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_140)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6248; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_140);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_140));

  /* "talib/func.pyx":6307
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MACDFIX_Lookback( signalperiod )
 */
  __pyx_k_tuple_141 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_141)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_141);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_141));

  /* "talib/func.pyx":6364
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAMA_Lookback( fastlimit , slowlimit )
 */
  __pyx_k_tuple_142 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_142)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_142);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_142));

  /* "talib/func.pyx":6422
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAVP_Lookback( minperiod , maxperiod , matype )
 */
  __pyx_k_tuple_145 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_145)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6422; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_145);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_145));

  /* "talib/func.pyx":6467
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAX_Lookback( timeperiod )
 */
  __pyx_k_tuple_146 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_146)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_146);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_146));

  /* "talib/func.pyx":6512
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MAXINDEX_Lookback( timeperiod )
 */
  __pyx_k_tuple_147 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_147)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6512; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_147);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_147));

  /* "talib/func.pyx":6561
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MEDPRICE_Lookback( )
 */
  __pyx_k_tuple_148 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_148)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_148);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_148));

  /* "talib/func.pyx":6624
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MFI_Lookback( timeperiod )
 */
  __pyx_k_tuple_149 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_149)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6624; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_149);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_149));

  /* "talib/func.pyx":6669
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPOINT_Lookback( timeperiod )
 */
  __pyx_k_tuple_150 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_150)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_150);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_150));

  /* "talib/func.pyx":6720
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIDPRICE_Lookback( timeperiod )
 */
  __pyx_k_tuple_151 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_151)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6720; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_151);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_151));

  /* "talib/func.pyx":6765
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MIN_Lookback( timeperiod )
 */
  __pyx_k_tuple_152 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_152)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_152);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_152));

  /* "talib/func.pyx":6810
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MININDEX_Lookback( timeperiod )
 */
  __pyx_k_tuple_153 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_153)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_153);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_153));

  /* "talib/func.pyx":6858
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAX_Lookback( timeperiod )
 */
  __pyx_k_tuple_154 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_154)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_154);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_154));

  /* "talib/func.pyx":6910
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINMAXINDEX_Lookback( timeperiod )
 */
  __pyx_k_tuple_155 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_155)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6910; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_155);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_155));

  /* "talib/func.pyx":6971
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DI_Lookback( timeperiod )
 */
  __pyx_k_tuple_156 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_156)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_156);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_156));

  /* "talib/func.pyx":7022
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MINUS_DM_Lookback( timeperiod )
 */
  __pyx_k_tuple_157 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_157)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7022; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_157);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_157));

  /* "talib/func.pyx":7067
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MOM_Lookback( timeperiod )
 */
  __pyx_k_tuple_158 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_158)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7067; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_158);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_158));

  /* "talib/func.pyx":7117
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_MULT_Lookback( )
 */
  __pyx_k_tuple_159 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_159)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_159);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_159));

  /* "talib/func.pyx":7174
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_NATR_Lookback( timeperiod )
 */
  __pyx_k_tuple_160 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_160)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_160);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_160));

  /* "talib/func.pyx":7224
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_OBV_Lookback( )
 */
  __pyx_k_tuple_161 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_161)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7224; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_161);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_161));

  /* "talib/func.pyx":7281
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DI_Lookback( timeperiod )
 */
  __pyx_k_tuple_162 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_162)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7281; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_162);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_162));

  /* "talib/func.pyx":7332
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PLUS_DM_Lookback( timeperiod )
 */
  __pyx_k_tuple_163 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_163)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_163);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_163));

  /* "talib/func.pyx":7379
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_PPO_Lookback( fastperiod , slowperiod , matype )
 */
  __pyx_k_tuple_164 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_164)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_164);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_164));

  /* "talib/func.pyx":7424
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROC_Lookback( timeperiod )
 */
  __pyx_k_tuple_165 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_165)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7424; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_165);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_165));

  /* "talib/func.pyx":7469
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCP_Lookback( timeperiod )
 */
  __pyx_k_tuple_166 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_166)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7469; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_166);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_166));

  /* "talib/func.pyx":7514
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR_Lookback( timeperiod )
 */
  __pyx_k_tuple_167 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_167)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7514; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_167);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_167));

  /* "talib/func.pyx":7559
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ROCR100_Lookback( timeperiod )
 */
  __pyx_k_tuple_168 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_168)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7559; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_168);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_168));

  /* "talib/func.pyx":7604
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_RSI_Lookback( timeperiod )
 */
  __pyx_k_tuple_169 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_169)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_169);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_169));

  /* "talib/func.pyx":7656
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAR_Lookback( acceleration , maximum )
 */
  __pyx_k_tuple_170 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_170)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7656; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_170);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_170));

  /* "talib/func.pyx":7714
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SAREXT_Lookback( startvalue , offsetonreverse , accelerationinitlong , accelerationlong , accelerationmaxlong , accelerationinitshort , accelerationshort , accelerationmaxshort )
 */
  __pyx_k_tuple_174 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_174)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_174);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_174));

  /* "talib/func.pyx":7757
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SIN_Lookback( )
 */
  __pyx_k_tuple_175 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_175)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7757; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_175);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_175));

  /* "talib/func.pyx":7800
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SINH_Lookback( )
 */
  __pyx_k_tuple_176 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_176)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_176);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_176));

  /* "talib/func.pyx":7845
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_177 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_177)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7845; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_177);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_177));

  /* "talib/func.pyx":7888
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SQRT_Lookback( )
 */
  __pyx_k_tuple_178 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_178)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7888; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_178);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_178));

  /* "talib/func.pyx":7934
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STDDEV_Lookback( timeperiod , nbdev )
 */
  __pyx_k_tuple_179 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_179)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_179);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_179));

  /* "talib/func.pyx":7998
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCH_Lookback( fastk_period , slowk_period , slowk_matype , slowd_period , slowd_matype )
 */
  __pyx_k_tuple_180 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_180)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7998; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_180);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_180));

  /* "talib/func.pyx":8064
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHF_Lookback( fastk_period , fastd_period , fastd_matype )
 */
  __pyx_k_tuple_181 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_181)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8064; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_181);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_181));

  /* "talib/func.pyx":8119
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_STOCHRSI_Lookback( timeperiod , fastk_period , fastd_period , fastd_matype )
 */
  __pyx_k_tuple_182 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_182)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_182);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_182));

  /* "talib/func.pyx":8173
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUB_Lookback( )
 */
  __pyx_k_tuple_183 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_183)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_183);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_183));

  /* "talib/func.pyx":8218
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_SUM_Lookback( timeperiod )
 */
  __pyx_k_tuple_184 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_184)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_184);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_184));

  /* "talib/func.pyx":8264
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_T3_Lookback( timeperiod , vfactor )
 */
  __pyx_k_tuple_185 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_185)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_185);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_185));

  /* "talib/func.pyx":8307
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TAN_Lookback( )
 */
  __pyx_k_tuple_186 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_186)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_186);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_186));

  /* "talib/func.pyx":8350
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TANH_Lookback( )
 */
  __pyx_k_tuple_187 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_187)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8350; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_187);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_187));

  /* "talib/func.pyx":8395
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TEMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_188 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_188)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_188);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_188));

  /* "talib/func.pyx":8450
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRANGE_Lookback( )
 */
  __pyx_k_tuple_189 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_189)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8450; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_189);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_189));

  /* "talib/func.pyx":8495
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_190 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_190)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_190);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_190));

  /* "talib/func.pyx":8540
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TRIX_Lookback( timeperiod )
 */
  __pyx_k_tuple_191 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_191)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_191);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_191));

  /* "talib/func.pyx":8585
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TSF_Lookback( timeperiod )
 */
  __pyx_k_tuple_192 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_192)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_192);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_192));

  /* "talib/func.pyx":8640
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_TYPPRICE_Lookback( )
 */
  __pyx_k_tuple_193 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_193)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_193);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_193));

  /* "talib/func.pyx":8699
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_ULTOSC_Lookback( timeperiod1 , timeperiod2 , timeperiod3 )
 */
  __pyx_k_tuple_194 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_194)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_194);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_194));

  /* "talib/func.pyx":8745
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_VAR_Lookback( timeperiod , nbdev )
 */
  __pyx_k_tuple_195 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_195)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8745; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_195);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_195));

  /* "talib/func.pyx":8800
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WCLPRICE_Lookback( )
 */
  __pyx_k_tuple_196 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_196)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8800; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_196);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_196));

  /* "talib/func.pyx":8857
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WILLR_Lookback( timeperiod )
 */
  __pyx_k_tuple_197 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_197)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8857; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_197);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_197));

  /* "talib/func.pyx":8902
 *             break
 *     else:
 *         raise Exception("inputs are all NaN")             # <<<<<<<<<<<<<<
 *     endidx = length - begidx - 1
 *     lookback = begidx + TA_WMA_Lookback( timeperiod )
 */
  __pyx_k_tuple_198 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_s_3)); if (unlikely(!__pyx_k_tuple_198)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8902; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_198);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_198));

  /* "numpy.pxd":215
 *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
 * 
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 */
  __pyx_k_tuple_200 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_199)); if (unlikely(!__pyx_k_tuple_200)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 215; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_200);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_200));

  /* "numpy.pxd":219
 *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
 *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
 *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
 * 
 *             info.buf = PyArray_DATA(self)
 */
  __pyx_k_tuple_202 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_201)); if (unlikely(!__pyx_k_tuple_202)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 219; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_202);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_202));

  /* "numpy.pxd":257
 *                 if ((descr.byteorder == c'>' and little_endian) or
 *                     (descr.byteorder == c'<' and not little_endian)):
 *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *                 if   t == NPY_BYTE:        f = "b"
 *                 elif t == NPY_UBYTE:       f = "B"
 */
  __pyx_k_tuple_204 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_203)); if (unlikely(!__pyx_k_tuple_204)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_204);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_204));

  /* "numpy.pxd":799
 * 
 *         if (end - f) - (new_offset - offset[0]) < 15:
 *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
 * 
 *         if ((child.byteorder == c'>' and little_endian) or
 */
  __pyx_k_tuple_207 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_206)); if (unlikely(!__pyx_k_tuple_207)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 799; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_207);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_207));

  /* "numpy.pxd":803
 *         if ((child.byteorder == c'>' and little_endian) or
 *             (child.byteorder == c'<' and not little_endian)):
 *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
 *             # One could encode it in the format string and have Cython
 *             # complain instead, BUT: < and > in format strings also imply
 */
  __pyx_k_tuple_208 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_203)); if (unlikely(!__pyx_k_tuple_208)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_208);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_208));

  /* "numpy.pxd":823
 *             t = child.type_num
 *             if end - f < 5:
 *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
 * 
 *             # Until ticket #99 is fixed, use integers to avoid warnings
 */
  __pyx_k_tuple_210 = PyTuple_Pack(1, ((PyObject *)__pyx_kp_u_209)); if (unlikely(!__pyx_k_tuple_210)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_210);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_210));

  /* "talib/func.pyx":347
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ACOS( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ACOS(real)
 * 
 */
  __pyx_k_tuple_211 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_211)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_211);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_211));
  __pyx_k_codeobj_212 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_211, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ACOS, 347, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_212)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":390
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AD( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None ):             # <<<<<<<<<<<<<<
 *     """ AD(high, low, close, volume)
 * 
 */
  __pyx_k_tuple_215 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__volume), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__volume_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_215)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_215);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_215));
  __pyx_k_codeobj_216 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_215, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__AD, 390, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_216)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":451
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADD( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ ADD(real0, real1)
 * 
 */
  __pyx_k_tuple_217 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real0), ((PyObject *)__pyx_n_s__real1), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real0_data), ((PyObject *)__pyx_n_s__real1_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_217)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_217);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_217));
  __pyx_k_codeobj_218 = (PyObject*)__Pyx_PyCode_New(2, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_217, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ADD, 451, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_218)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":501
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADOSC( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None , int fastperiod=-2**31 , int slowperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADOSC(high, low, close, volume[, fastperiod=?, slowperiod=?])
 * 
 */
  __pyx_k_tuple_219 = PyTuple_Pack(20, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__volume), ((PyObject *)__pyx_n_s__fastperiod), ((PyObject *)__pyx_n_s__slowperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__volume_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_219)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_219);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_219));
  __pyx_k_codeobj_220 = (PyObject*)__Pyx_PyCode_New(6, 0, 20, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_219, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ADOSC, 501, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_220)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":565
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADX( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADX(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_221 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_221)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_221);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_221));
  __pyx_k_codeobj_222 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_221, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ADX, 565, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_222)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":622
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADXR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADXR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_223 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_223)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_223);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_223));
  __pyx_k_codeobj_224 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_223, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ADXR, 622, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_224)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":679
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def APO( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ APO(real[, fastperiod=?, slowperiod=?, matype=?])
 * 
 */
  __pyx_k_tuple_225 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__fastperiod), ((PyObject *)__pyx_n_s__slowperiod), ((PyObject *)__pyx_n_s__matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_225)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_225);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_225));
  __pyx_k_codeobj_226 = (PyObject*)__Pyx_PyCode_New(4, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_225, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__APO, 679, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_226)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":726
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AROON( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ AROON(high, low[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_227 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outaroondown), ((PyObject *)__pyx_n_s__outaroondown_data), ((PyObject *)__pyx_n_s__outaroonup), ((PyObject *)__pyx_n_s__outaroonup_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_227)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_227);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_227));
  __pyx_k_codeobj_228 = (PyObject*)__Pyx_PyCode_New(3, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_227, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__AROON, 726, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_228)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":784
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AROONOSC( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ AROONOSC(high, low[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_229 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_229)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_229);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_229));
  __pyx_k_codeobj_230 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_229, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__AROONOSC, 784, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_230)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":835
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ASIN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ASIN(real)
 * 
 */
  __pyx_k_tuple_231 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_231)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_231);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_231));
  __pyx_k_codeobj_232 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_231, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ASIN, 835, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_232)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":878
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ATAN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ATAN(real)
 * 
 */
  __pyx_k_tuple_233 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_233)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 878; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_233);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_233));
  __pyx_k_codeobj_234 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_233, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ATAN, 878, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_234)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 878; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":921
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ATR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ATR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_235 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_235)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_235);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_235));
  __pyx_k_codeobj_236 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_235, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ATR, 921, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_236)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":978
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AVGPRICE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ AVGPRICE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_237 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_237)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_237);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_237));
  __pyx_k_codeobj_238 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_237, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__AVGPRICE, 978, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_238)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1039
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BBANDS( np.ndarray real not None , int timeperiod=-2**31 , double nbdevup=-4e37 , double nbdevdn=-4e37 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ BBANDS(real[, timeperiod=?, nbdevup=?, nbdevdn=?, matype=?])
 * 
 */
  __pyx_k_tuple_242 = PyTuple_Pack(20, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__nbdevup), ((PyObject *)__pyx_n_s__nbdevdn), ((PyObject *)__pyx_n_s__matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outrealupperband), ((PyObject *)__pyx_n_s_239), ((PyObject *)__pyx_n_s__outrealmiddleband), ((PyObject *)__pyx_n_s_240), ((PyObject *)__pyx_n_s__outreallowerband), ((PyObject *)__pyx_n_s_241), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_242)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_242);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_242));
  __pyx_k_codeobj_243 = (PyObject*)__Pyx_PyCode_New(5, 0, 20, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_242, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__BBANDS, 1039, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_243)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1101
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BETA( np.ndarray real0 not None , np.ndarray real1 not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ BETA(real0, real1[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_244 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__real0), ((PyObject *)__pyx_n_s__real1), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real0_data), ((PyObject *)__pyx_n_s__real1_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_244)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_244);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_244));
  __pyx_k_codeobj_245 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_244, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__BETA, 1101, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_245)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1153
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BOP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ BOP(open, high, low, close)
 * 
 */
  __pyx_k_tuple_246 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_246)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_246);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_246));
  __pyx_k_codeobj_247 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_246, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__BOP, 1153, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_247)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1214
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CCI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CCI(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_248 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_248)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_248);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_248));
  __pyx_k_codeobj_249 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_248, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CCI, 1214, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_249)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1271
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL2CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL2CROWS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_250 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_250)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_250);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_250));
  __pyx_k_codeobj_251 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_250, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL2CROWS, 1271, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_251)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1332
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3BLACKCROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3BLACKCROWS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_252 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_252)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_252);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_252));
  __pyx_k_codeobj_253 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_252, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL3BLACKCROWS, 1332, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_253)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1393
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3INSIDE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3INSIDE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_254 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_254)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_254);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_254));
  __pyx_k_codeobj_255 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_254, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL3INSIDE, 1393, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_255)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1454
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3LINESTRIKE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3LINESTRIKE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_256 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_256)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_256);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_256));
  __pyx_k_codeobj_257 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_256, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL3LINESTRIKE, 1454, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_257)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1515
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3OUTSIDE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3OUTSIDE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_258 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_258)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_258);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_258));
  __pyx_k_codeobj_259 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_258, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL3OUTSIDE, 1515, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_259)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1576
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3STARSINSOUTH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3STARSINSOUTH(open, high, low, close)
 * 
 */
  __pyx_k_tuple_260 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_260)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_260);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_260));
  __pyx_k_codeobj_261 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_260, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL3STARSINSOUTH, 1576, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_261)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1637
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3WHITESOLDIERS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3WHITESOLDIERS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_262 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_262)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_262);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_262));
  __pyx_k_codeobj_263 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_262, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDL3WHITESOLDIERS, 1637, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_263)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1698
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLABANDONEDBABY( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLABANDONEDBABY(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_264 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_264)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_264);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_264));
  __pyx_k_codeobj_265 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_264, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLABANDONEDBABY, 1698, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_265)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1761
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLADVANCEBLOCK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLADVANCEBLOCK(open, high, low, close)
 * 
 */
  __pyx_k_tuple_266 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_266)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_266);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_266));
  __pyx_k_codeobj_267 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_266, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLADVANCEBLOCK, 1761, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_267)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1822
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLBELTHOLD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLBELTHOLD(open, high, low, close)
 * 
 */
  __pyx_k_tuple_268 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_268)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_268);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_268));
  __pyx_k_codeobj_269 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_268, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLBELTHOLD, 1822, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_269)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1883
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLBREAKAWAY( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLBREAKAWAY(open, high, low, close)
 * 
 */
  __pyx_k_tuple_270 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_270)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_270);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_270));
  __pyx_k_codeobj_271 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_270, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLBREAKAWAY, 1883, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_271)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":1944
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCLOSINGMARUBOZU( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCLOSINGMARUBOZU(open, high, low, close)
 * 
 */
  __pyx_k_tuple_272 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_272)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_272);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_272));
  __pyx_k_codeobj_273 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_272, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLCLOSINGMARUBOZU, 1944, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_273)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2005
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCONCEALBABYSWALL( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCONCEALBABYSWALL(open, high, low, close)
 * 
 */
  __pyx_k_tuple_274 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_274)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_274);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_274));
  __pyx_k_codeobj_275 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_274, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLCONCEALBABYSWALL, 2005, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_275)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2066
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCOUNTERATTACK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCOUNTERATTACK(open, high, low, close)
 * 
 */
  __pyx_k_tuple_276 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_276)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_276);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_276));
  __pyx_k_codeobj_277 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_276, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLCOUNTERATTACK, 2066, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_277)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2127
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDARKCLOUDCOVER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.5 ):             # <<<<<<<<<<<<<<
 *     """ CDLDARKCLOUDCOVER(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_278 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_278)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_278);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_278));
  __pyx_k_codeobj_279 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_278, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLDARKCLOUDCOVER, 2127, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_279)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2190
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDOJI(open, high, low, close)
 * 
 */
  __pyx_k_tuple_280 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_280)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_280);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_280));
  __pyx_k_codeobj_281 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_280, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLDOJI, 2190, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_281)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2251
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDOJISTAR(open, high, low, close)
 * 
 */
  __pyx_k_tuple_282 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_282)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_282);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_282));
  __pyx_k_codeobj_283 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_282, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLDOJISTAR, 2251, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_283)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2312
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDRAGONFLYDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDRAGONFLYDOJI(open, high, low, close)
 * 
 */
  __pyx_k_tuple_284 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_284)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_284);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_284));
  __pyx_k_codeobj_285 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_284, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLDRAGONFLYDOJI, 2312, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_285)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2373
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLENGULFING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLENGULFING(open, high, low, close)
 * 
 */
  __pyx_k_tuple_286 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_286)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_286);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_286));
  __pyx_k_codeobj_287 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_286, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLENGULFING, 2373, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_287)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2434
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLEVENINGDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLEVENINGDOJISTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_288 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_288)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_288);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_288));
  __pyx_k_codeobj_289 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_288, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLEVENINGDOJISTAR, 2434, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_289)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2497
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLEVENINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLEVENINGSTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_290 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_290)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_290);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_290));
  __pyx_k_codeobj_291 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_290, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLEVENINGSTAR, 2497, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_291)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2560
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLGAPSIDESIDEWHITE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLGAPSIDESIDEWHITE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_292 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_292)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_292);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_292));
  __pyx_k_codeobj_293 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_292, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLGAPSIDESIDEWHITE, 2560, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_293)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2621
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLGRAVESTONEDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLGRAVESTONEDOJI(open, high, low, close)
 * 
 */
  __pyx_k_tuple_294 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_294)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_294);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_294));
  __pyx_k_codeobj_295 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_294, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLGRAVESTONEDOJI, 2621, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_295)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2682
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHAMMER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHAMMER(open, high, low, close)
 * 
 */
  __pyx_k_tuple_296 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_296)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_296);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_296));
  __pyx_k_codeobj_297 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_296, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHAMMER, 2682, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_297)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2743
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHANGINGMAN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHANGINGMAN(open, high, low, close)
 * 
 */
  __pyx_k_tuple_298 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_298)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_298);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_298));
  __pyx_k_codeobj_299 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_298, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHANGINGMAN, 2743, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_299)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2804
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHARAMI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHARAMI(open, high, low, close)
 * 
 */
  __pyx_k_tuple_300 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_300)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_300);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_300));
  __pyx_k_codeobj_301 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_300, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHARAMI, 2804, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_301)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2865
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHARAMICROSS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHARAMICROSS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_302 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_302)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_302);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_302));
  __pyx_k_codeobj_303 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_302, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHARAMICROSS, 2865, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_303)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2926
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIGHWAVE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIGHWAVE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_304 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_304)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_304);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_304));
  __pyx_k_codeobj_305 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_304, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHIGHWAVE, 2926, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_305)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":2987
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIKKAKE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIKKAKE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_306 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_306)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_306);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_306));
  __pyx_k_codeobj_307 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_306, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHIKKAKE, 2987, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_307)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3048
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIKKAKEMOD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIKKAKEMOD(open, high, low, close)
 * 
 */
  __pyx_k_tuple_308 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_308)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_308);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_308));
  __pyx_k_codeobj_309 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_308, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHIKKAKEMOD, 3048, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_309)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3109
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHOMINGPIGEON( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHOMINGPIGEON(open, high, low, close)
 * 
 */
  __pyx_k_tuple_310 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_310)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_310);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_310));
  __pyx_k_codeobj_311 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_310, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLHOMINGPIGEON, 3109, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_311)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3170
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLIDENTICAL3CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLIDENTICAL3CROWS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_312 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_312)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_312);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_312));
  __pyx_k_codeobj_313 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_312, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLIDENTICAL3CROWS, 3170, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_313)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3231
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLINNECK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLINNECK(open, high, low, close)
 * 
 */
  __pyx_k_tuple_314 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_314)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_314);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_314));
  __pyx_k_codeobj_315 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_314, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLINNECK, 3231, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_315)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3292
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLINVERTEDHAMMER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLINVERTEDHAMMER(open, high, low, close)
 * 
 */
  __pyx_k_tuple_316 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_316)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_316);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_316));
  __pyx_k_codeobj_317 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_316, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLINVERTEDHAMMER, 3292, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_317)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3353
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLKICKING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLKICKING(open, high, low, close)
 * 
 */
  __pyx_k_tuple_318 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_318)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_318);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_318));
  __pyx_k_codeobj_319 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_318, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLKICKING, 3353, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_319)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3414
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLKICKINGBYLENGTH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLKICKINGBYLENGTH(open, high, low, close)
 * 
 */
  __pyx_k_tuple_320 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_320)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_320);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_320));
  __pyx_k_codeobj_321 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_320, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLKICKINGBYLENGTH, 3414, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_321)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3475
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLADDERBOTTOM( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLADDERBOTTOM(open, high, low, close)
 * 
 */
  __pyx_k_tuple_322 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_322)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_322);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_322));
  __pyx_k_codeobj_323 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_322, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLLADDERBOTTOM, 3475, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_323)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3536
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLONGLEGGEDDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLONGLEGGEDDOJI(open, high, low, close)
 * 
 */
  __pyx_k_tuple_324 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_324)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_324);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_324));
  __pyx_k_codeobj_325 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_324, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLLONGLEGGEDDOJI, 3536, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_325)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3597
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLONGLINE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLONGLINE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_326 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_326)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_326);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_326));
  __pyx_k_codeobj_327 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_326, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLLONGLINE, 3597, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_327)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3658
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMARUBOZU( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLMARUBOZU(open, high, low, close)
 * 
 */
  __pyx_k_tuple_328 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_328)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_328);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_328));
  __pyx_k_codeobj_329 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_328, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLMARUBOZU, 3658, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_329)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3719
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMATCHINGLOW( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLMATCHINGLOW(open, high, low, close)
 * 
 */
  __pyx_k_tuple_330 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_330)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_330);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_330));
  __pyx_k_codeobj_331 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_330, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLMATCHINGLOW, 3719, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_331)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3780
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMATHOLD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.5 ):             # <<<<<<<<<<<<<<
 *     """ CDLMATHOLD(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_332 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_332)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_332);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_332));
  __pyx_k_codeobj_333 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_332, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLMATHOLD, 3780, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_333)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3843
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMORNINGDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLMORNINGDOJISTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_334 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_334)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_334);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_334));
  __pyx_k_codeobj_335 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_334, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLMORNINGDOJISTAR, 3843, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_335)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3906
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMORNINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLMORNINGSTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_k_tuple_336 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__penetration), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_336)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_336);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_336));
  __pyx_k_codeobj_337 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_336, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLMORNINGSTAR, 3906, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_337)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":3969
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLONNECK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLONNECK(open, high, low, close)
 * 
 */
  __pyx_k_tuple_338 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_338)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_338);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_338));
  __pyx_k_codeobj_339 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_338, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLONNECK, 3969, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_339)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4030
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLPIERCING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLPIERCING(open, high, low, close)
 * 
 */
  __pyx_k_tuple_340 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_340)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_340);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_340));
  __pyx_k_codeobj_341 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_340, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLPIERCING, 4030, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_341)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4091
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLRICKSHAWMAN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLRICKSHAWMAN(open, high, low, close)
 * 
 */
  __pyx_k_tuple_342 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_342)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_342);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_342));
  __pyx_k_codeobj_343 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_342, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLRICKSHAWMAN, 4091, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_343)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4152
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLRISEFALL3METHODS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLRISEFALL3METHODS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_344 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_344)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_344);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_344));
  __pyx_k_codeobj_345 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_344, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLRISEFALL3METHODS, 4152, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_345)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4213
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSEPARATINGLINES( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSEPARATINGLINES(open, high, low, close)
 * 
 */
  __pyx_k_tuple_346 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_346)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_346);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_346));
  __pyx_k_codeobj_347 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_346, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLSEPARATINGLINES, 4213, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_347)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4274
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSHOOTINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSHOOTINGSTAR(open, high, low, close)
 * 
 */
  __pyx_k_tuple_348 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_348)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_348);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_348));
  __pyx_k_codeobj_349 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_348, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLSHOOTINGSTAR, 4274, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_349)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4335
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSHORTLINE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSHORTLINE(open, high, low, close)
 * 
 */
  __pyx_k_tuple_350 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_350)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_350);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_350));
  __pyx_k_codeobj_351 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_350, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLSHORTLINE, 4335, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_351)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4396
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSPINNINGTOP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSPINNINGTOP(open, high, low, close)
 * 
 */
  __pyx_k_tuple_352 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_352)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_352);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_352));
  __pyx_k_codeobj_353 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_352, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLSPINNINGTOP, 4396, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_353)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4457
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSTALLEDPATTERN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSTALLEDPATTERN(open, high, low, close)
 * 
 */
  __pyx_k_tuple_354 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_354)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_354);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_354));
  __pyx_k_codeobj_355 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_354, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLSTALLEDPATTERN, 4457, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_355)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4518
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSTICKSANDWICH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSTICKSANDWICH(open, high, low, close)
 * 
 */
  __pyx_k_tuple_356 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_356)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_356);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_356));
  __pyx_k_codeobj_357 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_356, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLSTICKSANDWICH, 4518, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_357)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4579
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTAKURI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTAKURI(open, high, low, close)
 * 
 */
  __pyx_k_tuple_358 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_358)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_358);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_358));
  __pyx_k_codeobj_359 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_358, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLTAKURI, 4579, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_359)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4640
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTASUKIGAP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTASUKIGAP(open, high, low, close)
 * 
 */
  __pyx_k_tuple_360 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_360)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_360);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_360));
  __pyx_k_codeobj_361 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_360, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLTASUKIGAP, 4640, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_361)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4701
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTHRUSTING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTHRUSTING(open, high, low, close)
 * 
 */
  __pyx_k_tuple_362 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_362)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_362);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_362));
  __pyx_k_codeobj_363 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_362, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLTHRUSTING, 4701, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_363)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4762
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTRISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTRISTAR(open, high, low, close)
 * 
 */
  __pyx_k_tuple_364 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_364)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_364);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_364));
  __pyx_k_codeobj_365 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_364, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLTRISTAR, 4762, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_365)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4823
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLUNIQUE3RIVER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLUNIQUE3RIVER(open, high, low, close)
 * 
 */
  __pyx_k_tuple_366 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_366)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_366);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_366));
  __pyx_k_codeobj_367 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_366, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLUNIQUE3RIVER, 4823, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_367)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4884
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLUPSIDEGAP2CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLUPSIDEGAP2CROWS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_368 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_368)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_368);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_368));
  __pyx_k_codeobj_369 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_368, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLUPSIDEGAP2CROWS, 4884, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_369)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":4945
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLXSIDEGAP3METHODS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLXSIDEGAP3METHODS(open, high, low, close)
 * 
 */
  __pyx_k_tuple_370 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__open), ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__open_data), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_370)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_370);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_370));
  __pyx_k_codeobj_371 = (PyObject*)__Pyx_PyCode_New(4, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_370, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CDLXSIDEGAP3METHODS, 4945, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_371)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5006
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CEIL( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ CEIL(real)
 * 
 */
  __pyx_k_tuple_372 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_372)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_372);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_372));
  __pyx_k_codeobj_373 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_372, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CEIL, 5006, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_373)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5049
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CMO( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CMO(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_374 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_374)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_374);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_374));
  __pyx_k_codeobj_375 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_374, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CMO, 5049, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_375)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5094
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CORREL( np.ndarray real0 not None , np.ndarray real1 not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CORREL(real0, real1[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_376 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__real0), ((PyObject *)__pyx_n_s__real1), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real0_data), ((PyObject *)__pyx_n_s__real1_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_376)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_376);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_376));
  __pyx_k_codeobj_377 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_376, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__CORREL, 5094, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_377)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5146
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def COS( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ COS(real)
 * 
 */
  __pyx_k_tuple_378 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_378)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_378);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_378));
  __pyx_k_codeobj_379 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_378, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__COS, 5146, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_379)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5189
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def COSH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ COSH(real)
 * 
 */
  __pyx_k_tuple_380 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_380)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_380);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_380));
  __pyx_k_codeobj_381 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_380, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__COSH, 5189, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_381)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5232
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DEMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ DEMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_382 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_382)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_382);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_382));
  __pyx_k_codeobj_383 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_382, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__DEMA, 5232, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_383)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5277
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DIV( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ DIV(real0, real1)
 * 
 */
  __pyx_k_tuple_384 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real0), ((PyObject *)__pyx_n_s__real1), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real0_data), ((PyObject *)__pyx_n_s__real1_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_384)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_384);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_384));
  __pyx_k_codeobj_385 = (PyObject*)__Pyx_PyCode_New(2, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_384, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__DIV, 5277, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_385)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5327
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DX( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ DX(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_386 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_386)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_386);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_386));
  __pyx_k_codeobj_387 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_386, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__DX, 5327, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_387)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5384
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def EMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ EMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_388 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_388)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_388);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_388));
  __pyx_k_codeobj_389 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_388, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__EMA, 5384, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_389)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5429
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def EXP( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ EXP(real)
 * 
 */
  __pyx_k_tuple_390 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_390)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_390);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_390));
  __pyx_k_codeobj_391 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_390, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__EXP, 5429, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_391)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5472
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def FLOOR( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ FLOOR(real)
 * 
 */
  __pyx_k_tuple_392 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_392)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_392);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_392));
  __pyx_k_codeobj_393 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_392, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__FLOOR, 5472, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_393)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5515
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_DCPERIOD( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_DCPERIOD(real)
 * 
 */
  __pyx_k_tuple_394 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_394)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_394);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_394));
  __pyx_k_codeobj_395 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_394, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__HT_DCPERIOD, 5515, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_395)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5558
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_DCPHASE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_DCPHASE(real)
 * 
 */
  __pyx_k_tuple_396 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_396)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_396);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_396));
  __pyx_k_codeobj_397 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_396, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__HT_DCPHASE, 5558, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_397)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5601
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_PHASOR( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_PHASOR(real)
 * 
 */
  __pyx_k_tuple_398 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinphase), ((PyObject *)__pyx_n_s__outinphase_data), ((PyObject *)__pyx_n_s__outquadrature), ((PyObject *)__pyx_n_s__outquadrature_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_398)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_398);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_398));
  __pyx_k_codeobj_399 = (PyObject*)__Pyx_PyCode_New(1, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_398, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__HT_PHASOR, 5601, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_399)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5651
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_SINE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_SINE(real)
 * 
 */
  __pyx_k_tuple_400 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outsine), ((PyObject *)__pyx_n_s__outsine_data), ((PyObject *)__pyx_n_s__outleadsine), ((PyObject *)__pyx_n_s__outleadsine_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_400)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5651; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_400);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_400));
  __pyx_k_codeobj_401 = (PyObject*)__Pyx_PyCode_New(1, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_400, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__HT_SINE, 5651, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_401)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5651; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5701
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_TRENDLINE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_TRENDLINE(real)
 * 
 */
  __pyx_k_tuple_402 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_402)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_402);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_402));
  __pyx_k_codeobj_403 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_402, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__HT_TRENDLINE, 5701, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_403)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5744
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_TRENDMODE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_TRENDMODE(real)
 * 
 */
  __pyx_k_tuple_404 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_404)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_404);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_404));
  __pyx_k_codeobj_405 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_404, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__HT_TRENDMODE, 5744, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_405)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5787
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def KAMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ KAMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_406 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_406)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_406);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_406));
  __pyx_k_codeobj_407 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_406, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__KAMA, 5787, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_407)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5832
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_408 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_408)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_408);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_408));
  __pyx_k_codeobj_409 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_408, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__LINEARREG, 5832, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_409)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5877
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_ANGLE( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_ANGLE(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_410 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_410)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_410);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_410));
  __pyx_k_codeobj_411 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_410, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__LINEARREG_ANGLE, 5877, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_411)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5922
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_INTERCEPT( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_INTERCEPT(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_412 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_412)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_412);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_412));
  __pyx_k_codeobj_413 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_412, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__LINEARREG_INTERCEPT, 5922, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_413)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":5967
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_SLOPE( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_SLOPE(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_414 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_414)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_414);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_414));
  __pyx_k_codeobj_415 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_414, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__LINEARREG_SLOPE, 5967, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_415)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6012
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ LN(real)
 * 
 */
  __pyx_k_tuple_416 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_416)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_416);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_416));
  __pyx_k_codeobj_417 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_416, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__LN, 6012, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_417)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6055
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LOG10( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ LOG10(real)
 * 
 */
  __pyx_k_tuple_418 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_418)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_418);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_418));
  __pyx_k_codeobj_419 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_418, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__LOG10, 6055, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_419)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6098
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MA( np.ndarray real not None , int timeperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ MA(real[, timeperiod=?, matype=?])
 * 
 */
  __pyx_k_tuple_420 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_420)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_420);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_420));
  __pyx_k_codeobj_421 = (PyObject*)__Pyx_PyCode_New(3, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_420, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MA, 6098, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_421)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6144
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACD( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int signalperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MACD(real[, fastperiod=?, slowperiod=?, signalperiod=?])
 * 
 */
  __pyx_k_tuple_422 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__fastperiod), ((PyObject *)__pyx_n_s__slowperiod), ((PyObject *)__pyx_n_s__signalperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outmacd), ((PyObject *)__pyx_n_s__outmacd_data), ((PyObject *)__pyx_n_s__outmacdsignal), ((PyObject *)__pyx_n_s__outmacdsignal_data), ((PyObject *)__pyx_n_s__outmacdhist), ((PyObject *)__pyx_n_s__outmacdhist_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_422)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_422);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_422));
  __pyx_k_codeobj_423 = (PyObject*)__Pyx_PyCode_New(4, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_422, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MACD, 6144, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_423)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6205
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACDEXT( np.ndarray real not None , int fastperiod=-2**31 , int fastmatype=0 , int slowperiod=-2**31 , int slowmatype=0 , int signalperiod=-2**31 , int signalmatype=0 ):             # <<<<<<<<<<<<<<
 *     """ MACDEXT(real[, fastperiod=?, fastmatype=?, slowperiod=?, slowmatype=?, signalperiod=?, signalmatype=?])
 * 
 */
  __pyx_k_tuple_424 = PyTuple_Pack(22, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__fastperiod), ((PyObject *)__pyx_n_s__fastmatype), ((PyObject *)__pyx_n_s__slowperiod), ((PyObject *)__pyx_n_s__slowmatype), ((PyObject *)__pyx_n_s__signalperiod), ((PyObject *)__pyx_n_s__signalmatype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outmacd), ((PyObject *)__pyx_n_s__outmacd_data), ((PyObject *)__pyx_n_s__outmacdsignal), ((PyObject *)__pyx_n_s__outmacdsignal_data), ((PyObject *)__pyx_n_s__outmacdhist), ((PyObject *)__pyx_n_s__outmacdhist_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_424)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_424);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_424));
  __pyx_k_codeobj_425 = (PyObject*)__Pyx_PyCode_New(7, 0, 22, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_424, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MACDEXT, 6205, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_425)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6269
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACDFIX( np.ndarray real not None , int signalperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MACDFIX(real[, signalperiod=?])
 * 
 */
  __pyx_k_tuple_426 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__signalperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outmacd), ((PyObject *)__pyx_n_s__outmacd_data), ((PyObject *)__pyx_n_s__outmacdsignal), ((PyObject *)__pyx_n_s__outmacdsignal_data), ((PyObject *)__pyx_n_s__outmacdhist), ((PyObject *)__pyx_n_s__outmacdhist_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_426)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_426);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_426));
  __pyx_k_codeobj_427 = (PyObject*)__Pyx_PyCode_New(2, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_426, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MACDFIX, 6269, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_427)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6328
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAMA( np.ndarray real not None , double fastlimit=-4e37 , double slowlimit=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ MAMA(real[, fastlimit=?, slowlimit=?])
 * 
 */
  __pyx_k_tuple_428 = PyTuple_Pack(16, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__fastlimit), ((PyObject *)__pyx_n_s__slowlimit), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outmama), ((PyObject *)__pyx_n_s__outmama_data), ((PyObject *)__pyx_n_s__outfama), ((PyObject *)__pyx_n_s__outfama_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_428)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_428);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_428));
  __pyx_k_codeobj_429 = (PyObject*)__Pyx_PyCode_New(3, 0, 16, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_428, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MAMA, 6328, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_429)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6381
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAVP( np.ndarray real not None , np.ndarray periods not None , int minperiod=-2**31 , int maxperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ MAVP(real, periods[, minperiod=?, maxperiod=?, matype=?])
 * 
 */
  __pyx_k_tuple_430 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__periods), ((PyObject *)__pyx_n_s__minperiod), ((PyObject *)__pyx_n_s__maxperiod), ((PyObject *)__pyx_n_s__matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__periods_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_430)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_430);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_430));
  __pyx_k_codeobj_431 = (PyObject*)__Pyx_PyCode_New(5, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_430, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MAVP, 6381, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_431)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6435
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MAX(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_432 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_432)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_432);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_432));
  __pyx_k_codeobj_433 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_432, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MAX, 6435, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_433)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6480
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAXINDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MAXINDEX(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_434 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_434)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_434);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_434));
  __pyx_k_codeobj_435 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_434, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MAXINDEX, 6480, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_435)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6525
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MEDPRICE( np.ndarray high not None , np.ndarray low not None ):             # <<<<<<<<<<<<<<
 *     """ MEDPRICE(high, low)
 * 
 */
  __pyx_k_tuple_436 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_436)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_436);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_436));
  __pyx_k_codeobj_437 = (PyObject*)__Pyx_PyCode_New(2, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_436, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MEDPRICE, 6525, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_437)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6574
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MFI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MFI(high, low, close, volume[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_438 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__volume), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__volume_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_438)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_438);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_438));
  __pyx_k_codeobj_439 = (PyObject*)__Pyx_PyCode_New(5, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_438, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MFI, 6574, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_439)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6637
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIDPOINT( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIDPOINT(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_440 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_440)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_440);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_440));
  __pyx_k_codeobj_441 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_440, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MIDPOINT, 6637, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_441)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6682
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIDPRICE( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIDPRICE(high, low[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_442 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_442)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_442);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_442));
  __pyx_k_codeobj_443 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_442, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MIDPRICE, 6682, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_443)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6733
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIN( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIN(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_444 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_444)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_444);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_444));
  __pyx_k_codeobj_445 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_444, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MIN, 6733, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_445)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6778
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MININDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MININDEX(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_446 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outinteger), ((PyObject *)__pyx_n_s__outinteger_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_446)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_446);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_446));
  __pyx_k_codeobj_447 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_446, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MININDEX, 6778, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_447)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6823
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINMAX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINMAX(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_448 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outmin), ((PyObject *)__pyx_n_s__outmin_data), ((PyObject *)__pyx_n_s__outmax), ((PyObject *)__pyx_n_s__outmax_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_448)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_448);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_448));
  __pyx_k_codeobj_449 = (PyObject*)__Pyx_PyCode_New(2, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_448, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MINMAX, 6823, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_449)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6875
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINMAXINDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINMAXINDEX(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_450 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outminidx), ((PyObject *)__pyx_n_s__outminidx_data), ((PyObject *)__pyx_n_s__outmaxidx), ((PyObject *)__pyx_n_s__outmaxidx_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_450)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_450);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_450));
  __pyx_k_codeobj_451 = (PyObject*)__Pyx_PyCode_New(2, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_450, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MINMAXINDEX, 6875, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_451)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6927
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINUS_DI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINUS_DI(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_452 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_452)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_452);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_452));
  __pyx_k_codeobj_453 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_452, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MINUS_DI, 6927, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_453)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":6984
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINUS_DM( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINUS_DM(high, low[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_454 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_454)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_454);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_454));
  __pyx_k_codeobj_455 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_454, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MINUS_DM, 6984, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_455)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7035
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MOM( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MOM(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_456 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_456)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_456);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_456));
  __pyx_k_codeobj_457 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_456, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MOM, 7035, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_457)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7080
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MULT( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ MULT(real0, real1)
 * 
 */
  __pyx_k_tuple_458 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real0), ((PyObject *)__pyx_n_s__real1), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real0_data), ((PyObject *)__pyx_n_s__real1_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_458)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_458);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_458));
  __pyx_k_codeobj_459 = (PyObject*)__Pyx_PyCode_New(2, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_458, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__MULT, 7080, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_459)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7130
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def NATR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ NATR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_460 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_460)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_460);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_460));
  __pyx_k_codeobj_461 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_460, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__NATR, 7130, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_461)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7187
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def OBV( np.ndarray real not None , np.ndarray volume not None ):             # <<<<<<<<<<<<<<
 *     """ OBV(real, volume)
 * 
 */
  __pyx_k_tuple_462 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__volume), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__volume_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_462)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_462);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_462));
  __pyx_k_codeobj_463 = (PyObject*)__Pyx_PyCode_New(2, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_462, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__OBV, 7187, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_463)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7237
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PLUS_DI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ PLUS_DI(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_464 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_464)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_464);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_464));
  __pyx_k_codeobj_465 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_464, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__PLUS_DI, 7237, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_465)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7294
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PLUS_DM( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ PLUS_DM(high, low[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_466 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_466)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_466);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_466));
  __pyx_k_codeobj_467 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_466, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__PLUS_DM, 7294, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_467)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7345
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PPO( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ PPO(real[, fastperiod=?, slowperiod=?, matype=?])
 * 
 */
  __pyx_k_tuple_468 = PyTuple_Pack(15, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__fastperiod), ((PyObject *)__pyx_n_s__slowperiod), ((PyObject *)__pyx_n_s__matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_468)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_468);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_468));
  __pyx_k_codeobj_469 = (PyObject*)__Pyx_PyCode_New(4, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_468, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__PPO, 7345, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_469)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7392
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROC( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROC(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_470 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_470)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_470);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_470));
  __pyx_k_codeobj_471 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_470, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ROC, 7392, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_471)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7437
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCP( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCP(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_472 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_472)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_472);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_472));
  __pyx_k_codeobj_473 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_472, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ROCP, 7437, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_473)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7482
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCR( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCR(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_474 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_474)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_474);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_474));
  __pyx_k_codeobj_475 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_474, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ROCR, 7482, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_475)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7527
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCR100( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCR100(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_476 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_476)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_476);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_476));
  __pyx_k_codeobj_477 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_476, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ROCR100, 7527, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_477)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7572
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def RSI( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ RSI(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_478 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_478)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_478);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_478));
  __pyx_k_codeobj_479 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_478, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__RSI, 7572, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_479)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7617
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SAR( np.ndarray high not None , np.ndarray low not None , double acceleration=0.02 , double maximum=0.2 ):             # <<<<<<<<<<<<<<
 *     """ SAR(high, low[, acceleration=?, maximum=?])
 * 
 */
  __pyx_k_tuple_480 = PyTuple_Pack(16, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__acceleration), ((PyObject *)__pyx_n_s__maximum), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_480)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_480);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_480));
  __pyx_k_codeobj_481 = (PyObject*)__Pyx_PyCode_New(4, 0, 16, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_480, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SAR, 7617, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_481)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7669
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SAREXT( np.ndarray high not None , np.ndarray low not None , double startvalue=-4e37 , double offsetonreverse=-4e37 , double accelerationinitlong=-4e37 , double accelerationlong=-4e37 , double accelerationmaxlong=-4e37 , double accelerationinitshort=-4e37 , double accelerationshort=-4e37 , double accelerationmaxshort=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ SAREXT(high, low[, startvalue=?, offsetonreverse=?, accelerationinitlong=?, accelerationlong=?, accelerationmaxlong=?, accelerationinitshort=?, accelerationshort=?, accelerationmaxshort=?])
 * 
 */
  __pyx_k_tuple_482 = PyTuple_Pack(22, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__startvalue), ((PyObject *)__pyx_n_s__offsetonreverse), ((PyObject *)__pyx_n_s_171), ((PyObject *)__pyx_n_s__accelerationlong), ((PyObject *)__pyx_n_s__accelerationmaxlong), ((PyObject *)__pyx_n_s_172), ((PyObject *)__pyx_n_s__accelerationshort), ((PyObject *)__pyx_n_s_173), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_482)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_482);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_482));
  __pyx_k_codeobj_483 = (PyObject*)__Pyx_PyCode_New(10, 0, 22, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_482, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SAREXT, 7669, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_483)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7727
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SIN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SIN(real)
 * 
 */
  __pyx_k_tuple_484 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_484)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_484);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_484));
  __pyx_k_codeobj_485 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_484, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SIN, 7727, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_485)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7770
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SINH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SINH(real)
 * 
 */
  __pyx_k_tuple_486 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_486)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_486);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_486));
  __pyx_k_codeobj_487 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_486, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SINH, 7770, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_487)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7813
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ SMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_488 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_488)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_488);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_488));
  __pyx_k_codeobj_489 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_488, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SMA, 7813, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_489)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7858
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SQRT( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SQRT(real)
 * 
 */
  __pyx_k_tuple_490 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_490)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_490);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_490));
  __pyx_k_codeobj_491 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_490, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SQRT, 7858, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_491)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7901
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STDDEV( np.ndarray real not None , int timeperiod=-2**31 , double nbdev=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ STDDEV(real[, timeperiod=?, nbdev=?])
 * 
 */
  __pyx_k_tuple_492 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__nbdev), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_492)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_492);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_492));
  __pyx_k_codeobj_493 = (PyObject*)__Pyx_PyCode_New(3, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_492, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__STDDEV, 7901, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_493)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":7947
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCH( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int fastk_period=-2**31 , int slowk_period=-2**31 , int slowk_matype=0 , int slowd_period=-2**31 , int slowd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCH(high, low, close[, fastk_period=?, slowk_period=?, slowk_matype=?, slowd_period=?, slowd_matype=?])
 * 
 */
  __pyx_k_tuple_494 = PyTuple_Pack(23, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__fastk_period), ((PyObject *)__pyx_n_s__slowk_period), ((PyObject *)__pyx_n_s__slowk_matype), ((PyObject *)__pyx_n_s__slowd_period), ((PyObject *)__pyx_n_s__slowd_matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outslowk), ((PyObject *)__pyx_n_s__outslowk_data), ((PyObject *)__pyx_n_s__outslowd), ((PyObject *)__pyx_n_s__outslowd_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_494)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_494);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_494));
  __pyx_k_codeobj_495 = (PyObject*)__Pyx_PyCode_New(8, 0, 23, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_494, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__STOCH, 7947, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_495)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8015
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCHF( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int fastk_period=-2**31 , int fastd_period=-2**31 , int fastd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCHF(high, low, close[, fastk_period=?, fastd_period=?, fastd_matype=?])
 * 
 */
  __pyx_k_tuple_496 = PyTuple_Pack(21, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__fastk_period), ((PyObject *)__pyx_n_s__fastd_period), ((PyObject *)__pyx_n_s__fastd_matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outfastk), ((PyObject *)__pyx_n_s__outfastk_data), ((PyObject *)__pyx_n_s__outfastd), ((PyObject *)__pyx_n_s__outfastd_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_496)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_496);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_496));
  __pyx_k_codeobj_497 = (PyObject*)__Pyx_PyCode_New(6, 0, 21, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_496, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__STOCHF, 8015, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_497)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8081
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCHRSI( np.ndarray real not None , int timeperiod=-2**31 , int fastk_period=-2**31 , int fastd_period=-2**31 , int fastd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCHRSI(real[, timeperiod=?, fastk_period=?, fastd_period=?, fastd_matype=?])
 * 
 */
  __pyx_k_tuple_498 = PyTuple_Pack(18, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__fastk_period), ((PyObject *)__pyx_n_s__fastd_period), ((PyObject *)__pyx_n_s__fastd_matype), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outfastk), ((PyObject *)__pyx_n_s__outfastk_data), ((PyObject *)__pyx_n_s__outfastd), ((PyObject *)__pyx_n_s__outfastd_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_498)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_498);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_498));
  __pyx_k_codeobj_499 = (PyObject*)__Pyx_PyCode_New(5, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_498, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__STOCHRSI, 8081, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_499)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8136
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SUB( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ SUB(real0, real1)
 * 
 */
  __pyx_k_tuple_500 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real0), ((PyObject *)__pyx_n_s__real1), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real0_data), ((PyObject *)__pyx_n_s__real1_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_500)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_500);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_500));
  __pyx_k_codeobj_501 = (PyObject*)__Pyx_PyCode_New(2, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_500, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SUB, 8136, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_501)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8186
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SUM( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ SUM(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_502 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_502)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_502);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_502));
  __pyx_k_codeobj_503 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_502, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__SUM, 8186, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_503)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8231
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def T3( np.ndarray real not None , int timeperiod=-2**31 , double vfactor=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ T3(real[, timeperiod=?, vfactor=?])
 * 
 */
  __pyx_k_tuple_504 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__vfactor), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_504)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_504);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_504));
  __pyx_k_codeobj_505 = (PyObject*)__Pyx_PyCode_New(3, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_504, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__T3, 8231, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_505)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8277
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TAN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ TAN(real)
 * 
 */
  __pyx_k_tuple_506 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_506)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_506);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_506));
  __pyx_k_codeobj_507 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_506, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TAN, 8277, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_507)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8320
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TANH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ TANH(real)
 * 
 */
  __pyx_k_tuple_508 = PyTuple_Pack(12, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_508)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_508);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_508));
  __pyx_k_codeobj_509 = (PyObject*)__Pyx_PyCode_New(1, 0, 12, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_508, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TANH, 8320, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_509)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8363
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TEMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TEMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_510 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_510)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_510);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_510));
  __pyx_k_codeobj_511 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_510, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TEMA, 8363, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_511)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8408
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRANGE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ TRANGE(high, low, close)
 * 
 */
  __pyx_k_tuple_512 = PyTuple_Pack(16, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_512)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_512);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_512));
  __pyx_k_codeobj_513 = (PyObject*)__Pyx_PyCode_New(3, 0, 16, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_512, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TRANGE, 8408, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_513)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8463
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRIMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TRIMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_514 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_514)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_514);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_514));
  __pyx_k_codeobj_515 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_514, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TRIMA, 8463, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_515)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8508
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRIX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TRIX(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_516 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_516)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_516);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_516));
  __pyx_k_codeobj_517 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_516, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TRIX, 8508, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_517)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8553
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TSF( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TSF(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_518 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_518)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_518);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_518));
  __pyx_k_codeobj_519 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_518, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TSF, 8553, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_519)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8598
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TYPPRICE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ TYPPRICE(high, low, close)
 * 
 */
  __pyx_k_tuple_520 = PyTuple_Pack(16, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_520)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_520);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_520));
  __pyx_k_codeobj_521 = (PyObject*)__Pyx_PyCode_New(3, 0, 16, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_520, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__TYPPRICE, 8598, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_521)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8653
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ULTOSC( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod1=-2**31 , int timeperiod2=-2**31 , int timeperiod3=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ULTOSC(high, low, close[, timeperiod1=?, timeperiod2=?, timeperiod3=?])
 * 
 */
  __pyx_k_tuple_522 = PyTuple_Pack(19, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod1), ((PyObject *)__pyx_n_s__timeperiod2), ((PyObject *)__pyx_n_s__timeperiod3), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_522)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_522);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_522));
  __pyx_k_codeobj_523 = (PyObject*)__Pyx_PyCode_New(6, 0, 19, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_522, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__ULTOSC, 8653, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_523)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8712
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def VAR( np.ndarray real not None , int timeperiod=-2**31 , double nbdev=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ VAR(real[, timeperiod=?, nbdev=?])
 * 
 */
  __pyx_k_tuple_524 = PyTuple_Pack(14, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__nbdev), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_524)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_524);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_524));
  __pyx_k_codeobj_525 = (PyObject*)__Pyx_PyCode_New(3, 0, 14, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_524, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__VAR, 8712, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_525)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8758
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WCLPRICE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ WCLPRICE(high, low, close)
 * 
 */
  __pyx_k_tuple_526 = PyTuple_Pack(16, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_526)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_526);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_526));
  __pyx_k_codeobj_527 = (PyObject*)__Pyx_PyCode_New(3, 0, 16, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_526, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__WCLPRICE, 8758, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_527)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8813
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WILLR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ WILLR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_528 = PyTuple_Pack(17, ((PyObject *)__pyx_n_s__high), ((PyObject *)__pyx_n_s__low), ((PyObject *)__pyx_n_s__close), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__high_data), ((PyObject *)__pyx_n_s__low_data), ((PyObject *)__pyx_n_s__close_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_528)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_528);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_528));
  __pyx_k_codeobj_529 = (PyObject*)__Pyx_PyCode_New(4, 0, 17, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_528, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__WILLR, 8813, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_529)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "talib/func.pyx":8870
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ WMA(real[, timeperiod=?])
 * 
 */
  __pyx_k_tuple_530 = PyTuple_Pack(13, ((PyObject *)__pyx_n_s__real), ((PyObject *)__pyx_n_s__timeperiod), ((PyObject *)__pyx_n_s__length), ((PyObject *)__pyx_n_s__begidx), ((PyObject *)__pyx_n_s__endidx), ((PyObject *)__pyx_n_s__lookback), ((PyObject *)__pyx_n_s__real_data), ((PyObject *)__pyx_n_s__outbegidx), ((PyObject *)__pyx_n_s__outnbelement), ((PyObject *)__pyx_n_s__outreal), ((PyObject *)__pyx_n_s__outreal_data), ((PyObject *)__pyx_n_s__i), ((PyObject *)__pyx_n_s__retCode)); if (unlikely(!__pyx_k_tuple_530)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_k_tuple_530);
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_530));
  __pyx_k_codeobj_531 = (PyObject*)__Pyx_PyCode_New(2, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_k_tuple_530, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_213, __pyx_n_s__WMA, 8870, __pyx_empty_bytes); if (unlikely(!__pyx_k_codeobj_531)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initfunc(void); /*proto*/
PyMODINIT_FUNC initfunc(void)
#else
PyMODINIT_FUNC PyInit_func(void); /*proto*/
PyMODINIT_FUNC PyInit_func(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  double __pyx_t_4;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_func(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("func"), __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "talib.func")) {
      if (unlikely(PyDict_SetItemString(modules, "talib.func", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME)); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_module_is_main_talib__func) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  /*--- Type import code ---*/
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
  #if CYTHON_COMPILING_IN_PYPY
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 861; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  __pyx_t_1 = __Pyx_ImportModule("talib.common"); if (!__pyx_t_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ImportFunction(__pyx_t_1, "_ta_check_success", (void (**)(void))&__pyx_f_5talib_6common__ta_check_success, "PyObject *(PyObject *, int, int __pyx_skip_dispatch)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  /*--- Execution code ---*/

  /* "talib/func.pyx":2
 * cimport numpy as np
 * from numpy import nan             # <<<<<<<<<<<<<<
 * from cython import boundscheck, wraparound
 * 
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_n_s__nan));
  PyList_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_n_s__nan));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__nan));
  __pyx_t_3 = __Pyx_Import(((PyObject *)__pyx_n_s__numpy), ((PyObject *)__pyx_t_2), -1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_t_2 = PyObject_GetAttr(__pyx_t_3, __pyx_n_s__nan);
  if (__pyx_t_2 == NULL) {
    if (PyErr_ExceptionMatches(PyExc_AttributeError)) __Pyx_RaiseImportError(__pyx_n_s__nan);
    if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __Pyx_GOTREF(__pyx_t_2);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__nan, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":13
 * ctypedef int TA_MAType
 * 
 * cdef double NaN = nan             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "math.h":
 */
  __pyx_t_3 = __Pyx_GetName(__pyx_m, __pyx_n_s__nan); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_4 == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_5talib_4func_NaN = __pyx_t_4;

  /* "talib/func.pyx":24
 *     object PyArray_GETCONTIGUOUS(np.ndarray)
 * 
 * np.import_array() # Initialize the NumPy C API             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "ta-lib/ta_libc.h":
 */
  import_array();

  /* "talib/func.pyx":347
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ACOS( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ACOS(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_1ACOS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ACOS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":390
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AD( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None ):             # <<<<<<<<<<<<<<
 *     """ AD(high, low, close, volume)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_3AD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__AD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":451
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADD( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ ADD(real0, real1)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_5ADD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ADD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 451; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":501
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADOSC( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None , int fastperiod=-2**31 , int slowperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADOSC(high, low, close, volume[, fastperiod=?, slowperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_7ADOSC, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ADOSC, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":565
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADX( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADX(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_9ADX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ADX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 565; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":622
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ADXR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ADXR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_11ADXR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ADXR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 622; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":679
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def APO( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ APO(real[, fastperiod=?, slowperiod=?, matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_13APO, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__APO, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":726
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AROON( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ AROON(high, low[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_15AROON, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__AROON, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":784
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AROONOSC( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ AROONOSC(high, low[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_17AROONOSC, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__AROONOSC, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 784; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":835
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ASIN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ASIN(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_19ASIN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ASIN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 835; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":878
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ATAN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ ATAN(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_21ATAN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 878; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ATAN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 878; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":921
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ATR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ATR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_23ATR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ATR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 921; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":978
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def AVGPRICE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ AVGPRICE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_25AVGPRICE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__AVGPRICE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 978; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1039
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BBANDS( np.ndarray real not None , int timeperiod=-2**31 , double nbdevup=-4e37 , double nbdevdn=-4e37 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ BBANDS(real[, timeperiod=?, nbdevup=?, nbdevdn=?, matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_27BBANDS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__BBANDS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1039; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1101
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BETA( np.ndarray real0 not None , np.ndarray real1 not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ BETA(real0, real1[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_29BETA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__BETA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1101; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1153
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def BOP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ BOP(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_31BOP, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__BOP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1214
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CCI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CCI(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_33CCI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CCI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1214; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1271
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL2CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL2CROWS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_35CDL2CROWS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL2CROWS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1271; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1332
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3BLACKCROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3BLACKCROWS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_37CDL3BLACKCROWS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL3BLACKCROWS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1393
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3INSIDE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3INSIDE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_39CDL3INSIDE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL3INSIDE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1454
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3LINESTRIKE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3LINESTRIKE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_41CDL3LINESTRIKE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL3LINESTRIKE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1515
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3OUTSIDE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3OUTSIDE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_43CDL3OUTSIDE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL3OUTSIDE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1576
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3STARSINSOUTH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3STARSINSOUTH(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_45CDL3STARSINSOUTH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL3STARSINSOUTH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1637
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDL3WHITESOLDIERS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDL3WHITESOLDIERS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_47CDL3WHITESOLDIERS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDL3WHITESOLDIERS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1698
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLABANDONEDBABY( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLABANDONEDBABY(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_49CDLABANDONEDBABY, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLABANDONEDBABY, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1698; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1761
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLADVANCEBLOCK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLADVANCEBLOCK(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_51CDLADVANCEBLOCK, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLADVANCEBLOCK, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1761; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1822
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLBELTHOLD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLBELTHOLD(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_53CDLBELTHOLD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLBELTHOLD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1822; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1883
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLBREAKAWAY( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLBREAKAWAY(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_55CDLBREAKAWAY, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLBREAKAWAY, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":1944
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCLOSINGMARUBOZU( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCLOSINGMARUBOZU(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_57CDLCLOSINGMARUBOZU, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLCLOSINGMARUBOZU, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1944; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2005
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCONCEALBABYSWALL( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCONCEALBABYSWALL(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_59CDLCONCEALBABYSWALL, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLCONCEALBABYSWALL, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2005; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2066
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLCOUNTERATTACK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLCOUNTERATTACK(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_61CDLCOUNTERATTACK, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLCOUNTERATTACK, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2066; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2127
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDARKCLOUDCOVER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.5 ):             # <<<<<<<<<<<<<<
 *     """ CDLDARKCLOUDCOVER(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_63CDLDARKCLOUDCOVER, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLDARKCLOUDCOVER, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2190
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDOJI(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_65CDLDOJI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLDOJI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2251
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDOJISTAR(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_67CDLDOJISTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLDOJISTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2251; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2312
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLDRAGONFLYDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLDRAGONFLYDOJI(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_69CDLDRAGONFLYDOJI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLDRAGONFLYDOJI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2312; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2373
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLENGULFING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLENGULFING(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_71CDLENGULFING, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLENGULFING, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2434
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLEVENINGDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLEVENINGDOJISTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_73CDLEVENINGDOJISTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLEVENINGDOJISTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2497
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLEVENINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLEVENINGSTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_75CDLEVENINGSTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLEVENINGSTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2560
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLGAPSIDESIDEWHITE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLGAPSIDESIDEWHITE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_77CDLGAPSIDESIDEWHITE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLGAPSIDESIDEWHITE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2560; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2621
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLGRAVESTONEDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLGRAVESTONEDOJI(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_79CDLGRAVESTONEDOJI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLGRAVESTONEDOJI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2621; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2682
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHAMMER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHAMMER(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_81CDLHAMMER, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHAMMER, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2743
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHANGINGMAN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHANGINGMAN(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_83CDLHANGINGMAN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHANGINGMAN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2743; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2804
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHARAMI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHARAMI(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_85CDLHARAMI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHARAMI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2865
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHARAMICROSS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHARAMICROSS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_87CDLHARAMICROSS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHARAMICROSS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2926
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIGHWAVE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIGHWAVE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_89CDLHIGHWAVE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHIGHWAVE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":2987
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIKKAKE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIKKAKE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_91CDLHIKKAKE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHIKKAKE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 2987; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3048
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHIKKAKEMOD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHIKKAKEMOD(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_93CDLHIKKAKEMOD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHIKKAKEMOD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3048; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3109
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLHOMINGPIGEON( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLHOMINGPIGEON(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_95CDLHOMINGPIGEON, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLHOMINGPIGEON, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3170
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLIDENTICAL3CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLIDENTICAL3CROWS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_97CDLIDENTICAL3CROWS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLIDENTICAL3CROWS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3231
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLINNECK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLINNECK(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_99CDLINNECK, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLINNECK, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3292
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLINVERTEDHAMMER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLINVERTEDHAMMER(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_101CDLINVERTEDHAMMER, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLINVERTEDHAMMER, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3353
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLKICKING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLKICKING(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_103CDLKICKING, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLKICKING, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3353; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3414
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLKICKINGBYLENGTH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLKICKINGBYLENGTH(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_105CDLKICKINGBYLENGTH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLKICKINGBYLENGTH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3414; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3475
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLADDERBOTTOM( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLADDERBOTTOM(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_107CDLLADDERBOTTOM, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLLADDERBOTTOM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3536
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLONGLEGGEDDOJI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLONGLEGGEDDOJI(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_109CDLLONGLEGGEDDOJI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLLONGLEGGEDDOJI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3597
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLLONGLINE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLLONGLINE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_111CDLLONGLINE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLLONGLINE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3597; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3658
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMARUBOZU( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLMARUBOZU(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_113CDLMARUBOZU, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLMARUBOZU, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3658; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3719
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMATCHINGLOW( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLMATCHINGLOW(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_115CDLMATCHINGLOW, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLMATCHINGLOW, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3719; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3780
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMATHOLD( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.5 ):             # <<<<<<<<<<<<<<
 *     """ CDLMATHOLD(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_117CDLMATHOLD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLMATHOLD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3843
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMORNINGDOJISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLMORNINGDOJISTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_119CDLMORNINGDOJISTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLMORNINGDOJISTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3843; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3906
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLMORNINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , double penetration=0.3 ):             # <<<<<<<<<<<<<<
 *     """ CDLMORNINGSTAR(open, high, low, close[, penetration=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_121CDLMORNINGSTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLMORNINGSTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3906; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":3969
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLONNECK( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLONNECK(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_123CDLONNECK, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLONNECK, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3969; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4030
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLPIERCING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLPIERCING(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_125CDLPIERCING, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLPIERCING, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4030; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4091
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLRICKSHAWMAN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLRICKSHAWMAN(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_127CDLRICKSHAWMAN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLRICKSHAWMAN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4091; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4152
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLRISEFALL3METHODS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLRISEFALL3METHODS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_129CDLRISEFALL3METHODS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLRISEFALL3METHODS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4213
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSEPARATINGLINES( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSEPARATINGLINES(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_131CDLSEPARATINGLINES, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLSEPARATINGLINES, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4213; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4274
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSHOOTINGSTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSHOOTINGSTAR(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_133CDLSHOOTINGSTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLSHOOTINGSTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4335
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSHORTLINE( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSHORTLINE(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_135CDLSHORTLINE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLSHORTLINE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4396
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSPINNINGTOP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSPINNINGTOP(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_137CDLSPINNINGTOP, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLSPINNINGTOP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4396; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4457
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSTALLEDPATTERN( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSTALLEDPATTERN(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_139CDLSTALLEDPATTERN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLSTALLEDPATTERN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4457; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4518
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLSTICKSANDWICH( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLSTICKSANDWICH(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_141CDLSTICKSANDWICH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLSTICKSANDWICH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4579
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTAKURI( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTAKURI(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_143CDLTAKURI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLTAKURI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4579; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4640
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTASUKIGAP( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTASUKIGAP(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_145CDLTASUKIGAP, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLTASUKIGAP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4640; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4701
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTHRUSTING( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTHRUSTING(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_147CDLTHRUSTING, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLTHRUSTING, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4762
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLTRISTAR( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLTRISTAR(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_149CDLTRISTAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLTRISTAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4823
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLUNIQUE3RIVER( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLUNIQUE3RIVER(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_151CDLUNIQUE3RIVER, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLUNIQUE3RIVER, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4884
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLUPSIDEGAP2CROWS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLUPSIDEGAP2CROWS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_153CDLUPSIDEGAP2CROWS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLUPSIDEGAP2CROWS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4884; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":4945
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CDLXSIDEGAP3METHODS( np.ndarray open not None , np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ CDLXSIDEGAP3METHODS(open, high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_155CDLXSIDEGAP3METHODS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CDLXSIDEGAP3METHODS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5006
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CEIL( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ CEIL(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_157CEIL, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CEIL, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5006; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5049
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CMO( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CMO(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_159CMO, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CMO, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5049; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5094
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def CORREL( np.ndarray real0 not None , np.ndarray real1 not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ CORREL(real0, real1[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_161CORREL, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__CORREL, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5094; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5146
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def COS( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ COS(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_163COS, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__COS, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5189
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def COSH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ COSH(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_165COSH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__COSH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5232
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DEMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ DEMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_167DEMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__DEMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5232; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5277
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DIV( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ DIV(real0, real1)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_169DIV, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__DIV, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5327
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def DX( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ DX(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_171DX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__DX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5384
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def EMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ EMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_173EMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__EMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5429
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def EXP( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ EXP(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_175EXP, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__EXP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5472
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def FLOOR( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ FLOOR(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_177FLOOR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__FLOOR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5515
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_DCPERIOD( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_DCPERIOD(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_179HT_DCPERIOD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__HT_DCPERIOD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5558
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_DCPHASE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_DCPHASE(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_181HT_DCPHASE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__HT_DCPHASE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5558; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5601
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_PHASOR( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_PHASOR(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_183HT_PHASOR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__HT_PHASOR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5601; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5651
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_SINE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_SINE(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_185HT_SINE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5651; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__HT_SINE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5651; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5701
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_TRENDLINE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_TRENDLINE(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_187HT_TRENDLINE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__HT_TRENDLINE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5744
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def HT_TRENDMODE( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ HT_TRENDMODE(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_189HT_TRENDMODE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__HT_TRENDMODE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5744; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5787
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def KAMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ KAMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_191KAMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__KAMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5787; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5832
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_193LINEARREG, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__LINEARREG, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5877
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_ANGLE( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_ANGLE(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_195LINEARREG_ANGLE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__LINEARREG_ANGLE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5922
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_INTERCEPT( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_INTERCEPT(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_197LINEARREG_INTERCEPT, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__LINEARREG_INTERCEPT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5922; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":5967
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LINEARREG_SLOPE( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ LINEARREG_SLOPE(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_199LINEARREG_SLOPE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__LINEARREG_SLOPE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5967; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6012
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ LN(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_201LN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__LN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6055
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def LOG10( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ LOG10(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_203LOG10, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__LOG10, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6055; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6098
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MA( np.ndarray real not None , int timeperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ MA(real[, timeperiod=?, matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_205MA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6098; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6144
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACD( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int signalperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MACD(real[, fastperiod=?, slowperiod=?, signalperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_207MACD, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MACD, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6205
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACDEXT( np.ndarray real not None , int fastperiod=-2**31 , int fastmatype=0 , int slowperiod=-2**31 , int slowmatype=0 , int signalperiod=-2**31 , int signalmatype=0 ):             # <<<<<<<<<<<<<<
 *     """ MACDEXT(real[, fastperiod=?, fastmatype=?, slowperiod=?, slowmatype=?, signalperiod=?, signalmatype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_209MACDEXT, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MACDEXT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6205; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6269
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MACDFIX( np.ndarray real not None , int signalperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MACDFIX(real[, signalperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_211MACDFIX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MACDFIX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6269; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6328
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAMA( np.ndarray real not None , double fastlimit=-4e37 , double slowlimit=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ MAMA(real[, fastlimit=?, slowlimit=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_213MAMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MAMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6381
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAVP( np.ndarray real not None , np.ndarray periods not None , int minperiod=-2**31 , int maxperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ MAVP(real, periods[, minperiod=?, maxperiod=?, matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_215MAVP, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MAVP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6435
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MAX(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_217MAX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MAX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6435; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6480
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MAXINDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MAXINDEX(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_219MAXINDEX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MAXINDEX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6480; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6525
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MEDPRICE( np.ndarray high not None , np.ndarray low not None ):             # <<<<<<<<<<<<<<
 *     """ MEDPRICE(high, low)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_221MEDPRICE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MEDPRICE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6574
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MFI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , np.ndarray volume not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MFI(high, low, close, volume[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_223MFI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MFI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6637
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIDPOINT( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIDPOINT(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_225MIDPOINT, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MIDPOINT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6682
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIDPRICE( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIDPRICE(high, low[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_227MIDPRICE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MIDPRICE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6682; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6733
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MIN( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MIN(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_229MIN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MIN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6778
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MININDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MININDEX(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_231MININDEX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MININDEX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6778; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6823
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINMAX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINMAX(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_233MINMAX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MINMAX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6875
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINMAXINDEX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINMAXINDEX(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_235MINMAXINDEX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MINMAXINDEX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6875; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6927
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINUS_DI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINUS_DI(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_237MINUS_DI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MINUS_DI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6927; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":6984
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MINUS_DM( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MINUS_DM(high, low[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_239MINUS_DM, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MINUS_DM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 6984; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7035
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MOM( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ MOM(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_241MOM, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MOM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7035; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7080
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def MULT( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ MULT(real0, real1)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_243MULT, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__MULT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7080; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7130
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def NATR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ NATR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_245NATR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__NATR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7187
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def OBV( np.ndarray real not None , np.ndarray volume not None ):             # <<<<<<<<<<<<<<
 *     """ OBV(real, volume)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_247OBV, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__OBV, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7237
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PLUS_DI( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ PLUS_DI(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_249PLUS_DI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__PLUS_DI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7237; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7294
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PLUS_DM( np.ndarray high not None , np.ndarray low not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ PLUS_DM(high, low[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_251PLUS_DM, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__PLUS_DM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7294; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7345
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def PPO( np.ndarray real not None , int fastperiod=-2**31 , int slowperiod=-2**31 , int matype=0 ):             # <<<<<<<<<<<<<<
 *     """ PPO(real[, fastperiod=?, slowperiod=?, matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_253PPO, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__PPO, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7345; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7392
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROC( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROC(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_255ROC, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ROC, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7437
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCP( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCP(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_257ROCP, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ROCP, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7482
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCR( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCR(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_259ROCR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ROCR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7527
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ROCR100( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ROCR100(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_261ROCR100, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ROCR100, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7527; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7572
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def RSI( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ RSI(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_263RSI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__RSI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7617
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SAR( np.ndarray high not None , np.ndarray low not None , double acceleration=0.02 , double maximum=0.2 ):             # <<<<<<<<<<<<<<
 *     """ SAR(high, low[, acceleration=?, maximum=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_265SAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7669
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SAREXT( np.ndarray high not None , np.ndarray low not None , double startvalue=-4e37 , double offsetonreverse=-4e37 , double accelerationinitlong=-4e37 , double accelerationlong=-4e37 , double accelerationmaxlong=-4e37 , double accelerationinitshort=-4e37 , double accelerationshort=-4e37 , double accelerationmaxshort=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ SAREXT(high, low[, startvalue=?, offsetonreverse=?, accelerationinitlong=?, accelerationlong=?, accelerationmaxlong=?, accelerationinitshort=?, accelerationshort=?, accelerationmaxshort=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_267SAREXT, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SAREXT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7727
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SIN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SIN(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_269SIN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SIN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7770
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SINH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SINH(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_271SINH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SINH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7770; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7813
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ SMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_273SMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7858
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SQRT( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ SQRT(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_275SQRT, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SQRT, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7858; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7901
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STDDEV( np.ndarray real not None , int timeperiod=-2**31 , double nbdev=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ STDDEV(real[, timeperiod=?, nbdev=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_277STDDEV, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__STDDEV, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7901; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":7947
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCH( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int fastk_period=-2**31 , int slowk_period=-2**31 , int slowk_matype=0 , int slowd_period=-2**31 , int slowd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCH(high, low, close[, fastk_period=?, slowk_period=?, slowk_matype=?, slowd_period=?, slowd_matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_279STOCH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__STOCH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8015
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCHF( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int fastk_period=-2**31 , int fastd_period=-2**31 , int fastd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCHF(high, low, close[, fastk_period=?, fastd_period=?, fastd_matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_281STOCHF, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__STOCHF, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8015; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8081
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def STOCHRSI( np.ndarray real not None , int timeperiod=-2**31 , int fastk_period=-2**31 , int fastd_period=-2**31 , int fastd_matype=0 ):             # <<<<<<<<<<<<<<
 *     """ STOCHRSI(real[, timeperiod=?, fastk_period=?, fastd_period=?, fastd_matype=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_283STOCHRSI, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__STOCHRSI, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8081; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8136
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SUB( np.ndarray real0 not None , np.ndarray real1 not None ):             # <<<<<<<<<<<<<<
 *     """ SUB(real0, real1)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_285SUB, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SUB, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8186
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def SUM( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ SUM(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_287SUM, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__SUM, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8231
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def T3( np.ndarray real not None , int timeperiod=-2**31 , double vfactor=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ T3(real[, timeperiod=?, vfactor=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_289T3, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__T3, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8231; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8277
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TAN( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ TAN(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_291TAN, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TAN, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8320
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TANH( np.ndarray real not None ):             # <<<<<<<<<<<<<<
 *     """ TANH(real)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_293TANH, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TANH, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8363
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TEMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TEMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_295TEMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TEMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8363; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8408
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRANGE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ TRANGE(high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_297TRANGE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TRANGE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8463
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRIMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TRIMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_299TRIMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TRIMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8463; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8508
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TRIX( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TRIX(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_301TRIX, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TRIX, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8553
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TSF( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ TSF(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_303TSF, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TSF, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8553; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8598
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def TYPPRICE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ TYPPRICE(high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_305TYPPRICE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__TYPPRICE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8653
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def ULTOSC( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod1=-2**31 , int timeperiod2=-2**31 , int timeperiod3=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ ULTOSC(high, low, close[, timeperiod1=?, timeperiod2=?, timeperiod3=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_307ULTOSC, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__ULTOSC, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8712
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def VAR( np.ndarray real not None , int timeperiod=-2**31 , double nbdev=-4e37 ):             # <<<<<<<<<<<<<<
 *     """ VAR(real[, timeperiod=?, nbdev=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_309VAR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__VAR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8758
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WCLPRICE( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None ):             # <<<<<<<<<<<<<<
 *     """ WCLPRICE(high, low, close)
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_311WCLPRICE, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__WCLPRICE, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8758; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8813
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WILLR( np.ndarray high not None , np.ndarray low not None , np.ndarray close not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ WILLR(high, low, close[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_313WILLR, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__WILLR, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8813; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8870
 * @wraparound(False)  # turn off relative indexing from end of lists
 * @boundscheck(False) # turn off bounds-checking for entire function
 * def WMA( np.ndarray real not None , int timeperiod=-2**31 ):             # <<<<<<<<<<<<<<
 *     """ WMA(real[, timeperiod=?])
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5talib_4func_315WMA, NULL, __pyx_n_s_214); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s__WMA, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8870; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "talib/func.pyx":8913
 *     return outreal
 * 
 * __all__ = ["ACOS","AD","ADD","ADOSC","ADX","ADXR","APO","AROON","AROONOSC","ASIN","ATAN","ATR","AVGPRICE","BBANDS","BETA","BOP","CCI","CDL2CROWS","CDL3BLACKCROWS","CDL3INSIDE","CDL3LINESTRIKE","CDL3OUTSIDE","CDL3STARSINSOUTH","CDL3WHITESOLDIERS","CDLABANDONEDBABY","CDLADVANCEBLOCK","CDLBELTHOLD","CDLBREAKAWAY","CDLCLOSINGMARUBOZU","CDLCONCEALBABYSWALL","CDLCOUNTERATTACK","CDLDARKCLOUDCOVER","CDLDOJI","CDLDOJISTAR","CDLDRAGONFLYDOJI","CDLENGULFING","CDLEVENINGDOJISTAR","CDLEVENINGSTAR","CDLGAPSIDESIDEWHITE","CDLGRAVESTONEDOJI","CDLHAMMER","CDLHANGINGMAN","CDLHARAMI","CDLHARAMICROSS","CDLHIGHWAVE","CDLHIKKAKE","CDLHIKKAKEMOD","CDLHOMINGPIGEON","CDLIDENTICAL3CROWS","CDLINNECK","CDLINVERTEDHAMMER","CDLKICKING","CDLKICKINGBYLENGTH","CDLLADDERBOTTOM","CDLLONGLEGGEDDOJI","CDLLONGLINE","CDLMARUBOZU","CDLMATCHINGLOW","CDLMATHOLD","CDLMORNINGDOJISTAR","CDLMORNINGSTAR","CDLONNECK","CDLPIERCING","CDLRICKSHAWMAN","CDLRISEFALL3METHODS","CDLSEPARATINGLINES","CDLSHOOTINGSTAR","CDLSHORTLINE","CDLSPINNINGTOP","CDLSTALLEDPATTERN","CDLSTICKSANDWICH","CDLTAKURI","CDLTASUKIGAP","CDLTHRUSTING","CDLTRISTAR","CDLUNIQUE3RIVER","CDLUPSIDEGAP2CROWS","CDLXSIDEGAP3METHODS","CEIL","CMO","CORREL","COS","COSH","DEMA","DIV","DX","EMA","EXP","FLOOR","HT_DCPERIOD","HT_DCPHASE","HT_PHASOR","HT_SINE","HT_TRENDLINE","HT_TRENDMODE","KAMA","LINEARREG","LINEARREG_ANGLE","LINEARREG_INTERCEPT","LINEARREG_SLOPE","LN","LOG10","MA","MACD","MACDEXT","MACDFIX","MAMA","MAVP","MAX","MAXINDEX","MEDPRICE","MFI","MIDPOINT","MIDPRICE","MIN","MININDEX","MINMAX","MINMAXINDEX","MINUS_DI","MINUS_DM","MOM","MULT","NATR","OBV","PLUS_DI","PLUS_DM","PPO","ROC","ROCP","ROCR","ROCR100","RSI","SAR","SAREXT","SIN","SINH","SMA","SQRT","STDDEV","STOCH","STOCHF","STOCHRSI","SUB","SUM","T3","TAN","TANH","TEMA","TRANGE","TRIMA","TRIX","TSF","TYPPRICE","ULTOSC","VAR","WCLPRICE","WILLR","WMA"]             # <<<<<<<<<<<<<<
 */
  __pyx_t_3 = PyList_New(158); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ACOS));
  PyList_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_n_s__ACOS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ACOS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__AD));
  PyList_SET_ITEM(__pyx_t_3, 1, ((PyObject *)__pyx_n_s__AD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__AD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ADD));
  PyList_SET_ITEM(__pyx_t_3, 2, ((PyObject *)__pyx_n_s__ADD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ADD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ADOSC));
  PyList_SET_ITEM(__pyx_t_3, 3, ((PyObject *)__pyx_n_s__ADOSC));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ADOSC));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ADX));
  PyList_SET_ITEM(__pyx_t_3, 4, ((PyObject *)__pyx_n_s__ADX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ADX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ADXR));
  PyList_SET_ITEM(__pyx_t_3, 5, ((PyObject *)__pyx_n_s__ADXR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ADXR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__APO));
  PyList_SET_ITEM(__pyx_t_3, 6, ((PyObject *)__pyx_n_s__APO));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__APO));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__AROON));
  PyList_SET_ITEM(__pyx_t_3, 7, ((PyObject *)__pyx_n_s__AROON));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__AROON));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__AROONOSC));
  PyList_SET_ITEM(__pyx_t_3, 8, ((PyObject *)__pyx_n_s__AROONOSC));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__AROONOSC));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ASIN));
  PyList_SET_ITEM(__pyx_t_3, 9, ((PyObject *)__pyx_n_s__ASIN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ASIN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ATAN));
  PyList_SET_ITEM(__pyx_t_3, 10, ((PyObject *)__pyx_n_s__ATAN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ATAN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ATR));
  PyList_SET_ITEM(__pyx_t_3, 11, ((PyObject *)__pyx_n_s__ATR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ATR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__AVGPRICE));
  PyList_SET_ITEM(__pyx_t_3, 12, ((PyObject *)__pyx_n_s__AVGPRICE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__AVGPRICE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__BBANDS));
  PyList_SET_ITEM(__pyx_t_3, 13, ((PyObject *)__pyx_n_s__BBANDS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__BBANDS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__BETA));
  PyList_SET_ITEM(__pyx_t_3, 14, ((PyObject *)__pyx_n_s__BETA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__BETA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__BOP));
  PyList_SET_ITEM(__pyx_t_3, 15, ((PyObject *)__pyx_n_s__BOP));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__BOP));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CCI));
  PyList_SET_ITEM(__pyx_t_3, 16, ((PyObject *)__pyx_n_s__CCI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CCI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL2CROWS));
  PyList_SET_ITEM(__pyx_t_3, 17, ((PyObject *)__pyx_n_s__CDL2CROWS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL2CROWS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL3BLACKCROWS));
  PyList_SET_ITEM(__pyx_t_3, 18, ((PyObject *)__pyx_n_s__CDL3BLACKCROWS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL3BLACKCROWS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL3INSIDE));
  PyList_SET_ITEM(__pyx_t_3, 19, ((PyObject *)__pyx_n_s__CDL3INSIDE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL3INSIDE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL3LINESTRIKE));
  PyList_SET_ITEM(__pyx_t_3, 20, ((PyObject *)__pyx_n_s__CDL3LINESTRIKE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL3LINESTRIKE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL3OUTSIDE));
  PyList_SET_ITEM(__pyx_t_3, 21, ((PyObject *)__pyx_n_s__CDL3OUTSIDE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL3OUTSIDE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL3STARSINSOUTH));
  PyList_SET_ITEM(__pyx_t_3, 22, ((PyObject *)__pyx_n_s__CDL3STARSINSOUTH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL3STARSINSOUTH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDL3WHITESOLDIERS));
  PyList_SET_ITEM(__pyx_t_3, 23, ((PyObject *)__pyx_n_s__CDL3WHITESOLDIERS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDL3WHITESOLDIERS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLABANDONEDBABY));
  PyList_SET_ITEM(__pyx_t_3, 24, ((PyObject *)__pyx_n_s__CDLABANDONEDBABY));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLABANDONEDBABY));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLADVANCEBLOCK));
  PyList_SET_ITEM(__pyx_t_3, 25, ((PyObject *)__pyx_n_s__CDLADVANCEBLOCK));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLADVANCEBLOCK));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLBELTHOLD));
  PyList_SET_ITEM(__pyx_t_3, 26, ((PyObject *)__pyx_n_s__CDLBELTHOLD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLBELTHOLD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLBREAKAWAY));
  PyList_SET_ITEM(__pyx_t_3, 27, ((PyObject *)__pyx_n_s__CDLBREAKAWAY));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLBREAKAWAY));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLCLOSINGMARUBOZU));
  PyList_SET_ITEM(__pyx_t_3, 28, ((PyObject *)__pyx_n_s__CDLCLOSINGMARUBOZU));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLCLOSINGMARUBOZU));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLCONCEALBABYSWALL));
  PyList_SET_ITEM(__pyx_t_3, 29, ((PyObject *)__pyx_n_s__CDLCONCEALBABYSWALL));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLCONCEALBABYSWALL));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLCOUNTERATTACK));
  PyList_SET_ITEM(__pyx_t_3, 30, ((PyObject *)__pyx_n_s__CDLCOUNTERATTACK));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLCOUNTERATTACK));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLDARKCLOUDCOVER));
  PyList_SET_ITEM(__pyx_t_3, 31, ((PyObject *)__pyx_n_s__CDLDARKCLOUDCOVER));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLDARKCLOUDCOVER));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLDOJI));
  PyList_SET_ITEM(__pyx_t_3, 32, ((PyObject *)__pyx_n_s__CDLDOJI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLDOJI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLDOJISTAR));
  PyList_SET_ITEM(__pyx_t_3, 33, ((PyObject *)__pyx_n_s__CDLDOJISTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLDOJISTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLDRAGONFLYDOJI));
  PyList_SET_ITEM(__pyx_t_3, 34, ((PyObject *)__pyx_n_s__CDLDRAGONFLYDOJI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLDRAGONFLYDOJI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLENGULFING));
  PyList_SET_ITEM(__pyx_t_3, 35, ((PyObject *)__pyx_n_s__CDLENGULFING));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLENGULFING));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLEVENINGDOJISTAR));
  PyList_SET_ITEM(__pyx_t_3, 36, ((PyObject *)__pyx_n_s__CDLEVENINGDOJISTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLEVENINGDOJISTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLEVENINGSTAR));
  PyList_SET_ITEM(__pyx_t_3, 37, ((PyObject *)__pyx_n_s__CDLEVENINGSTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLEVENINGSTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLGAPSIDESIDEWHITE));
  PyList_SET_ITEM(__pyx_t_3, 38, ((PyObject *)__pyx_n_s__CDLGAPSIDESIDEWHITE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLGAPSIDESIDEWHITE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLGRAVESTONEDOJI));
  PyList_SET_ITEM(__pyx_t_3, 39, ((PyObject *)__pyx_n_s__CDLGRAVESTONEDOJI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLGRAVESTONEDOJI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHAMMER));
  PyList_SET_ITEM(__pyx_t_3, 40, ((PyObject *)__pyx_n_s__CDLHAMMER));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHAMMER));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHANGINGMAN));
  PyList_SET_ITEM(__pyx_t_3, 41, ((PyObject *)__pyx_n_s__CDLHANGINGMAN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHANGINGMAN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHARAMI));
  PyList_SET_ITEM(__pyx_t_3, 42, ((PyObject *)__pyx_n_s__CDLHARAMI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHARAMI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHARAMICROSS));
  PyList_SET_ITEM(__pyx_t_3, 43, ((PyObject *)__pyx_n_s__CDLHARAMICROSS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHARAMICROSS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHIGHWAVE));
  PyList_SET_ITEM(__pyx_t_3, 44, ((PyObject *)__pyx_n_s__CDLHIGHWAVE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHIGHWAVE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHIKKAKE));
  PyList_SET_ITEM(__pyx_t_3, 45, ((PyObject *)__pyx_n_s__CDLHIKKAKE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHIKKAKE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHIKKAKEMOD));
  PyList_SET_ITEM(__pyx_t_3, 46, ((PyObject *)__pyx_n_s__CDLHIKKAKEMOD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHIKKAKEMOD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLHOMINGPIGEON));
  PyList_SET_ITEM(__pyx_t_3, 47, ((PyObject *)__pyx_n_s__CDLHOMINGPIGEON));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLHOMINGPIGEON));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLIDENTICAL3CROWS));
  PyList_SET_ITEM(__pyx_t_3, 48, ((PyObject *)__pyx_n_s__CDLIDENTICAL3CROWS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLIDENTICAL3CROWS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLINNECK));
  PyList_SET_ITEM(__pyx_t_3, 49, ((PyObject *)__pyx_n_s__CDLINNECK));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLINNECK));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLINVERTEDHAMMER));
  PyList_SET_ITEM(__pyx_t_3, 50, ((PyObject *)__pyx_n_s__CDLINVERTEDHAMMER));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLINVERTEDHAMMER));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLKICKING));
  PyList_SET_ITEM(__pyx_t_3, 51, ((PyObject *)__pyx_n_s__CDLKICKING));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLKICKING));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLKICKINGBYLENGTH));
  PyList_SET_ITEM(__pyx_t_3, 52, ((PyObject *)__pyx_n_s__CDLKICKINGBYLENGTH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLKICKINGBYLENGTH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLLADDERBOTTOM));
  PyList_SET_ITEM(__pyx_t_3, 53, ((PyObject *)__pyx_n_s__CDLLADDERBOTTOM));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLLADDERBOTTOM));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLLONGLEGGEDDOJI));
  PyList_SET_ITEM(__pyx_t_3, 54, ((PyObject *)__pyx_n_s__CDLLONGLEGGEDDOJI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLLONGLEGGEDDOJI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLLONGLINE));
  PyList_SET_ITEM(__pyx_t_3, 55, ((PyObject *)__pyx_n_s__CDLLONGLINE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLLONGLINE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLMARUBOZU));
  PyList_SET_ITEM(__pyx_t_3, 56, ((PyObject *)__pyx_n_s__CDLMARUBOZU));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLMARUBOZU));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLMATCHINGLOW));
  PyList_SET_ITEM(__pyx_t_3, 57, ((PyObject *)__pyx_n_s__CDLMATCHINGLOW));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLMATCHINGLOW));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLMATHOLD));
  PyList_SET_ITEM(__pyx_t_3, 58, ((PyObject *)__pyx_n_s__CDLMATHOLD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLMATHOLD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLMORNINGDOJISTAR));
  PyList_SET_ITEM(__pyx_t_3, 59, ((PyObject *)__pyx_n_s__CDLMORNINGDOJISTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLMORNINGDOJISTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLMORNINGSTAR));
  PyList_SET_ITEM(__pyx_t_3, 60, ((PyObject *)__pyx_n_s__CDLMORNINGSTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLMORNINGSTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLONNECK));
  PyList_SET_ITEM(__pyx_t_3, 61, ((PyObject *)__pyx_n_s__CDLONNECK));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLONNECK));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLPIERCING));
  PyList_SET_ITEM(__pyx_t_3, 62, ((PyObject *)__pyx_n_s__CDLPIERCING));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLPIERCING));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLRICKSHAWMAN));
  PyList_SET_ITEM(__pyx_t_3, 63, ((PyObject *)__pyx_n_s__CDLRICKSHAWMAN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLRICKSHAWMAN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLRISEFALL3METHODS));
  PyList_SET_ITEM(__pyx_t_3, 64, ((PyObject *)__pyx_n_s__CDLRISEFALL3METHODS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLRISEFALL3METHODS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLSEPARATINGLINES));
  PyList_SET_ITEM(__pyx_t_3, 65, ((PyObject *)__pyx_n_s__CDLSEPARATINGLINES));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLSEPARATINGLINES));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLSHOOTINGSTAR));
  PyList_SET_ITEM(__pyx_t_3, 66, ((PyObject *)__pyx_n_s__CDLSHOOTINGSTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLSHOOTINGSTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLSHORTLINE));
  PyList_SET_ITEM(__pyx_t_3, 67, ((PyObject *)__pyx_n_s__CDLSHORTLINE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLSHORTLINE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLSPINNINGTOP));
  PyList_SET_ITEM(__pyx_t_3, 68, ((PyObject *)__pyx_n_s__CDLSPINNINGTOP));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLSPINNINGTOP));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLSTALLEDPATTERN));
  PyList_SET_ITEM(__pyx_t_3, 69, ((PyObject *)__pyx_n_s__CDLSTALLEDPATTERN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLSTALLEDPATTERN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLSTICKSANDWICH));
  PyList_SET_ITEM(__pyx_t_3, 70, ((PyObject *)__pyx_n_s__CDLSTICKSANDWICH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLSTICKSANDWICH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLTAKURI));
  PyList_SET_ITEM(__pyx_t_3, 71, ((PyObject *)__pyx_n_s__CDLTAKURI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLTAKURI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLTASUKIGAP));
  PyList_SET_ITEM(__pyx_t_3, 72, ((PyObject *)__pyx_n_s__CDLTASUKIGAP));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLTASUKIGAP));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLTHRUSTING));
  PyList_SET_ITEM(__pyx_t_3, 73, ((PyObject *)__pyx_n_s__CDLTHRUSTING));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLTHRUSTING));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLTRISTAR));
  PyList_SET_ITEM(__pyx_t_3, 74, ((PyObject *)__pyx_n_s__CDLTRISTAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLTRISTAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLUNIQUE3RIVER));
  PyList_SET_ITEM(__pyx_t_3, 75, ((PyObject *)__pyx_n_s__CDLUNIQUE3RIVER));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLUNIQUE3RIVER));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLUPSIDEGAP2CROWS));
  PyList_SET_ITEM(__pyx_t_3, 76, ((PyObject *)__pyx_n_s__CDLUPSIDEGAP2CROWS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLUPSIDEGAP2CROWS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CDLXSIDEGAP3METHODS));
  PyList_SET_ITEM(__pyx_t_3, 77, ((PyObject *)__pyx_n_s__CDLXSIDEGAP3METHODS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CDLXSIDEGAP3METHODS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CEIL));
  PyList_SET_ITEM(__pyx_t_3, 78, ((PyObject *)__pyx_n_s__CEIL));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CEIL));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CMO));
  PyList_SET_ITEM(__pyx_t_3, 79, ((PyObject *)__pyx_n_s__CMO));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CMO));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__CORREL));
  PyList_SET_ITEM(__pyx_t_3, 80, ((PyObject *)__pyx_n_s__CORREL));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__CORREL));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__COS));
  PyList_SET_ITEM(__pyx_t_3, 81, ((PyObject *)__pyx_n_s__COS));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__COS));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__COSH));
  PyList_SET_ITEM(__pyx_t_3, 82, ((PyObject *)__pyx_n_s__COSH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__COSH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__DEMA));
  PyList_SET_ITEM(__pyx_t_3, 83, ((PyObject *)__pyx_n_s__DEMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__DEMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__DIV));
  PyList_SET_ITEM(__pyx_t_3, 84, ((PyObject *)__pyx_n_s__DIV));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__DIV));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__DX));
  PyList_SET_ITEM(__pyx_t_3, 85, ((PyObject *)__pyx_n_s__DX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__DX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__EMA));
  PyList_SET_ITEM(__pyx_t_3, 86, ((PyObject *)__pyx_n_s__EMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__EMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__EXP));
  PyList_SET_ITEM(__pyx_t_3, 87, ((PyObject *)__pyx_n_s__EXP));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__EXP));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__FLOOR));
  PyList_SET_ITEM(__pyx_t_3, 88, ((PyObject *)__pyx_n_s__FLOOR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__FLOOR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__HT_DCPERIOD));
  PyList_SET_ITEM(__pyx_t_3, 89, ((PyObject *)__pyx_n_s__HT_DCPERIOD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__HT_DCPERIOD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__HT_DCPHASE));
  PyList_SET_ITEM(__pyx_t_3, 90, ((PyObject *)__pyx_n_s__HT_DCPHASE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__HT_DCPHASE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__HT_PHASOR));
  PyList_SET_ITEM(__pyx_t_3, 91, ((PyObject *)__pyx_n_s__HT_PHASOR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__HT_PHASOR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__HT_SINE));
  PyList_SET_ITEM(__pyx_t_3, 92, ((PyObject *)__pyx_n_s__HT_SINE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__HT_SINE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__HT_TRENDLINE));
  PyList_SET_ITEM(__pyx_t_3, 93, ((PyObject *)__pyx_n_s__HT_TRENDLINE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__HT_TRENDLINE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__HT_TRENDMODE));
  PyList_SET_ITEM(__pyx_t_3, 94, ((PyObject *)__pyx_n_s__HT_TRENDMODE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__HT_TRENDMODE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__KAMA));
  PyList_SET_ITEM(__pyx_t_3, 95, ((PyObject *)__pyx_n_s__KAMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__KAMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__LINEARREG));
  PyList_SET_ITEM(__pyx_t_3, 96, ((PyObject *)__pyx_n_s__LINEARREG));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__LINEARREG));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__LINEARREG_ANGLE));
  PyList_SET_ITEM(__pyx_t_3, 97, ((PyObject *)__pyx_n_s__LINEARREG_ANGLE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__LINEARREG_ANGLE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__LINEARREG_INTERCEPT));
  PyList_SET_ITEM(__pyx_t_3, 98, ((PyObject *)__pyx_n_s__LINEARREG_INTERCEPT));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__LINEARREG_INTERCEPT));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__LINEARREG_SLOPE));
  PyList_SET_ITEM(__pyx_t_3, 99, ((PyObject *)__pyx_n_s__LINEARREG_SLOPE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__LINEARREG_SLOPE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__LN));
  PyList_SET_ITEM(__pyx_t_3, 100, ((PyObject *)__pyx_n_s__LN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__LN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__LOG10));
  PyList_SET_ITEM(__pyx_t_3, 101, ((PyObject *)__pyx_n_s__LOG10));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__LOG10));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MA));
  PyList_SET_ITEM(__pyx_t_3, 102, ((PyObject *)__pyx_n_s__MA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MACD));
  PyList_SET_ITEM(__pyx_t_3, 103, ((PyObject *)__pyx_n_s__MACD));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MACD));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MACDEXT));
  PyList_SET_ITEM(__pyx_t_3, 104, ((PyObject *)__pyx_n_s__MACDEXT));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MACDEXT));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MACDFIX));
  PyList_SET_ITEM(__pyx_t_3, 105, ((PyObject *)__pyx_n_s__MACDFIX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MACDFIX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MAMA));
  PyList_SET_ITEM(__pyx_t_3, 106, ((PyObject *)__pyx_n_s__MAMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MAMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MAVP));
  PyList_SET_ITEM(__pyx_t_3, 107, ((PyObject *)__pyx_n_s__MAVP));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MAVP));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MAX));
  PyList_SET_ITEM(__pyx_t_3, 108, ((PyObject *)__pyx_n_s__MAX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MAX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MAXINDEX));
  PyList_SET_ITEM(__pyx_t_3, 109, ((PyObject *)__pyx_n_s__MAXINDEX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MAXINDEX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MEDPRICE));
  PyList_SET_ITEM(__pyx_t_3, 110, ((PyObject *)__pyx_n_s__MEDPRICE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MEDPRICE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MFI));
  PyList_SET_ITEM(__pyx_t_3, 111, ((PyObject *)__pyx_n_s__MFI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MFI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MIDPOINT));
  PyList_SET_ITEM(__pyx_t_3, 112, ((PyObject *)__pyx_n_s__MIDPOINT));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MIDPOINT));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MIDPRICE));
  PyList_SET_ITEM(__pyx_t_3, 113, ((PyObject *)__pyx_n_s__MIDPRICE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MIDPRICE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MIN));
  PyList_SET_ITEM(__pyx_t_3, 114, ((PyObject *)__pyx_n_s__MIN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MIN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MININDEX));
  PyList_SET_ITEM(__pyx_t_3, 115, ((PyObject *)__pyx_n_s__MININDEX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MININDEX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MINMAX));
  PyList_SET_ITEM(__pyx_t_3, 116, ((PyObject *)__pyx_n_s__MINMAX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MINMAX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MINMAXINDEX));
  PyList_SET_ITEM(__pyx_t_3, 117, ((PyObject *)__pyx_n_s__MINMAXINDEX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MINMAXINDEX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MINUS_DI));
  PyList_SET_ITEM(__pyx_t_3, 118, ((PyObject *)__pyx_n_s__MINUS_DI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MINUS_DI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MINUS_DM));
  PyList_SET_ITEM(__pyx_t_3, 119, ((PyObject *)__pyx_n_s__MINUS_DM));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MINUS_DM));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MOM));
  PyList_SET_ITEM(__pyx_t_3, 120, ((PyObject *)__pyx_n_s__MOM));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MOM));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__MULT));
  PyList_SET_ITEM(__pyx_t_3, 121, ((PyObject *)__pyx_n_s__MULT));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__MULT));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__NATR));
  PyList_SET_ITEM(__pyx_t_3, 122, ((PyObject *)__pyx_n_s__NATR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__NATR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__OBV));
  PyList_SET_ITEM(__pyx_t_3, 123, ((PyObject *)__pyx_n_s__OBV));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__OBV));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__PLUS_DI));
  PyList_SET_ITEM(__pyx_t_3, 124, ((PyObject *)__pyx_n_s__PLUS_DI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__PLUS_DI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__PLUS_DM));
  PyList_SET_ITEM(__pyx_t_3, 125, ((PyObject *)__pyx_n_s__PLUS_DM));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__PLUS_DM));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__PPO));
  PyList_SET_ITEM(__pyx_t_3, 126, ((PyObject *)__pyx_n_s__PPO));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__PPO));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ROC));
  PyList_SET_ITEM(__pyx_t_3, 127, ((PyObject *)__pyx_n_s__ROC));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ROC));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ROCP));
  PyList_SET_ITEM(__pyx_t_3, 128, ((PyObject *)__pyx_n_s__ROCP));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ROCP));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ROCR));
  PyList_SET_ITEM(__pyx_t_3, 129, ((PyObject *)__pyx_n_s__ROCR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ROCR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ROCR100));
  PyList_SET_ITEM(__pyx_t_3, 130, ((PyObject *)__pyx_n_s__ROCR100));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ROCR100));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__RSI));
  PyList_SET_ITEM(__pyx_t_3, 131, ((PyObject *)__pyx_n_s__RSI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__RSI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SAR));
  PyList_SET_ITEM(__pyx_t_3, 132, ((PyObject *)__pyx_n_s__SAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SAREXT));
  PyList_SET_ITEM(__pyx_t_3, 133, ((PyObject *)__pyx_n_s__SAREXT));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SAREXT));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SIN));
  PyList_SET_ITEM(__pyx_t_3, 134, ((PyObject *)__pyx_n_s__SIN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SIN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SINH));
  PyList_SET_ITEM(__pyx_t_3, 135, ((PyObject *)__pyx_n_s__SINH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SINH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SMA));
  PyList_SET_ITEM(__pyx_t_3, 136, ((PyObject *)__pyx_n_s__SMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SQRT));
  PyList_SET_ITEM(__pyx_t_3, 137, ((PyObject *)__pyx_n_s__SQRT));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SQRT));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__STDDEV));
  PyList_SET_ITEM(__pyx_t_3, 138, ((PyObject *)__pyx_n_s__STDDEV));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__STDDEV));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__STOCH));
  PyList_SET_ITEM(__pyx_t_3, 139, ((PyObject *)__pyx_n_s__STOCH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__STOCH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__STOCHF));
  PyList_SET_ITEM(__pyx_t_3, 140, ((PyObject *)__pyx_n_s__STOCHF));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__STOCHF));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__STOCHRSI));
  PyList_SET_ITEM(__pyx_t_3, 141, ((PyObject *)__pyx_n_s__STOCHRSI));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__STOCHRSI));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SUB));
  PyList_SET_ITEM(__pyx_t_3, 142, ((PyObject *)__pyx_n_s__SUB));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SUB));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__SUM));
  PyList_SET_ITEM(__pyx_t_3, 143, ((PyObject *)__pyx_n_s__SUM));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__SUM));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__T3));
  PyList_SET_ITEM(__pyx_t_3, 144, ((PyObject *)__pyx_n_s__T3));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__T3));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TAN));
  PyList_SET_ITEM(__pyx_t_3, 145, ((PyObject *)__pyx_n_s__TAN));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TAN));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TANH));
  PyList_SET_ITEM(__pyx_t_3, 146, ((PyObject *)__pyx_n_s__TANH));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TANH));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TEMA));
  PyList_SET_ITEM(__pyx_t_3, 147, ((PyObject *)__pyx_n_s__TEMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TEMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TRANGE));
  PyList_SET_ITEM(__pyx_t_3, 148, ((PyObject *)__pyx_n_s__TRANGE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TRANGE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TRIMA));
  PyList_SET_ITEM(__pyx_t_3, 149, ((PyObject *)__pyx_n_s__TRIMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TRIMA));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TRIX));
  PyList_SET_ITEM(__pyx_t_3, 150, ((PyObject *)__pyx_n_s__TRIX));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TRIX));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TSF));
  PyList_SET_ITEM(__pyx_t_3, 151, ((PyObject *)__pyx_n_s__TSF));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TSF));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__TYPPRICE));
  PyList_SET_ITEM(__pyx_t_3, 152, ((PyObject *)__pyx_n_s__TYPPRICE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__TYPPRICE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__ULTOSC));
  PyList_SET_ITEM(__pyx_t_3, 153, ((PyObject *)__pyx_n_s__ULTOSC));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__ULTOSC));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__VAR));
  PyList_SET_ITEM(__pyx_t_3, 154, ((PyObject *)__pyx_n_s__VAR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__VAR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__WCLPRICE));
  PyList_SET_ITEM(__pyx_t_3, 155, ((PyObject *)__pyx_n_s__WCLPRICE));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__WCLPRICE));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__WILLR));
  PyList_SET_ITEM(__pyx_t_3, 156, ((PyObject *)__pyx_n_s__WILLR));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__WILLR));
  __Pyx_INCREF(((PyObject *)__pyx_n_s__WMA));
  PyList_SET_ITEM(__pyx_t_3, 157, ((PyObject *)__pyx_n_s__WMA));
  __Pyx_GIVEREF(((PyObject *)__pyx_n_s__WMA));
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s____all__, ((PyObject *)__pyx_t_3)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8913; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;

  /* "talib/func.pyx":1
 * cimport numpy as np             # <<<<<<<<<<<<<<
 * from numpy import nan
 * from cython import boundscheck, wraparound
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s____test__, ((PyObject *)__pyx_t_3)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;

  /* "numpy.pxd":975
 *      arr.base = baseptr
 * 
 * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
 *     if arr.base is NULL:
 *         return None
 */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  if (__pyx_m) {
    __Pyx_AddTraceback("init talib.func", __pyx_clineno, __pyx_lineno, __pyx_filename);
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init talib.func");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif /* CYTHON_REFNANNY */

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result) {
        if (dict != __pyx_b) {
            PyErr_Clear();
            result = PyObject_GetAttr(__pyx_b, name);
        }
        if (!result) {
            PyErr_SetObject(PyExc_NameError, name);
        }
    }
    return result;
}

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (!type) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (Py_TYPE(obj) == type) return 1;
    }
    else {
        if (PyObject_TypeCheck(obj, type)) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%s' has incorrect type (expected %s, got %s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    #if PY_VERSION_HEX < 0x02050000
    if (PyClass_Check(type)) {
    #else
    if (PyType_Check(type)) {
    #endif
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                type = 0;
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) Py_TYPE(type);
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else /* Python 3+ */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *args;
        if (!value)
            args = PyTuple_New(0);
        else if (PyTuple_Check(value)) {
            Py_INCREF(value);
            args = value;
        }
        else
            args = PyTuple_Pack(1, value);
        if (!args)
            goto bad;
        owned_instance = PyEval_CallObject(type, args);
        Py_DECREF(args);
        if (!owned_instance)
            goto bad;
        value = owned_instance;
        if (!PyExceptionInstance_Check(value)) {
            PyErr_Format(PyExc_TypeError,
                         "calling %R should have returned an instance of "
                         "BaseException, not %R",
                         type, Py_TYPE(value));
            goto bad;
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause && cause != Py_None) {
        PyObject *fixed_cause;
        if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        }
        else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        }
        else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%s() takes %s %" CYTHON_FORMAT_SSIZE_T "d positional argument%s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%s to unpack",
                 index, (index == 1) ? "" : "s");
}

static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import = 0;
    py_import = __Pyx_GetAttrString(__pyx_b, "__import__");
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    #if PY_VERSION_HEX >= 0x02050000
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0; /* try absolute import on failure */
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
    #else
    if (level>0) {
        PyErr_SetString(PyExc_RuntimeError, "Relative import is not supported for Python <=2.4.");
        goto bad;
    }
    module = PyObject_CallFunctionObjArgs(py_import,
        name, global_dict, empty_dict, list, NULL);
    #endif
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

static CYTHON_INLINE void __Pyx_RaiseImportError(PyObject *name) {
#if PY_MAJOR_VERSION < 3
    PyErr_Format(PyExc_ImportError, "cannot import name %.230s",
                 PyString_AsString(name));
#else
    PyErr_Format(PyExc_ImportError, "cannot import name %S", name);
#endif
}

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return ::std::complex< float >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      return x + y*(__pyx_t_float_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
      __pyx_t_float_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eqf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sumf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_difff(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_prodf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_quotf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        __pyx_t_float_complex z;
        float denom = b.real * b.real + b.imag * b.imag;
        z.real = (a.real * b.real + a.imag * b.imag) / denom;
        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
        return z;
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_negf(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zerof(__pyx_t_float_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_conjf(__pyx_t_float_complex a) {
        __pyx_t_float_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
    #if 1
        static CYTHON_INLINE float __Pyx_c_absf(__pyx_t_float_complex z) {
          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
            return sqrtf(z.real*z.real + z.imag*z.imag);
          #else
            return hypotf(z.real, z.imag);
          #endif
        }
        static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_powf(__pyx_t_float_complex a, __pyx_t_float_complex b) {
            __pyx_t_float_complex z;
            float r, lnr, theta, z_r, z_theta;
            if (b.imag == 0 && b.real == (int)b.real) {
                if (b.real < 0) {
                    float denom = a.real * a.real + a.imag * a.imag;
                    a.real = a.real / denom;
                    a.imag = -a.imag / denom;
                    b.real = -b.real;
                }
                switch ((int)b.real) {
                    case 0:
                        z.real = 1;
                        z.imag = 0;
                        return z;
                    case 1:
                        return a;
                    case 2:
                        z = __Pyx_c_prodf(a, a);
                        return __Pyx_c_prodf(a, a);
                    case 3:
                        z = __Pyx_c_prodf(a, a);
                        return __Pyx_c_prodf(z, a);
                    case 4:
                        z = __Pyx_c_prodf(a, a);
                        return __Pyx_c_prodf(z, z);
                }
            }
            if (a.imag == 0) {
                if (a.real == 0) {
                    return a;
                }
                r = a.real;
                theta = 0;
            } else {
                r = __Pyx_c_absf(a);
                theta = atan2f(a.imag, a.real);
            }
            lnr = logf(r);
            z_r = expf(lnr * b.real - theta * b.imag);
            z_theta = theta * b.real + lnr * b.imag;
            z.real = z_r * cosf(z_theta);
            z.imag = z_r * sinf(z_theta);
            return z;
        }
    #endif
#endif

#if CYTHON_CCOMPLEX
  #ifdef __cplusplus
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return ::std::complex< double >(x, y);
    }
  #else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      return x + y*(__pyx_t_double_complex)_Complex_I;
    }
  #endif
#else
    static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
      __pyx_t_double_complex z;
      z.real = x;
      z.imag = y;
      return z;
    }
#endif

#if CYTHON_CCOMPLEX
#else
    static CYTHON_INLINE int __Pyx_c_eq(__pyx_t_double_complex a, __pyx_t_double_complex b) {
       return (a.real == b.real) && (a.imag == b.imag);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real + b.real;
        z.imag = a.imag + b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_diff(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real - b.real;
        z.imag = a.imag - b.imag;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_prod(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        z.real = a.real * b.real - a.imag * b.imag;
        z.imag = a.real * b.imag + a.imag * b.real;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_quot(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        __pyx_t_double_complex z;
        double denom = b.real * b.real + b.imag * b.imag;
        z.real = (a.real * b.real + a.imag * b.imag) / denom;
        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
        return z;
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_neg(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real = -a.real;
        z.imag = -a.imag;
        return z;
    }
    static CYTHON_INLINE int __Pyx_c_is_zero(__pyx_t_double_complex a) {
       return (a.real == 0) && (a.imag == 0);
    }
    static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_conj(__pyx_t_double_complex a) {
        __pyx_t_double_complex z;
        z.real =  a.real;
        z.imag = -a.imag;
        return z;
    }
    #if 1
        static CYTHON_INLINE double __Pyx_c_abs(__pyx_t_double_complex z) {
          #if !defined(HAVE_HYPOT) || defined(_MSC_VER)
            return sqrt(z.real*z.real + z.imag*z.imag);
          #else
            return hypot(z.real, z.imag);
          #endif
        }
        static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_pow(__pyx_t_double_complex a, __pyx_t_double_complex b) {
            __pyx_t_double_complex z;
            double r, lnr, theta, z_r, z_theta;
            if (b.imag == 0 && b.real == (int)b.real) {
                if (b.real < 0) {
                    double denom = a.real * a.real + a.imag * a.imag;
                    a.real = a.real / denom;
                    a.imag = -a.imag / denom;
                    b.real = -b.real;
                }
                switch ((int)b.real) {
                    case 0:
                        z.real = 1;
                        z.imag = 0;
                        return z;
                    case 1:
                        return a;
                    case 2:
                        z = __Pyx_c_prod(a, a);
                        return __Pyx_c_prod(a, a);
                    case 3:
                        z = __Pyx_c_prod(a, a);
                        return __Pyx_c_prod(z, a);
                    case 4:
                        z = __Pyx_c_prod(a, a);
                        return __Pyx_c_prod(z, z);
                }
            }
            if (a.imag == 0) {
                if (a.real == 0) {
                    return a;
                }
                r = a.real;
                theta = 0;
            } else {
                r = __Pyx_c_abs(a);
                theta = atan2(a.imag, a.real);
            }
            lnr = log(r);
            z_r = exp(lnr * b.real - theta * b.imag);
            z_theta = theta * b.real + lnr * b.imag;
            z.real = z_r * cos(z_theta);
            z.imag = z_r * sin(z_theta);
            return z;
        }
    #endif
#endif

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned char" :
                    "value too large to convert to unsigned char");
            }
            return (unsigned char)-1;
        }
        return (unsigned char)val;
    }
    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned short" :
                    "value too large to convert to unsigned short");
            }
            return (unsigned short)-1;
        }
        return (unsigned short)val;
    }
    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned int" :
                    "value too large to convert to unsigned int");
            }
            return (unsigned int)-1;
        }
        return (unsigned int)val;
    }
    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
    const char neg_one = (char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to char" :
                    "value too large to convert to char");
            }
            return (char)-1;
        }
        return (char)val;
    }
    return (char)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
    const short neg_one = (short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to short" :
                    "value too large to convert to short");
            }
            return (short)-1;
        }
        return (short)val;
    }
    return (short)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
    const signed char neg_one = (signed char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed char" :
                    "value too large to convert to signed char");
            }
            return (signed char)-1;
        }
        return (signed char)val;
    }
    return (signed char)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
    const signed short neg_one = (signed short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed short" :
                    "value too large to convert to signed short");
            }
            return (signed short)-1;
        }
        return (signed short)val;
    }
    return (signed short)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
    const signed int neg_one = (signed int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed int" :
                    "value too large to convert to signed int");
            }
            return (signed int)-1;
        }
        return (signed int)val;
    }
    return (signed int)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return (unsigned long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned long");
                return (unsigned long)-1;
            }
            return (unsigned long)PyLong_AsUnsignedLong(x);
        } else {
            return (unsigned long)PyLong_AsLong(x);
        }
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned long)-1;
        val = __Pyx_PyInt_AsUnsignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return (unsigned PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned PY_LONG_LONG");
                return (unsigned PY_LONG_LONG)-1;
            }
            return (unsigned PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
            return (unsigned PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
    const long neg_one = (long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to long");
            return (long)-1;
        }
        return (long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long)-1;
            }
            return (long)PyLong_AsUnsignedLong(x);
        } else {
            return (long)PyLong_AsLong(x);
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long)-1;
        val = __Pyx_PyInt_AsLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to PY_LONG_LONG");
            return (PY_LONG_LONG)-1;
        }
        return (PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to PY_LONG_LONG");
                return (PY_LONG_LONG)-1;
            }
            return (PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
            return (PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
    const signed long neg_one = (signed long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed long");
            return (signed long)-1;
        }
        return (signed long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed long");
                return (signed long)-1;
            }
            return (signed long)PyLong_AsUnsignedLong(x);
        } else {
            return (signed long)PyLong_AsLong(x);
        }
    } else {
        signed long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed long)-1;
        val = __Pyx_PyInt_AsSignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed PY_LONG_LONG");
            return (signed PY_LONG_LONG)-1;
        }
        return (signed PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed PY_LONG_LONG");
                return (signed PY_LONG_LONG)-1;
            }
            return (signed PY_LONG_LONG)PyLong_AsUnsignedLongLong(x);
        } else {
            return (signed PY_LONG_LONG)PyLong_AsLongLong(x);
        }
    } else {
        signed PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsSignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        #if PY_VERSION_HEX < 0x02050000
        return PyErr_Warn(NULL, message);
        #else
        return PyErr_WarnEx(NULL, message, 1);
        #endif
    }
    return 0;
}

#ifndef __PYX_HAVE_RT_ImportModule
#define __PYX_HAVE_RT_ImportModule
static PyObject *__Pyx_ImportModule(const char *name) {
    PyObject *py_name = 0;
    PyObject *py_module = 0;
    py_name = __Pyx_PyIdentifier_FromString(name);
    if (!py_name)
        goto bad;
    py_module = PyImport_Import(py_name);
    Py_DECREF(py_name);
    return py_module;
bad:
    Py_XDECREF(py_name);
    return 0;
}
#endif

#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
    size_t size, int strict)
{
    PyObject *py_module = 0;
    PyObject *result = 0;
    PyObject *py_name = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    py_module = __Pyx_ImportModule(module_name);
    if (!py_module)
        goto bad;
    py_name = __Pyx_PyIdentifier_FromString(class_name);
    if (!py_name)
        goto bad;
    result = PyObject_GetAttr(py_module, py_name);
    Py_DECREF(py_name);
    py_name = 0;
    Py_DECREF(py_module);
    py_module = 0;
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%s.%s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if (!strict && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility",
            module_name, class_name);
        #if PY_VERSION_HEX < 0x02050000
        if (PyErr_Warn(NULL, warning) < 0) goto bad;
        #else
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
        #endif
    }
    else if ((size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%s.%s has the wrong size, try recompiling",
            module_name, class_name);
        goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(py_module);
    Py_XDECREF(result);
    return NULL;
}
#endif

#ifndef __PYX_HAVE_RT_ImportFunction
#define __PYX_HAVE_RT_ImportFunction
static int __Pyx_ImportFunction(PyObject *module, const char *funcname, void (**f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(module, (char *)"__pyx_capi__");
    if (!d)
        goto bad;
    cobj = PyDict_GetItemString(d, funcname);
    if (!cobj) {
        PyErr_Format(PyExc_ImportError,
            "%s does not export expected C function %s",
                PyModule_GetName(module), funcname);
        goto bad;
    }
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3 && PY_MINOR_VERSION==0)
    if (!PyCapsule_IsValid(cobj, sig)) {
        PyErr_Format(PyExc_TypeError,
            "C function %s.%s has wrong signature (expected %s, got %s)",
             PyModule_GetName(module), funcname, sig, PyCapsule_GetName(cobj));
        goto bad;
    }
    tmp.p = PyCapsule_GetPointer(cobj, sig);
#else
    {const char *desc, *s1, *s2;
    desc = (const char *)PyCObject_GetDesc(cobj);
    if (!desc)
        goto bad;
    s1 = desc; s2 = sig;
    while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
    if (*s1 != *s2) {
        PyErr_Format(PyExc_TypeError,
            "C function %s.%s has wrong signature (expected %s, got %s)",
             PyModule_GetName(module), funcname, sig, desc);
        goto bad;
    }
    tmp.p = PyCObject_AsVoidPtr(cobj);}
#endif
    *f = tmp.fp;
    if (!(*f))
        goto bad;
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(d);
    return -1;
}
#endif

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,            /*int argcount,*/
        0,            /*int kwonlyargcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,      /*int firstlineno,*/
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_globals = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_VERSION_HEX < 0x03000000
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_VERSION_HEX < 0x03000000
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%s__ returned non-%s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
       return (size_t)-1;
   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
       PyErr_SetString(PyExc_OverflowError,
                       "value too large to convert to size_t");
       return (size_t)-1;
   }
   return (size_t)val;
}


#endif /* Py_PYTHON_H */
